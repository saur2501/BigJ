CS - Postman New Update
    New Features Galore!
        Workspace overview: Get a quick overview of all the activity happening inside a workspace. Manage your workspace by adding helpful description, modifying visibility and inviting team members to collaborate.

        Collection Runner: Collection runner now opens in a tab instead of a new window, helping you switch seamlessly between workflows. Find the new runner on the bottom right corner.

        Monitors: View and work with all of your monitors without having to leave your application. You can now view run details, activity logs, and watch your monitor runs start, execute, and finish in real-time.

        Mock servers: View and edit mock servers in a tab.

        Trash: Accidentally deleted a collection? Fret not. You can recover collections from Trash within the app. Find trash on the bottom right corner.

        Forking and Pull requests: Contributing to collections has never been easier. You can fork a collection from any workspace to create a copy for your reference or development. Moreover, you can request reviews using pull requests from the app.

        Merge checks: Enforce rules on how collections should be updated by setting merge conditions. Click on “Manage roles” in the collection dropdown to edit these. This feature is available on the Business and Enterprise tiers.

        Supercharged profiles: Enrich and customize your user profile and team profile with profile and cover pictures, descriptions and links to your presence on the internet.

        Private API Network: The Private API Network is now available right inside the postman app in the Home section.

        Inline comments in API schema: You can now collaborate and review API schemas more effectively by leaving line-by-line comments.

        Documentation: Postman’s documentation is now closely integrated with requests and collections. You can now easily edit documentation while defining requests and collections and also refer to the documentation while sending a request. Complete documentation view is also available within the app for personal, team and public workspaces.

        Scratch Pad: This release will let you use a space called Scratch Pad, where you can work while not being connected to Postman Servers. All your work will be stored locally and will not be synced.

        API watching: You can watch APIs in any workspace and be alerted about changes made to their specification.
    Postman v8.0
        Postman v8 gives you a consistent, better API development experience. It has universal search across all of Postman, including the Public and Private API Networks, plus you can work on public workspaces directly through the desktop app. This means that the Postman desktop app and Postman on the web are now equally empowering—which one you use is a matter of preference for your workflows.

        Here’s what’s new in this version -

        1. Universal navigation
        1.1 Home
        Introducing the all new Home section in the top navigation. Get an overview of everything happening in your team - activity by team members, new alerts, notifications and a lot more. From here, you can quickly navigate to workspaces, API network, integrations or Postman learning center - wherever you want to go, home is the place to start.



        1.2 Workspaces
        We have a brand new workspace selector which lets you quickly switch between workspaces which were used recently. You can now search through different types of workspaces without having to switch tabs. Just type the name of the workspace you want to go to.

        And oh! We now have public workspaces These are just like any other workspace but visible to everyone on the internet and easily accessible via Postman API network. Create a new public workspace and share your APIs with millions of Postman users around the world.

        1.3 Reports
        Available on the Enterprise and Business tiers, reports help you understand how your organization is building and consuming APIs. Get insights about requests, collection runs and test failures. Administrators can also use reports to analyze how Postman is being used across the organization.

        1.4 Explore
        One stop solution to explore all APIs published in the Postman API network. Browse through different teams and their public workspaces to discover new APIs. Read on to know more about this.

        1.5 Universal Search
        Universal search makes it incredibly easy to search and discover any private or public API element. It looks through all API elements in your account, the private API network, and the Public API Network to help you get started in a few clicks.



        2. A unified interface for web and native
        2.1 Panes
        The main working area is now divided into Panes, which help you customize the Postman interface to match your preferred work environment. You can expand and adjust relevant panes so that the right information is accessible readily.



        2.2 Updated sidebar
        Postman v8 lets you access collections, environments, mock servers, monitors and request history right from the sidebar. You can easily author, search and modify any of these elements without leaving the app. The whole sidebar acts like a pane which can be resized and also collapsed based on your liking.

        2.3 Context bars
        Context bars provide information relevant to the element you’re viewing in a workspace. Here, you can access documentation for an element, see pull requests, add comments or just copy the ID for CI/CD integration.



        3. All the world’s APIs are just a click away
        Postman v8 not only simplifies your API development experience but also makes exploring APIs a piece of cake. Browse through hundreds of third party APIs in the “Explore” section. Here, you can look at collections published by different teams and navigate through them just like you do in your own workspace.

        Interested in an API? Want to send a request? It is just a few clicks away. Just fork the collection into your workspace and you’re good to go.

        But wait! Even you can be a part of the Postman API network. Simply create a public workspace and share your collections in it - they are automatically available to millions of Postman users.

        Like to contribute to someone else’s API? That’s easy too! Fork the collection into your workspace, make the changes and raise a pull request.
EQ - I should love not only family, but also friends and relatives, next I should love my city, state, country and world (meaning people in there).
    This is what ashram entails as its goal.
CS
    If you don't use @Lazy, the framework creates a singleton bean at the application startup and makes sure that the same instance is autowired and reused in all other dependent beans
    REST Controller is multithreaded - It is not the case that the controller will block all subsequent calls while busy. It is multithreaded.
        REST controller is multithreaded as the DisptcherServlet handles multiple requests from the clients concurrently and serves using the respective controller methods.
        Your controller is a singleton by default and your service is singleton by default too.
        So, to make them thread safe - make sure that the operations that take place inside the service must be thread safe
        Use @transactional annotation in spring or implement it yourself.
        We can test this thru a variable increment - have a class with a variable able to take 3 values.
            Let the returned value increment over every call.
    Thread safe - lots of threads in a process will traverse thru a given object (class instance) methods.
        A class is thread-safe if it behaves correctly when accessed from multiple threads,
        regardless of the scheduling or interleaving of the execution of those threads by the runtime environment,
        and with no additional synchronization or other coordination on the part of the calling code.
    Web App - starts with premise of n threads for n requests
        but nothing shared across threads except singleton objects and static class members - variables and methods of the class.
        All threads have different class instances to run on without a problem - nth shared but when threads work on anything shared - then there are potential problems.
        like shared class members or singleton class or classes with limited instances - then you have the problem of thread safety.
        Think of it this way - lots of threads are coming thru Our controller class. Any state information can easily be wronged.
    Rest controllers don't run 1 after the other - although controller instance is shared - all threads run it simultaneously
        so at any given time we can have n threads running thru the singleton controller.
CS - Arch - make 1 straight forward transactional DFD story and then think alternatives.
IDEA - Derivations and discussions. Also delivered in LIB so qualifies for sume.
    Create a transformation matrix for the TSS vector. Any product is also yet another transformational matrix. But convenient for the user.
        chaining of the rules is output becomes input for the other.
        This is being realized thru nested rules - rule that has rule as a function. Good idea. Called rule orchestration.on
        windowing - for sliding average - can think of implementing it in terms of sequences of previous one itself.
            but the problem of late comers. Integral as a solution. I would like to have it but how to explain to the users but gotta explain - not easy to sell.
        Transformation problem solution is quite a work.
            introduce 2 spark jobs - error recognition, outlier recog, and correction, UoM transformations.
            expensive to break everything around monitoring and data ingestion pipeline. Any idea to do it quicker.
            We lose many customers cuz we don't have these basic capabilities.
    Sequential circuits vs combinatorial circuits - when output becomes the input for the same or the other circuit.
        Sequential circuits - can realize polynomial functions of higher order.
        Not that design time team has to do it - even we can do it from inside our spark job - this can be proposed or implemented when time comes.
        @who needs it from hardware when software can do it.
CS - Refactoring
    Doesn't matter lines of code (5-15 is a helpful indicator through). method should do one thing and only one thing.
    Indicators that this is not the case -
        More than one level of indention in a method
        Paragraph Breaks - whitespaces between logical statements.
    fit on screen is very good - imagine if you have to gives reasons to a lawyer.
PIES - Foundation - It is about well being. Divided into 4 as follows
    Attitude - Internal or mental well being. Mental States - personal psyche.
        Can stretch this to include external conduct in personal space.
    Behavior - Well being with respect external conduct (personally or socially) - eg driving car, polity, etc. Social psyche (or personal well being in society)
    Communication - Well being thru Interactions or exchanges. Networking - micro-economics and fun
    Devotion - Well being thru being purpose centric. Scrum. Effectiveness or IQ Motivation.
    Conclusion - Psychology, economics and Motivation is at the heart of this.
        but also social studies for behaviors eg but that can always be studied under ashram.
EQ - Economics
    Price increase does not change demand (only demanded quantity). In economic terms, demand is a reference to how useful a good is to the customer.
    in economics, if they say “demand increases” it means people are willing to pay more for it.
    True demand has it’s root in fundamental human desire, not in economics. It’s a subjective measure of how important a good or service is to a person relative to other goods and services.
    So when we say demand increases, we are suggesting people have changed their view of what is important to them and they want more of a product than they did in the past.
    if ice were simply to become a far more popular product for people to buy, then the companies producing and selling ice might be able to produce it for less, due to economies of scale
    So in general, increased demand increases price when supply kept constant but if supply can be increased then economics of scale takes over.
    Similarly, lower demand, lower cost.
    Higher prices mean less demand. But High demand raises the prices.
    1 ice-creaming then bidding so price shoots. 100 icecream, price drops cuz you have replacements.
    Higher price (than value), you reduce the intake thus demand; lower price, then you over use it.
    So, price is just in middle and price and demand keep affecting and stabilizing each other along with supply.
    There's demand so there's price. Price rising, then demand reduces so you can't increase it too much.
    Study it as human behavior with respect to price in terms of supply and demand. The price is too low, people will desire it more.
        another study, market behavior of price, with respect to demand and supply. You know that people value this, you can rate it high.
CS - Spark - Exception in thread "main" java.lang.NoClassDefFoundError: org/apache/spark/SparkContext
    Caused by: java.lang.ClassNotFoundException: org.apache.spark.SparkContext
    change scope for spark dependencies from provided to compile
CS - Logger
    logger.info - can't write long along - concatenate with string for proper results.
CS - cf Process not found. Memory not sufficient.
    cf delete-orphaned-routes and open cf apps in new terminal.
    launch front end and delete some stopped services. That won't work.
    Delete some running unnecessary services cuz of quota cf org org_name, cf quota quota_name.
IQ - Presentation
    Organize your content.
        Theory and Practical should intersperse - practical really spices things up.
        specification, then end user presentation, architecture, code review.
    Practice 3 times b4 your presentation.
CS - Mac hierarchy - Good UXD.
    Apple icon -> list -> icons -> tabs -> list columns hierarchy -> individual controls / Demo video.
CS - Maven POM - CF 404 - Sometimes even after deployment cf app does not respond and gives 404 not found - although it worked in local. Gotta add following to spring-boot maven plugin.
    <execution>
        <goals>
        <goal>repackage</goal>
        </goals>
    </execution>
    </executions>
CS - Kafka
    Producer
        Properties
            bootstrap.servers - eg - localhost:9092,localhost:9093
            key.serializer - eg org.apache.kafka.common.serialization.StringSerializer
            value.serializer - eg - SupplierSerializer class
            Others in respective places
                props.put("group.id", groupName); - for consumer
                props.put("partitioner.class", "SensorPartitioner"); - for partition
                props.put("speed.sensor.name", "TSS");
        KafkaProducer(props)
        send(ProducerRecord) - exception proned (?asynchronous)
            get() - for synchronous
        send(ProducerRecord, callback(recordMetadata, exception){})
            send(ProducerRecord, new MyProducerCallback())
        producer.close();
    dependencies ->
        ProducerCallback 
            class MyProducerCallback implements Callback {
                public void onCompletion(RecordMetadata, Exception) {}
            }
        ProducerRecord[Object, Object](topic, key, value)
        Partition
            props.put("partitioner.class", "SensorPartitioner");
            Producer(props).
            class SensorPartitioner implements Partitioner {
                configure
                Partition("topic", Object key, byte[] keyBytes, value, valueBytes, Cluster cluster) {}
                close(){}
            }
        SupplierSerializer implements Serializer[Supplier] {
            configure
            serialize(String topic, Supplier data): byte[] {
                id.toString().getBytes("UTF8")
                ByteBuffer.allocate(space)
                ByteBuffer.putInt(id); 
            }
            close
        }
        Deserialize
            Deserialize(topic, byte[] data): Supplier {
                ByteBuffer.wrap(data).getInt();
                new String(ByteBuffer.get(byte[]), "UTF8")
            }
    Consumer
        Properties
            key.deserializer - org.apache.kafka.common.serialization.StringDeserializer
            props.put("group.id", groupName);
            enable.auto.commit, false
            props.load(new FileInputStream("fileName"));
        KafkaConsumer[Object, Object] consumer = new KafkaConsumer[](props);
            consumer.subscribe(Arrays.asList(topicName));
                consumer.subscribe(Arrays.asList(topicName),rebalanceListner);
            records = consumer.poll(100) -> ConsumerRecords
            consumer.commitAsync();
            consumer.commitSync();
                consumer.commitSync(currentOffsets);    //Map[TopicPartition, OffsetAndMetadata] - useful with RebalanceListener
            consumer.close()
        ConsumerRecords[String, Supplier] records = consumer.poll(100);
            records.count()
            record.topic(), record.partition(),record.offset()
            for(ConsumerRecord record: records)
            record.value().getID()
        TopicPartition
            p0 = new TopicPartition(topicName, 0);
            p0.partition()
            consumer.assign(Arrays.asList(p0,p1,p2));
            consumer.position(p0)
            consumer.seek(p0, offset)
            consumer.position(p0)
        rebalanceListner extends ConsumerRebalanceListener
            new RebalanceListner(consumer)
            rebalanceListner.addOffset(record.topic(), record.partition(),record.offset());
                remember topicPartition and OffsetAndMetadata Map.
            onPartitionsRevoked(Collection[TopicPartitions] partitions) {
                use currentOffsets to consumer.commitSync(currentOffsets)
            }
            useful if you had read but not committed and rebalance happened in the meantime.
    AvroProducers and AvroConsumers - ...
    
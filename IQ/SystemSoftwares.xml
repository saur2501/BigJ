<?xml version="1.0" encoding="UTF-8"?>
<SystemSoftwares> Focus mainly on consumption as utils. Also, case studies of software engineering. Important from deployment perspective.
        <OS>
            <IITDelhi>
                    OS- how they work and issues to make them work
                    interesting? Always research- initially mainframes- letting processes share machines
                            today- mobile, cars, embedded devices
                            Hardware changes- large machines 80 cores- right OS for them?
                            OS for desktop ideal for mobile. space mission- much more reliable!
                                    Prove that no bugs in them
                            GPU, memory- how to use all resources in best way- software design problems!!
                    OS- have devices drivers- expose library for system to use.
                            Apps run on top of it- for some operations ask OS.
                    OS could have been 1 big piece of software- if user this, then that and so on
                            not practical? bootloader, shell, graphic window manager, browser and server
                            huge case statement it has- switch case- different pieces of logic put together- they have nth in common.
                            agreement across applications to fit in. I don't want to use mp3 encoder cuz his prog may have bugs and want to do malicious things to my program.
                            It's a SE nightmare to maintain it.
                    Practical- expose an interface- apps run on top of OS- apps run independently
                            all rely on interface and obey interface- follow specification.
                            UNIX- devp by Thompson and richie
                                    I want to run multiple processes on my system- what interface to provide.
                                    H/w components- CPU, memory, disk- processes want to access file A, another file B- coexistence.
                                    RAM- Process A is using B is not using memory vs disk but all coexist but today RAM allow all.
                                    Gave interactive shell- type command- some program runs- it finishes and come back to command prompt.
                                    Need FileSystem
                                            on disk data structure/ interface
                                            Apps requests OS translates to disk requests to serve apps.
                                            File- Strings/streams of characters- called by filename.
                                                    I want to access File A at offset B- translates to disk offset and gives content.
                                                    For manageability- concept of directory- namespace of files organized in hierarchical manner.
                                                    Thus, filenames had a path associated to it- ?in the contexts of directory.
                                            App says open a file- open("Filename");
                                                    File description- a handle is given to me.
                                                    Read on file descriptor- read(fd,buf, 100)- read from file and put into character array buf 
                                                    write(fd,buf,100)- buf is pointer in memory- write into file from buffer array.
                                                    how to read and write into/from disk is abstracted by OS.
                                            another abstraction by shell.
                                                    shell is a part of OS- a program- which gives command prompt- 
                                                    Shell is listening to a port- say keyboard- you type browser
                                                    it treats/interprets "browser" as a file name searches in current directory (where shell is running)
                                                    found then that executable file is run- that file contains instructions for CPU.
                                                    browser file is loaded as application and control is transfered to browser.
                                                            program will run by itself- may make open calls to open files- write calls- some point "exit"
                                                            exit system calls those days- return back to shell- remove "browser" from memory- close all open files, etc.
                                                    OS is giving interfaces to run different programs and let them coexist on disc.
                                    OS did this
                                            1. start/ load a new program
                                            2. Open/ read/ write files
                                            3. exit- frees all allotted resources
                                                    has a return value (integer)- exit(exitCode)

                                    MODEL 1 Design principle is make interface small but powerful
                                            These days shell is separate application which tells OS to do sth- start an application.
                                            These shell instructions or functions form interface of OS- called as kernel functions- system calls.

                                            UNIX provides system call called fork, exec- to start a new program
                                                    exec("Filename")- program makes exec system call- OS searches filename is current directory in filesystem
                                                    if there then replace shell with that particular file name.
                                                    In this model (unlike old), kernel can't jump back to original shell.
                                                    Fork (st spawn)
                                                            Shell running calls fork- 2 apps get created- 1 application creates its replica.
                                                            shell calls fork- 2 shells are created- 1 shell can run- 2 copies same state- same Program counter (next instruction)
                                                            the calling one is called parent and made one called child.
                                                            Program is an executable on disk and Process is running program
                                                            Parent process is stored to disk and child process calls exec("browser")- loads new program by wiping out (shell dies)
                                                            after child calls exit- it is wiped off, parent process from child is loaded and continues from l left off.
                                                            But how do you tell which process is child- which process is parent?
                                                                    thru return value fork returns
                                                                    pid = fork();
                                                                    every process has a pid
                                                                    when fork() returns- parent process pid gets value of child process
                                                                    and child process gets a value (behaves as if fork() was executed)- 0
                                                    Exec takes program to process and dies.
                                                    These fork and exec allowed for any app- any app can model shell.
                                            Let's write a basic shell program
                                                    while(1){
                                                            readCommand();//not system call- but a function- place holder (calls other syscalls)
                                                            ..
                                                            pid = fork();
                                                            if(pid == 0)
                                                                    exec(command);
                                                    }
                                                    uniprocessor where child gets to run first.
                                                    exit- goes away and parent runs next.
                                                    How readCommand() works- key press identified and writing on console
                                                            many processes want to use these shared resources (console and keyboard)- h/w device access is mediated by OS.
                                                            Also, any shared resource is mediated by OS- not stepping on each others' toes.
                                                            1 contrib of UNIX- general interface usable across a variety of devices-
                                                                    OPEN
                                                                            fd = open("Filename");
                                                                            can be extended to keyboards, etc
                                                                            if 7 else is using- OS says I won't allow you to open it.
                                                                            Error- returns -ve value, file or device was not opened.
                                                                            Convention on what is return value
                                                                                    Process is running program- let's draw it as rectangle.
                                                                                    Browser process running
                                                                                    Each process has a file descriptor table
                                                                                            maps file descriptors to file name.
                                                                                            hidden from program- can't read it- but manipulate it using open/ close system calls.
                                                                                            0, 1 , 2 are special entries
                                                                                            I say open file "foo"- search is done, if not open then at first empty entry- "foo" is written.
                                                                                            0- STDIN (standard input from keyboard)
                                                                                            1- STDOUT (..output from console)
                                                                                            2- STDERR (Error)
                                                                                            3- "Foo"
                                                                                            Meaning I am a shell program, I by default read from standard input and write to standard output.
                                                                                            OS decides what is standard input for this program and what's standard output for it.
                                                                                    Eg- write(1,"hello",5);//I am writing on console.
                                                                                    read(0,"buf",100);	//read 100 chars from keyboard.
                                                                    READ
                                                                            read(fd, buf, size)
                                                                            if write only file, then error
                                                                    WRITE
                                                                            write(fd, buf, size)
                                                                            if read only file, then error
                                                                    CLOSE
                                                                            close(fd)- I done with it for others to use.
            Lec2
                    for manageability, structure it nicely.
                    It's lowest layer of software. api/interfaces exposed for applications to use.
                    Designing API is a little complex.
                    while(1){
                            write(1,"$ ",2);	//this is dollar prompt we see on screen.
                                                    //STDOUT opened by shell itself or from parent.
                                                    //fd could point to device, file, network (environment agnostic)
                            readCommand(0,Commands args);	//calls read system call on file descriptor 0- stdin- parses into commands and args.
                            if(pid = fork() == 0)
                                    exec(command, args);
                            else if(pid > 0)
                                    exitCode = wait(0);	//wait till any of my children exits. depends on child code- says exit(1);
                                                            //if accesses illegal memory by child, apt error code- what happened to child- why child crashed
                            else
                                    printf("Error in fork");	//error in fork- it didn't happen
                    }
                    Q- A variable instantiated in a process is in its own private space
                            st we need communication between processes for various reasons
                                    1 way to exit code but limited to child and parent- not any arbitrary
                    MS does differently
                            CreateProcess(command, args)
                                    start new process and no copying
                                    shell redirection- no redirection to file
                                    so pass as arguments- filename, etc- make it bulky
                            Fork can be done fast- don't copy the the whole process- copy only when sth is written to it.
                    How redirection done in shell
                            way1
                                    close(1);
                                    open("foo",WR);	//open file foo in write mode
                                    exec(....);
                                                        <!--
                            way2, $ sh < foo > bar 
                                                        -->
                                    close stdin, open foo and close stdout, open bar
                                    and execute sh
                                    foo.sh- echo one echo two (command says to stdout)
                                    but stdout is much later- at invocation time.
                                    executed and written into bar.
                    FDT again
                            P1 and P2 have their own FDT
                            mapping of FD, has a structure-
                                    where is my resource- file foo
                                    what is its offset- current pointer
                                    when I say write, it starts writing at current pointer.
                                    offset increments on every write system call.
                            If P1 forks P2- FDT gets copied
                                    File Sharing- intermingling of writing- racing condition
                                    insert synchronization to write.
                                    1 way of IPC- what 1 writes is visible to the other process.
                            If P2 says close on FDT- no impact on P1- pointers are being copied.
                    $ ls a b > foo 2> bar
                            stdout directed to foo
                            and stderr to bar 
                            naive
                                    close(1)
                                    open(foo)
                                    close(2)
                                    open(foo)
                    $ ls a b > foo 2> &1 for stdout.
                            Meaning- In FDT, 1's resource is closed and ptr is given for foo so with 2.
                                    overwrite will happen. we wanted was appended (offset racing)
                                    Better have FD 2nd point to Foo of both! (no racing in offset)
                                    Solution- a system call called dup- duplicate 1's pointer to 2.
                                    close(1)
                                    open(foo)
                                    close(2)
                                    dup(1)
                    Count for only unique entries in the file
                    $ uniq
                                                        <!--
                            $ sort < file.txt > tmp1
                                    takes input sorts it and print into stdout
                            $ uniq < tmp1 > tmp2- sort and redirect to tmp1
                            $ wc < tmp2
                            $ rm tmp1 tmp2
                            Output of 1 becomes input for the other- like tools- one's output in input for other.
                                    writing to disc is very costly.
                                    I should have said- connect stdout of sort to stdin of uniq and that with wc
                                    sort -> uniq -> wc
                                    no extra disc space
                                                                        -->
                            Why are processes not allowed to access FDT directly- for security reasons- file system requests- whether this process is authorized for resource.
                                    root user can others can't.
                                    What we are seeing is how processes get to do what they want to do
                                    pipe is very successful for this
                                    pipe is 1 way communication channel
                                    Syntax
                                            int fdarray[2];
                                                    //find the 2 file descriptors and assign them to ends of pipe
                                            pipe(fdarray);
                                                    write(fdarray[1],"hello",5)
                                                    read(fdarray[0],buf,100)
                                                    Here FDT refers to a different resource called pipe.
                                    Pipe inside OS- assigns fd[0] and fd[1] to its 2 ends.
                                            bypassed the HDD
                                            allows IPC across processes
                                    Pipe for IPC
                                            pipe(fdarray);
                                            pid = fork();
                                            if(pid > 0)
                                                    write(fdarray[1],"hello",5)
                                            else
                                                    read(fdarray[0],buf, 100)
                                            Here child will read what parent will write
                                    For our eg
                                            pipe(fdarray);
                                            pid = fork();
                                            if(pid == 0){
                                                    close(1);	//close stdout
                                                    dup(fdarray[1]);	//now stdout gets fdarray[1] data
                                                    exec("sort");
                                            }
                                            similarly, connect otheres stdin to fdarray[0] and you are good to go.
                                    Solution: 
                                                                                        <!--
                                                                                        sort < file.txt | uniq | wc
                                                                                        -->
                                            used by shell using pipe system call (home work)
                                            This raises the problem of consumer producer problem!
                                            Pipe is full- block the process- not allowed to run till the pipe gets space!
                                            these processes can dance together.
                                            This preemption is time efficient and balance
                                            pipe is limited by size of MM- and other things also!
                                            How OS releases pipe resources
                                                    system call- close on pipe (like file)- if 1 end of pipe is not referred to by any process- we may release the resource.
            Lec3
                    Process is running program- live state associated with it
                    abstraction of process is that it is private to it- called as address space cuz 1 million- different locations in different processes.
                    abstraction is also implemented by OS- process also means it will have its address space.
                    independent process and don't worry for other- browser doesn't worry about shell- cuz they executing in independent address space.
                    whenever shared resources reqd- they use system calls or memory.
                            shared resources like devices, files, memory- process asks OS for resource- if legal then concurrent accesses prohibited.
                            fork- create a process- List of process is also kinda resource- if wanna create- I want to create- if enough resources, enough memeory, then created with id else -ve error code.
                            open- do I have permissions to open the file or not.
                            OS is arbitrator between processes- untrusted and resource. Program that you don't trust- 
                                    could be greedy (resources), 
                                    malicious (crash the system)
                                    Or Buggy (crashes the system)
                            Security- untrusted processes shouldn't take control of system in untrusted way
                            Performance- different interface have their trade offs- fork vs createProcess
                    Process is presented in hierarchy of their creation
                            init on boot
                                    fork processes and they spawn further- like shell, xserver, etc
                                    looks like tree with pipes or inter process channels between them.
                            other IPC- make a channel and read from there.
                    Signal- another abstraction
                            To interrupt a process to say that you want to do sth else
                            Process is sequential flow of instruction- normal flow
                            key was pressed- process is signalled with a signal- semantic of signal is amounts to asynchronous system call.
                            OS raises a signal- interrupts current execution- makes a functional call to signal handler.
                            this is handler is registered b4- executes in the address space of process- can see/read/write that process can.
                            when signal handler returns, process continues from interruption.
                            It is like an asynchronous function call.
                            Signal handlers are private to processes- process1 registers signal handler- process2 under exec and signal occurs- process1's will not be executed.
                            It is as good as placing a function call at the  interrupt point in execution.
                            Makes a process to expose an interrupt driven interface.
                            press of key, arrival of network packet.
                            2 LINUX system calls which support signal abstraction.
                                    kill- kill(pid, signum)
                                            1 process can send signal to another process.
                                            rules- can't send to process by another user- only certain types, etc.
                                            kill -9 (sigkill) , etc
                                    signal- (int signum, void (*handler)(int))	
                                            signal number, function pointer
                                            process can register handlers for signals
                                            set of standard signals- part of OS semantics
                                            Eg- SIGINT- on press of ctrl+c while process executes.
                                                    causes asynchronous call for handler- most times- process exits
                                                    process can be overridden- number of times ctrl+c was pressed during execution
                                                    or start afresh or release this data structure.
                                            signal system call is used to register signal system call with a signal number
                                                    SIGINT has a number 7 or sth- with signal interrupt number 7- this is the handler
                                                    can I override all signals? SIGSTP (on ctrl+z)- our user will completely lose control on what process can do
                                                    certain signals allowed to override and others.
                                                    people use same handler by different signal numbers
                                            SIGSEGV- segmentation fault
                                                    process does sth illegal- touch what not supposed to touch
                                                    accesses address what not supposed to access
                                                    default handlers will stop the process
                                            SIGFPE- floating point exception (div by 0)
                                                    similar results as SIGSEGV
                                            SIGCHLD- if one child process exits
                                                    I wanted child process to run concurrently
                                                    I start browser window- spawn a new window and want coexistence.
                                                    want parent to be informed that child is exited for DS to maintained by parent.
                                                    ls was spawned as new process and shell waited- vs ls &- spawn a new process and don't wait for it- make it separate.
                                                    think of $browser &- but return status when comes back.

                    I am process P1 and spawn P2 which says exit()
                            should OS delete all state of P2 or retain sth- cuz p1 might have written wait- needs the exit code of P2.
                            Resp of OS to preserve exit code so that if P1 asks it can be given.
                            Process is truly cleaned (some state remains) up after parent process says wait on it.
                                    till that time it is called zombie process (just lingering around)- this bug common.
                                    programmer forgets to call wait on child and causes, process leak.
                            Long running app then eventually you will run out of memory.
                    Shell I say- ls &
                            ls will finish and exit but will remain zombie if exit code!
                            solution- has any spawned child, shell check periodically- any exitted but frequency- 1 hour, 1 sec, etc.
                                    signals can be used- if child exits- a SIGCHLD generated in shell.
                                    SIGCHLD handler- wait on it- do anything with exit status.
                    Open, read, write, close
                            we saw for files and devices
                            modern OS- does much more
                            Number of processes in the system
                            which process has how much memory allocated and which spaces
                            ps- all processes with dependencies and memory consumption
                            top- 
                            Process may be interested in lots of info from OS
                                    at run time- OS can give facility- change running CPU on system.
                                    16 processors but only 1 to be on- app can say that.
                                    OS has plethora of such burdens
                                    how many systam calls should OS provide- seems daunting.
                            so, LINUX uses pseudo-file system called /proc
                                    lives inside our file system but process id 101, 102, etc
                                    /proc has subdirectories- all process ids.
                                    ps just needs to see /proc and read its content.
                                    all info OS wishes to expose are part of this pseufo file system
                                    app just needs to use open, read, write system calls to read.
                                    simple constraint could be I can read my own resource usage not others.
                            changing active CPU- num_active_cpu system calls
                                    others are switched off.
                    LINUX has 300 system calls- not in 1000s or Millions.
                    Producer consumer
                            write by P1 and read by P2 on pipe
                            synchronization is needed- communicate and restrict their behavior based on that of other
                            this is expensive- system call made for OS- OS does a few things- get args, process them, copy, address- overheads!
                            Another solution is keep shared memory- kernel is out of picture from this.
                                    read and write are just on memory cells- much cheap!
                            This scenario where 2 different entities that coexist and share address space are called threads!
                            Thread is execution flow! 2 thread can have their own flow
                                    Process = Thread + address Space
                                    meaning process can have execution flow with its own address space.
                                    2 threads can share the same address space for a process.
                            Advantages
                                    processes- diffn processes running diffn programs- 1 process running on CPU, 1 waiting for disk, 1 waiting for network => full h/w resources utilized.
                                            shell waiting for keyboard input. Compiler running on CPU.
                                            browser waiting on network card for next packet.
                                            vs this part of program waiting for network, that part for CPU.
                                            on spilling OS has full visibility, this process looking for n/w, cpu.
                                    if multiprocesses systems, we can use other processes if multiple threads of control.
                                            just 1 thread of control- other CPU never runs.
                                            more concurrency and util of system- waiting for different parts of CPU.
                                            advantage- share address space => fast IPC.
                                            problem- no isolation- what 1 does, other not protected from it.
                                            they need to know each other- compiler and browser didn't different address space.
                                            same threads need safeguarding.
                                    How to create threads?
                                            Process- let's call it address space
                                            Fork spawning new address space and a new thread of control.
                                            now from OS- create a new thread of control without spawning new address space.
                                                    system calls to have multiple threads on same address space.
                                            OS sees independent different threads of control- can execute on different CPU provided that same address space is mapped on both CPU.
                                    Another way of implementing threads
                                            OS has no idea of multiple threads- internally some kinda system which emulates multiple threads of control.
                                            If 1 thread says exit, makes other threads exit also cuz not awareness of OS.
                                            how to do it in terms of our abstractions?
                                            1 thread says read and read to disk- all threads get blocked as if whole process said.
                                            read on network, whole process blocked- bad hardware usage.
                                            Wrap thread_exit in your own system call- which blocks it b4 it goes to OS.
                                            but what about read from network, process gets blocked.
                                            Clearly there is no concurrency on this system but logically they can be made to look like concurrent.
                                                    maintain a scheduler- multiple thread- this thread gets to run- they yield and 7 else is given a chance.
                    Process should not run away with CPU- OS should have a way to take the control back
                            interrupt is used- process running- interrupt happens- it is OS's interrupt handler
                            it says this process running too long, give other process a turn.
                            Also user level, user can register a signal "alarm" which lets process tell OS that signal timer be gererated 100 ms- SIGTIMER is generated
                            handler is called- which maintains all active threads in system- takes running to suspends it puts in ready queue. another thread, set running and return!
                            This implements Preemption! Emulate scheduler inside a thread
                            In some sense, signals abstraction of unix- parallels to that of hardware.
                    Benefits of user-level threads (former was kernel level)
                            kernel gave physical level concurrency
                            User level- context switch is much easy- I want to yield- process is told- no kernel processing- which is more expensive.
                            multiple user level can be mapped to kernel levels.
                            Kernel is general for all apps- user level has custom policy that suits app.
                            S/w is written in a style and we want to run in different envt
                            envt s.t kernel doesn't support kernel level threads- then same program in this envt- abstract as user level threads.
                            abstract as user level thread- fooling machine that it has thread but it has 1 thread.
                            different envt-- work on new library- fooling a program to believe that it has threads but working on single kernel thread.
                    Interrupts are rare- comes and OS interrupt handler is called and signal for App comes, signal handler is called for process.

            </IITDelhi>
            <Others>
                OTHERS
                    class CommonFile{
                            private string name;
                            private Folder parent;
                            public abstract void open();
                            public abstract void draw();
                            public abstract void setParent(Folder* parent);
                            public abstract void getParent();
                    }
                    class Folder extends CommonFile{
                            <!--List < CommonFile > children; -->
                            public void open(){}
                            public void draw; 	//draws folder differently
                    }
                    class File extends CommonFile{
                            //Function ptr
                            public void open();
                    }
            </Others>
            <IITKGP>
                Computer System
                Bare Machine
                Extended Machine- Run Time Environment (BIOS Kernel)
                User Interface- Applications (DB, Compilers, Biz, Games), Utilities (Text Editing, docs)- Shell
                User- Asserts Run program P- it uses shell (UI) 
                        to invoke App Progs 
                        which in turn use Kernel (Read 'a'- kernel does it for me)
                <ConcurrentProcessing>
                        <Condition>
                            2 statements can be concurrent iff
                                    W(Si) INTERSECTION W(Sj) = PHI
                                    R(Si) INTERSECTION W(Sj) = PHI
                                    W(Si) INTERSECTION R(Sj) = PHI
                            Eg- 
                                    S1: a = x + y;
                                    S2: b = z + 1;
                                    S3: c = a + b;
                                    S4: d = c - 1;
                            Look for common variables in 2 statements- ok if only in R(Si)
                        </Condition>
                        <ThreadsUsingFork>
                                a new process gets spawned which forks to branch and other continues along the execution.
                                Eg-
                                        begin
                                        S1
                                        fork L1
                                        S2
                                        S4
                                        fork L2
                                        S5
                                        L3: join
                                        S7
                                        end
                                        L1: S3
                                         goto L3
                                        L2: S6
                                         goto L3
                                        join count
                                         count = count - 1;
                                         if (count != 0) then quit

                                        S1->S2->S4->S6->S7
                                         |   |->S5->S6->S7
                                         |->S2->        S7
                        </ThreadsUsingFork>
                        <UsingCobeginCoEnd>
                                begin
                                S1
                                Cobegin

                                 S3		//I

                                 begin		//II
                                  S2
                                   Cobegin
                                    S4		//I
                                    S5		//II
                                   Coend
                                  S6
                                 end

                                Coend
                                S7
                                end

                                Not possible in all cases
                                Eg- refer to notes- when another fork along concurrent process and merges ahead.
                        </UsingCobeginCoEnd>
                        <EgApp>
                                REL Producer Consumer Problem
                                        2 parallelly running independent processes using common memory called buffer.
                                                Eg- Printer, etc.
                                        Producer -> BUFFER -> Consumer Process
                                        Buffer with shared variables
                                                array[0..n-1] of type item;
                                                in, out = 0..n-1;	//items from out to in (in cycle)
                                                nextp, nextc : item;
                                                in = out = 0; (starting point)
                                        cobegin
                                        Producer:		//insert item at in
                                                begin
                                                 while(1){
                                                  ..
                                                  produce an item in nextp;
                                                  while(((in+1)%n)==out) {}
                                                  buffer[in] = nextp;
                                                  in = (in + 1) % n;
                                                 }
                                                end
                                        Consumer:		//delete item at out
                                                begin
                                                 while(1){
                                                  while(in==out) {}
                                                  nextc = buffer[out];
                                                  out = (out + 1) % n;
                                                  ..
                                                  consume an item in nextc;
                                                  ..
                                                 }
                                                end
                                        coend
                        </EgApp>
                        <CriticalSectionProblem>
                                The code which uses shared variables overwrite contents resulting in bad outcomes- bad performance or data erosion, etc
                                <IntroToCriticalSection>
                                    Some interleaving of the processes will mess with the buffer contents or output.
                                            ?In producer Consumer, in and out works well but uses 1 cell less all the time!
                                            Change the code
                                                    cobegin
                                                    Producer:		//insert item at in
                                                            begin
                                                             while(1){
                                                              ..
                                                              produce an item in nextp;
                                                              while(count == n) {}
                                                              buffer[in] = nextp;
                                                              in = (in + 1) % n;
                                                              count++;
                                                             }
                                                            end
                                                    Consumer:		//delete item at out
                                                            begin
                                                             while(1){
                                                              while(count == 0) {}
                                                              nextc = buffer[out];
                                                              out = (out + 1) % n;
                                                              count--;
                                                              ..
                                                              consume an item in nextc;
                                                              ..
                                                             }
                                                            end
                                                    coend
                                            Looks like a promising code but let's analyse
                                                    count-- and count++ can wipe off others effect
                                                            uses register- R1 increments it.
                                                            2nd uses R2 decrements it- writes back.
                                                            then R1 writes back.
                                                    W(S1) INTERSECTION W(S2) != PHI
                                                    ?that with Read Set is important in sequence
                                                    This will make a mess out of our data structure.
                                                            cuz count gives absolutely wrong picture of degree of filling.
                                                            would claim full when it's empty.
                                                            would claim empty when data is there- overwriting.
                                </IntroToCriticalSection>
                                <ConditionsDesired>
                                3 conditions to be satisfied
                                        Mutual Exclusion- While 1 code reads/writes shared variable other can't write/read it.
                                                read read is allowed.
                                        Progress- demanding proc compete for turn (Sequence- no1 is special; 1 can't take hold of it)
                                        Bounded waiting- codes should not take monopoly over shared variable making a proc wait unlimitedly.
                                </ConditionsDesired>
                                <SoftwareSolution>
                                        Every Program write an entry section and exit section using shared variables to make a criteria for entry (can we use non-shared?)
                                        Code
                                        Entry SECTION
                                         CS
                                        Exit SECTION
                                        Code
                                Eg1- P1 and P2
                                shared variable: turn = 1..2; (initialize with 1 (say))
                                Pi:
                                        while(turn != i) {}	//I wait if not my turn
                                                CS
                                        turn = j;		//give turn to the other
                                Analyse
                                        MEX?- YES; until 1 writes that it's others turn he can't enter CS.
                                        Progress- if P1 toggles P2 for next chance which may not even want it- will make P1 wait unlimitedly.
                                                P1 and P2 are bound to toggle in execution of CS.
                                Eg2- P1 and P2
                                shared variable: array[0..1] of boolean
                                Pi:
                                        while(flag[j] != false) {}	//if others in not in CS, then I go and converse is true
                                        flag[i] = true;			//I am entering CS
                                                CS
                                        flag[i] = false;		//I am exiting CS
                                Analyse
                                        MEX?- No; both read 1st statement together and say,"no1 in CS, I am going"
                                Eg3- P1 and P2
                                Shared Variable: array[0..1] of boolean
                                Pi:
                                        flag[i] = true;			//I plan entering CS
                                        while(flag[j] == true) {}	//proceed if other doesn't plan so
                                                CS
                                        flag[i] = false;		//I am out.
                                Analyse
                                        if both want to enter together- both won't be able to go.
                                        MEX?- Yes
                                        Bounded Wait- No
                                        Progress- ?ok.
                                Eg4- P1 and P2
                                Shared Variable: array[0..1] of boolean
                                        turn:0..1;
                                Pi: Morality wins the show!!
                                        flag[i] = true;			//I plan enter CS
                                        turn = j;			//turn is of other
                                        while(flag[j] && turn==j) {}	//wait iff other proc in turn want to enter.
                                                CS
                                        flag[i] = false;		//I am out
                                Analyse
                                        while I as a process start execution, others can be in different portion of their code.
                                        MEX- Yes; if his flag is true (and I gave him turn)- my wait until exit is guaranteed.
                                        Progress- flag makes sure that unwilling process doesn't count.
                                        Bounded Wait- flag makes sure that exit of 1 trigger the waiting process.
                                n-ProcessCriticialSection
                                        Refer to Notes
                                </SoftwareSolution>
                                <HardwareSolutions>
                                        <Test_and_Set>
                                                Uses
                                                        boolean Test_and_Set(boolean *target){
                                                                Test_and_Set = *target;
                                                                *target = true;
                                                                return Test_and_Set;
                                                        }
                                                        swap(boolean a, boolean b)	//regular.
                                                Shared Variable: boolean waiting[0..n-1]
                                                        boolean lock = false (initialize), key;
                                                        var j:0..n-1;
                                                Pi:
                                                        waiting[i] = true;	//I plan for CS
                                                        key = true;		//I have the key
                                                        while(waiting[i] && key)
                                                                key = Test_and_Set(&lock);	//lock is imposed (true) and only first proc gets key = false
                                                                waiting[i] = false;

                                                                CS
                                                        j = (i+1)%n;		//my next proc j
                                                        while(j != i && !waiting[j])	//check which proc j plans for CS.
                                                                j = (j+1) % n;
                                                        if(j == i)			//if no1 waiting, remove lock
                                                                lock = false;		//lock removed
                                                        else waiting[j] = false;	//first proc in sequence is next to enter.
                                                Analysis- All pass
                                        </Test_and_Set>
                                        <Semaphores>
                                                Uses
                                                                                                                <!--
                                                        P(S){	//clog on 0 or negative S, decrement if positive
                                                                while(S<=0){}
                                                                S--;
                                                        }
                                                        V(S):S = S + 1; //increment S
                                                                                                                -->
                                                Shared Variable: mutex (semaphore) = 1 (initialization)
                                                Pi:
                                                        P(mutex)	//mutex made 0
                                                                CS
                                                        V(mutex)	//mutex made 1
                                                        RS
                                                Analysis
                                                        MEX? Yes- 2 procs can't execute P(mutex) simultaneously- hardware issue- so 1st 1 thru and others clog.
                                                        Progress- Yes- unwilling gets no chance
                                                        Unbounded wait- ?No- compete for P(S)
                                        </Semaphores>
                                </HardwareSolutions>
                        </CriticalSectionProblem>
                        <ProcessSynchronization>
                                Statement Si of Pi must be executed before Statement Sj of Pj
                                Shared Variable: semaphore sync = 0:
                                        Pi:
                                                ....
                                                Si
                                                V(sync)
                                                ....
                                        Pj:
                                                ...
                                                P(sync)
                                                Sj
                                                ...
                                <nSynchronization>
                                Decide sequence of execution of statements [of processes] or processes
                                        Given a graph of precedence of execution- plan execution
                                        insert semaphores- 
                                        semaphore a,b,c,d,...g = 0	//all locked up
                                        begin
                                                cobegin
                                                        begin S1; V(a); V(b); end (opens locks giving possibilities)
                                                        begin P(a); S2; S4; V(c); V(d); end 
                                                        begin P(b); S3; V(e); end
                                                        ....
                                                        ...
                                                coend
                                        end
                                </nSynchronization>
                                <Modification>
                                Modification: Infinite loop to waiting
                                        struct semaphore{
                                                int value;
                                                List< Process > proc;
                                        } S;
                                        P(S):
                                                S.value--;
                                                if(S.value < 0){
                                                        add this process to S.proc;
                                                        block(P);
                                                }
                                        V(S):
                                                S.value++;
                                                if(S.value <= 0){	//sleeping procs exist
                                                        remove a process P from S.proc;
                                                        wakeup(P);
                                                }
                                </Modification>
                                <Eg>
                                    <ProducerConsumerProblem>
                                        Shared Variables:
                                                Semaphore full, empty, mutex;
                                                item nextp, nextc;
                                                full = 0;	//no of full cells
                                                empty = n;	//no of empty cells
                                                mutex = 1;
                                        P:
                                                while(true){
                                                        produce an item in nextp;
                                                        P(empty);	//if empty spaces exist
                                                        P(mutex);
                                                        ...
                                                        add nextp to buffer;
                                                        ...
                                                        V(mutex);
                                                        V(full);	//full increased
                                                }
                                        C:
                                                while(true){
                                                        P(full);	//if full spaces exist
                                                        P(mutex);
                                                        ...
                                                        remove an item from buffer to nextc;
                                                        ..
                                                        V(mutex);
                                                        V(empty);	//empty spaces inc
                                                }
                                    </ProducerConsumerProblem>
                                    <ReaderWriterProblem>
                                        n ppl can read together 
                                        if even 1 reads, writing is not possible
                                                reverse is allowed- while writing one can read.
                                                while 1 writes, another can't write.
                                        shared variables: semaphore mutex = 1, wrt = 1;
                                                int readCount = 0;
                                        Reader:
                                                P(mutex);
                                                readCount++;
                                                if(readCount>=1)
                                                        P(wrt);	//no1 can write
                                                V(mutex);
                                                ....
                                                READ
                                                ....
                                                P(mutex);
                                                readCount--;
                                                if(readCount==0)
                                                        V(wrt);	//writing possible
                                        Writer:
                                                P(wrt);
                                                ...
                                                WRITE
                                                ..
                                                V(wrt);
                                    </ReaderWriterProblem>
                                </Eg>
                        </ProcessSynchronization>
                </ConcurrentProcessing>
                <Deadlock>
                Deadlock- (a set of procs are in deadlock) when every process in the set waits for an event that can only be caused by another process in the set.
                        Eg- Process P1 needs A and B to finish; P2 also needs A and B
                                A is allocated to P1. P1 wants B but P2 won't leave B (allocated) and P2 needs A to finish itself.
                        Process-Resource Relation- 
                                Processes ask OS for instances of resource to finish their execution.
                                Request
                                Use
                                Release
                        <NecessaryConditions>
                        Necessary Conditions (AND)
                                Mutual Exclusion- 1 resources instance can be allotted to 1 proc at a time.
                                Hold and Wait- Processes request another resource while holding.
                                No Preemption- if allocated, process leaves voluntarily on completion.
                                Circular Wait- Helps in analysis.
                        @Traffic Jam- which can't be solved
                                Junctions- occupied by 1 not 2 cars.
                                        direction of motion on junction
                                        Solution- Make a fly over.
                                Car holds a junction while demanding the other- use flyover.
                                        Solution- Make a condition that Lane 4's junction can be occupied iff junction 3 is free.
                                No car can leave its current position
                                        no force removal of car from point.
                                        Solution- use crane to lift it.
                                Such interdependence makes a cycle- had it not been a cycle.
                                        extension of Hold and wait.
                                        Solution- same as 2nd.
                        </NecessaryConditions>
                        <Representations>
                        Resource Allocation Graph
                                Vertices- 
                                        Processes by Circle
                                        Resources by rectangle- dots tell instances
                                Edges-
                                        Request Edge- Process to Resource surface
                                        Allocation Edge- Resource instance to Process.
                                        Addition- Claim Edge- How many instances in total will be needed of a resource.
                                            claim edge converted to allocation edge and vv- because sequence of resources asked by process is not known.
                                Or Wait-For Graph
                                    Processes interdependence graph- makes a directed cycle
                        </Representations>
                        <DeadlockInCentralizedSystems>
                                <Prevention>
                                Prevention- Take steps to avoid 4 conditions to happen
                                        ME- Printer can't be shared by MEX. Can't do it!
                                        Hold and Wait- request addition resources while holding!
                                                A process can request iff holding none (b4 starting)
                                                Or release the held resources in first place.
                                                Problem is inefficient usage of resources- held for long time but didn't need all throughout- others could not use.
                                        No Preemption- If Pi request Rj which is held by Pj.
                                                Pi must release its resources forcibly.
                                                Enforces hold and wait condition.
                                                Pi -> Rj -> Pj -> Rk
                                                        then release all Pj's resources.
                                        No Circular Wait- F: R->N. Map Resources to Natural Numbers.
                                                Process can request for resources in particular order.
                                                A proc holding Ri can request Rj iff F(Rj) > F(Ri), only bigger resource can be asked for.
                                                No chance for cycle formation.
                                </Prevention>
                                <Avoidance>
                                        No restriction on way requests are put by processes.
                                        But system decides whether granted immediately or wait for other processes to release resources.
                                        precalculation in the background whether granting a request could lead to a situ of deadlock (unsafe situation)
                                        Banker's algorithm- n- processes, m- Resource types
                                                Max : Max[i,j] = k		//matrix- n X m- ith process, jth resouce- Max resouce instances needed.
                                                Allocation : Allocation[i,j] = k	//Pi hold k instances of Rj
                                                Need : Need[i,j] = k		//Pi needs k instances of Rj to finish.
                                                        Need = Max - Allocation;
                                                Available : Available [j] = k	// vector of rank m (all resources instances available)
                                                Request : Request[i,j] = k      //Pi asking for k instances of Rj.
                                        Algorithm- Pi places a request.
                                                                                <!--
                                                (I)
                                                if(request(i) >= need(i))
                                                        error();
                                                if(!(request(i) <= available))
                                                        wait();
                                                //pretend allocation.
                                                available = available - request(i);
                                                allocation(i) = allocation(i) + request(i);
                                                need(i) = need(i) - request(i)

                                                safetyAlgorithm();	//check if this new state is in safe state or not.
                                                (II)
                                                (II)
                                        Safety Algorithm{
                                                work = available;
                                                finish = false;		//all false
                                                while(true){
                                                        //find a process whose need can be met
                                                        for(i=0;i< n; i++){
                                                                if(finish[i] == false && need(i) <= work)
                                                                        break;
                                                        }
                                                        if(i != n){	//process found- add to availability and mark finished.
                                                                work += allocation;
                                                                finish[i] = true;
                                                        } else break;
                                                }
                                                //finish = true for all i.
                                                for(i=0;i< n; i++){
                                                        if(finish[i] != true)
                                                                break;
                                                }
                                                if(i == n)
                                                        printf("system safe");
                                                else print("it's not");
                                        }
                                                                                -->
                                        Problem- The Max Resources can't be declared in advance and instance used once may be requested again
                                </Avoidance>
                                <DetectionAndRecovery>
                                        go on allocating when asked for.
                                        Keep checking time to time if deadlock is there.
                                        killing a process when it has finished 50 of 55 mins.
                                                repeat from square A.
                                                                                <!--
                                        Algo{
                                            Work(m) = available;
                                            if (Allocation(i) == 0) 
                                                finish[i] = true;   //not allocated are not candidates for deadlock.
                                            else finish[i] = false;
                                            while(true){
                                                //find a process whose need can be met
                                                for(i=0;i< n; i++){
                                                    if(finish[i] == false && request(i) <= work)    //need replaced by request
                                                        break;        //current request of process Pi can be met. Future request can cause later.
                                                }
                                                if(i != n){	//process found- add to availability and mark finished.
                                                    work += allocation;
                                                    finish[i] = true;
                                                } else break;
                                            }
                                            //finish = true for all i.
                                            for(i=0;i< n; i++){
                                                if(finish[i] != true)
                                                        break;
                                            }
                                            if(i == n)
                                                printf("system safe for now.");
                                            else print("it's in deadlock");
                                        }
                                                                                -->
                                        T(n)?
                                                O(m.n^2)
                                                These conditional statements involve vectors of rank m.
                                                while (true) can run at most n times (no of procs)
                                                Detection of cycle in graph- Process dependence graph.
                                                    O(n^2)- deadlock avoidance and detection.
                                </DetectionAndRecovery>        
                        </DeadlockInCentralizedSystems>
                        <InDistributedEnvironment>
                                Complication- The process and resources are not in one machine but across machines but distributed.
                                    process of Machine A may ask for resource in machine B.
                                    Prob with Deadlock avoidance- good algo but difficult to get info of resource instances reqd in advance.
                                        detection and recovery on other hand is practical.
                                        in distributed, either this one or prevention.
                                <DetectionAndRecovery>
                                    Every machine knows its own process and resource but not processes of other but resources maybe known.
                                    <CentralizedDeadlockDetection>
                                    Centralized deadlock detection approach.
                                        Every machine maintains its resource graph; alongside global picture is necessary (deadlock on global scale)
                                        Central coordinator machine maintains graph of whole network.
                                            Every machine sends info to central coordinator on change in local graph.
                                                central machine changes accordingly.
                                            Periodic sending of changes by every machine.
                                                Updation in local graph since previous timestamp.
                                                Eg- 3 new edge added, 2 deleted.
                                            If deadlock is found, it kills 1 or more processes.

                                        Eg- 
                                            Machine 0: Proc A, B; Resource R,S
                                                A -> R (request)
                                                R -> B (allotted)
                                                S -> A
                                            Machine 1: Proc C ; Resource S,T (though resource S is on machine 0)
                                                T -> C
                                                C -> S
                                        Global Picture
                                                                                        <!--
                                            B <- R <- A <- S <- C <- T
                                            No deadlock at present cuz no cycle.
                                                                                        -->
                                        Machine 0 messages- delete B <!-- <- --> R by M0 and B <!-- -> --> T added by M1.
                                            Message delay- M1 reaches that B -> T first. Then updation of edges and central machine finds a cycle.
                                            False Deadlock- Central machine would assert deadlock but M0 should have claimed B <!-- <- --> R b4!!
                                            Solution- Maintain a global clock- 
                                                Every message comes with a Time stamp. If a deadlock detected for a message.
                                        If deadlock detected then kill a process on a criteria
                                            Min executed process, etc.
                                                but 13 min exec/ 14 min total is better or 30 min exec/ 1 day.
                                                central coordinator- broadcast to all machines asking for messages before the latest time stamp.

                                            Central coordinator is a machine/process (besides other procs on machine)- processes are in deadlock.
                                                process detecting deadlock is not in deadlock.
                                                only need DSA but may need previliges- needs i/o, ram, etc.
                                    </CentralizedDeadlockDetection>
                                    <DistibutedDeadlockDetection>
                                    Distributed Deadlock Detection Approach
                                        All machine participate in deadlock detection.
                                        M0: Procs 0, 1, 2
                                        M1- 3, 4, 5
                                        M2- 6, 7, 8, 9.
                                        Eliminate resources to get WaitFor Graph (process interdependence)
                                            0 -> 1 -> 2 -> 3 -> 4 -> 6 -> 8 -> 0
                                                           | -> 5 -> 7 -> 9
                                            upper part of graph leads to deadlock- All machines maintain their part of graph!!
                                        Process blocked if request for a resource already allocated.
                                            Blocked process generates a message as tuple (Pi (blocked), Pj (message generator), Pk (messge recipient (waited for by Pj)))
                                                Pj tells all Pk it's waiting for- that Pi is blocked waiting for you.
                                                Other process previously say (8,0) was added (b4 (0,1)), Message generated by 0- Message would have ceased on P0.
                                            Eg- (0,0,1), P1 modifies and sends- (0,1,2), P2- (0,2,3), P3- (0,3,4) and (0,3,5); 
                                                P5- (0,5,7); P(7)- (0,7,9)- can't go anywhere- P9 finishes and backtrack until P3- P3 waits for another line.
                                                P4- (0,4,6); P(6)- (0,6,8); P(8)- (0,8,0)- P(0) receives and figures that P8 is waiting for P0 to finish P0- deadlock!!
                                                Here P0 commits suicide- kills itself.
                                            Prob- Mutliple Suicides
                                                Imagine- P6 and P0 had been blocked together
                                                They would both message, get it encircled and both will commit suicide- 1 was desired!!
                                                More procs killed though deadlock is gone.
                                                Solution- send a list of procs traversed along the message tuple- and both assert largest proc to be killed.
                                                    the highest PID (system generated) (for same list) will be unique to get killed.
                                                    more information is to be passed but experimentally 90% deadlocks involve 2 procs.
                                                    Unique victim process!
                                    </DistibutedDeadlockDetection>
                                </DetectionAndRecovery>
                                <DeadlockPrevention>
                                    Circular wait conditin- there's global clock for the system.
                                        duration of execution of proc is known.
                                        Pi (20 units exec) waiting for Pj (10 units executed)
                                        If Ti > Tj, then Pi asked to wait
                                            else Pi is killed.
                                        No chance for circular wait.
                                        Proof by contradiction- Streak of Pi thru Pm.
                                            Ti > Tj > Tk > Tl > Tm > Ti (not possible)
                                </DeadlockPrevention>
                        </InDistributedEnvironment>
                </Deadlock>
            </IITKGP>
            IIT-KGP, Subject IIITB, Shell Scripting, OS Installation, Softwares Organization, System Calls
            <Ravula>
                <Ref>
                    Galvin and Tanenbaum- good books, william stallings not recommended.
                    Lectures and then material. For theory refer to books.
                </Ref>
                <Defn>
                        A Collection of Programs (Software) that acts as interface betw user [or application programs] and hardware (CPU,memory,disk)
                            Hardware
                                resides in upper portion of MM (around 1/4 or so and remaining space for user processes and data.
                                Hardware runs our programs- solve our problems- OS manages that.    
                                Shields hardware management from application programs.
                                @Hardware maps to a human being- CPU is brain- working space like memory and executing- I/O Senses; 
                            Everything a vendor ships when you order an OS.
                            Kernel- 1 program that runs on PC all the time- eth else is system program or app program.
                                Shell- any interface to communicate instructs to OS (GUI and LUI)
                            Who starts OS?
                                Bootstrap program stored in ROM (EPROM or firmware) is loaded at power-up (or reboot) which
                                    initializes all aspects of system
                                    Locates OS and Loads OS kernel and starts execution on CPU.
                    <Uncat>
                            <CPUWorking>
                            Eg1- 
                            HLL Program	ASL Code 	Machine Code
                            Read X,Y	IN		01
                                            STA X		04 0F 00: Address of X
                                            IN		01
                                            STA Y		04 0F 02: Address of Y
                            Z = X + Y	LDA X		03 0F 00
                                            ADM Y		07 0F 02
                                            STA Z		04 0F 04: Address of Z
                            PRINT Z		OUT		02


                            Memory Layout
                                    0300	01 (opcode)
                                    0301	04 (address part)
                                    0302	00
                                    0303	0F
                                    0304	01
                                    0305	04
                                    0306	02
                                    0307	0F
                                    0308	03
                                    0309	00
                                    030A	0F
                                    030B	07
                                    030C	02
                                    030D	0F
                                    030E	04
                                    030F	04
                                    0310	0F
                                    0311	02

                                    0F00	Value of X	
                                    0F01	
                                    0F02	Value of Y
                                    0F03
                                    0F04	Value of Z
                                    0F05

                            CPU working- These memory addresses Exist in PC
                                    Stored Program Concept- Von Neumann Machine
                                            by John Von Neumann 1945
                                    Contents of Microcontrollers/ Microprograms- automate following.
                                            [Instruction Fetch- PC -> MAR -> RAM -> MBR -> IR
                                                    MAR (CPU) -> Address Bus -> Address Buffer (RAM) || Timing and Control (CPU) -> Asserts "Memory Read" -> Timing and Control (RAM)
                                                    Data Buffer (RAM) -> Data Bus || Timing And Control (RAM) -> Control Bus- asserts "Data Ready" -> Timing And Control (CPU)
                                            Decode Operation- IR -> Decoder -> Control Unit
                                            [Get Operand Address- PC -> MAR; 		//as advocated by CU context
                                            Fetch Operands- PC -> [MAR -> RAM -> MBR]* -> ACC/ Registers]*
                                                    MAR (CPU) -> Address Bus -> Address Buffer (RAM) || Timing and Control (CPU) -> Asserts "Memory Read" -> Timing and Control (RAM)
                                                    Data Buffer (RAM) -> Data Bus || Timing And Control (RAM) -> Control Bus- asserts "Data Ready" -> Timing And Control (CPU)
                                            Do Operation- Control Unit -> ALU -> ACC/ Registers/ Flags
                                            Store Operand- [PC ->..CU ->]? ACC, MAR, MBR -> RAM.	//depends on n-address instruction
                                                    MAR (CPU) -> Address Bus -> Address Buffer (RAM) || MBR -> Data Bus -> Data Buffer (RAM) || Timing and Control (CPU) -> Asserts "Memory Write" -> Timing and Control (RAM)
                                                    TIMING And Control (RAM)- Asserts "Write Done" -> Control Bus -> Timing and Control (CPU)
                                            Interrupt Check?
                                                    Yes- Process Interrupt
                                                    No- ]*

                                            Control Unit
                                                    Switches (c1,c2,...cn) are plugged on for charge to flow from 1 register to other)
                                                            configured to communicate amongst one another- plugging them on by CU determines what action will happen.
                                                            nC2 links vs 1 data bus in CPU connecting all registers hanging on it with control switches!
                                                            The instruction cycle has a sequence of simultaneous switches getting ON.
                                                            Their are also context specific CU signals based on current IR.
                                                    Make a list of low level instructions and map them to table of Control switches getting on.
                                                            this signal has to be sent by CU every iteration or on specific instruction.
                                                                    we have to take caution- 1 to 1 flow and no simultaneous unless MEX.
                                                                    Maybe diodes to specify direction of flow!
                                                            Jump on specific instructions or types- eg- Jump to "address-mode" execution cycle!
                                                                    Jump to operation1:ADD, Sub, etc.
                                                    Thus, there is an instruction cycle even within CU- this makes microchips
                                                            IR -> CAR -> Decoder -> Control Memory -> CBR -> Branch Logic
                                                    Microcontroller vs Microprograms
                                                            Simpler to implement and flexible
                                                            cheaper and less error prone
                                                            Easy Debug
                                                            User can program
                                                            But slower than hardwired unit

                                            CPU connects to all devices thru Primary and secondary Bus- to their Interface and Device Controller.
                                                    Interrupt Request (Device) -> Interrupt Acknowledgement (CPU)
                                                    CPU -> I/O Module Interface Port -> Device Controller (Control (does with interface and buffer), Buffer/ Interface) -> Device.

                            Eg2			Single Address	Machine Code
                            HLL			ASL		Address	Instruction
                            if(a >= b)		LDA a		0300	03 A050:a
                                                    SBM b		0303	0A A052:b
                                                    JN LABEL1	0306	E2 0315
                                    x = x - y;	LDA x		0309	03 A054
                                                    SBM y		030C	0A A056
                                                    STA x		030F	04 A054
                                                    JMP LABEL2	0312	E0 031E
                            else			
                                    y = y - x;	LABEL1:		
                                                    LDA y		0315	03 A056
                                                    SBM x		0318	0A A054
                                                    STA y		031B	04 A056
                            p = p * p;		LABEL2:
                                                    LDA p		031E	03 A058
                                                    MPY q		0321	06 A05A
                                                    STA p		0324	04 A058

                            On these lines there can be n-address instuctions
                                    3-address- ADD op3,op2,op1 (op1+op2=op3)
                                    2-address- ADD op2,op1 (op2 = op2+op1)
                            </CPUWorking>
                            <InstructionContents>
                                <OpCode>
                                    Eg- opcode:03
                                    Types
                                            Arithmetic
                                            Logical, Relational, etc
                                            System Control-  Enable Interrupt (EI), Disable Interrupt (DI), WAIT (for interrupt)
                                            Branch Instructions- if, goto, JMP, JN- refer to flags.
                                            Stack Instructions- Push, pop, etc (stack pointer)
                                                    200	JSR F1:0500					//(jump to subroutine)/ call 
                                                    203	STA X
                                                    Stack Pointer Remembers 203 as return instruction before going to 0500 to execute.
                                    Instruction Sets
                                            RISC- Limited and simple Addressing Modes
                                                    Large Registers (GPR)
                                                    Instruction Pipelining, chip cache
                                            CISC- 
                                </OpCode>
                                <AddressPart>
                                    Eg- address/operand part:A050
                                    <AddressingModes>
                                    addressing Modes- Effective Address- EA
                                            Register addressing-
                                                    MOV R1, R2; ADD R4,R5
                                                    EA = R
                                            Direct
                                                    ADD R1,M1
                                                    EA = M
                                            Immediate Addressing
                                                    EA = PHI
                                            Indirect Addressing
                                                    ADD R9, (M1)
                                                    EA = (M)
                                                    Contnets of M give the address of operand.
                                                    useful in pointers.
                                                            MAR = MBR (in instruction cycle)
                                            Register Indirect Addressing
                                                    Mov R5,(R2)
                                                    EA - (R2)
                                            Displacement Addressing
                                                    Indexing
                                                            MOV R5, X(R2)
                                                            EA = X + R2
                                                            ?Useful in Iteration
                                                            ?Useful in Arrays index reading.
                                                            Eg-
                                                                    CLR R5
                                                            LOOP : 	LDA B(R5)
                                                                    ADD A(R5)
                                                                    STA B(R5)
                                                                    MOV ACC,R5
                                                                    ADD #2
                                                                    MOV R5, ACC
                                                                    CMP N
                                                                    JMP Loop
                                                            Double Addressing
                                                                    CLR R5
                                                            LOOP:	ADD B(R5),A(R5)
                                                                    ADD R5,#2
                                                                    CMP N,R5
                                                                    JP LOOP
                                                    Base-Register Addressing
                                                            Useful In Paging scheme etc
                                                            EA = (BR) + M
                                                    [PC-]Relative Addresssing
                                                            200 instructions from current PC value!
                                    </AddressingModes>
                                </AddressPart>
                                    Break Up- Opcode, Mode, Reg, Mode, Reg
                                            4,3,3,3,3 (16 bit)
                                            12,4,6,4,6 (32 bits)
                                            Memory addresses are in separate bytes dedicated!
                            </InstructionContents>
                            <NumberSystemForALU>
                                    (04) base 16 = (0000 0100) base 2
                                    Radix 10
                                            204 = 4 + 0*10^1 + 2*10^2
                                            weight of every position- why? cuz when it comes in that position.
                                    Radix 2
                                            101 = 1*2^2 + 0*2^1 + 1*2^0 = 5
                                    <NegativeNumbers>
                                    Negative Number- 1 bit compromised for sign (n-1 bits to determine maxValue in one dirn)
                                            MSB reserved for Sign- Put 1 in the beginning for negative.
                                                    Probs- 
                                                            determining operation after checking MSB and final outcome by relative magnitudes
                                                                    Eg- 2-(-5) = 0010 - 1101 = 010 + 101 (add them)
                                                                    Eg- (-5)-(+3) = 1101-0011 = add them and then change sign
                                                                    Eg- (-5)+(+3) = 1101+0011 = difference and decide the sign.
                                                            ambiguity of 0- positive or negative.
                                            2's Complement
                                                    -5 = 2^4 - 5 = 10000 - 101 = 1111+1 - 101 = 1010 + 1 = 1011
                                                    = 1's complement +1 = 1111 - A = (2^4-1-A)+1
                                                    Numbers
                                                            000	0
                                                            001	1
                                                            010	2
                                                            011	3 (2^n - 1)
                                                            100	-4 (2^(n-1))
                                                            101	-3
                                                            110	-2
                                                            111	-1
                                    </NegativeNumbers>
                                    <Computation>
                                    Computation- for changing sign, insert 2's complementor before accumulator of ALU (with opcode as control signal)
                                            perform all adding, subtraction normally!
                                                    -x + y = -x is moved up the scale by y.
                                                    - x + -y = -x is moved down the scale.
                                                    x + (-y) = x is moved down by y.
                                                    Caution of overflow!!
                                            <Multiplication>
                                                    sign multitude Form
                                                            convert 2C to + sign- Do normal mult- decide the sign.
                                                            Multiplicands is recursively added to iteratively shifting version of itself depending on 1 or 0 on multiplier.
                                                                    shifting towards right- so that the lsb keep moving to the multiplier side and in the end- both taken together form outcome.
                                                            Shortcuts- avoid streaks of 1's and multiply by first 0 to the right!
                                                    Booth's Algo- for 2's complement
                                                            A = 0, Q-1 = 0, M- Multiplicand, Q= Multiplier, Count N=n
                                                            do{
                                                                    switch(Q0Q-1){	//multiplier
                                                                            case(10):
                                                                                    A = A - M
                                                                                    break;
                                                                            case(01):
                                                                                    A = A + M;
                                                                                    break;
                                                                            case(00 or 11):
                                                                    }
                                                            arithmetic shift right;
                                                            N = N-1;
                                                            }while(N!=0);
                                            </Multiplication>
                                            <Division>
                                                    Unsigned Numbers

                                                            A = 0, M- Divisor, Q= Dividend, Count N=n
                                                            do{
                                                                    Shift Left A,Q
                                                                    A= A-M
                                                                    if (A < 0)
                                                                            Q0 = 0
                                                                            A = A + M (restore A)
                                                                    else 
                                                                            Q0 = 1
                                                                    N--;
                                                            }while(N!=0);

                                                    2's complement
                                                            Refer to notes.
                                            </Division>
                                    </Computation>
                                    <FloatingNumber>
                                            Sign (1), Exponent (8), Mantissa (23) or significand (for 64- 1,11,52)
                                                    Eg- 0.00023567 = .2356 X 10^-3 = +, -3, 2357 (1st digit be non-zero)
                                                    weights reduce in decreasing powers of 10.
                                                    Biasing of Exponent- -128 to 127 biased on 128 gives range of 0 to 255
                                            Points are discrete but real numbers are continuous- so mapped to nearest number.
                                                    smallest no- 0.5 * 2^-128	= 1000000
                                                    largest no- (1-2^-23) * 2^127	= 1111111
                                            Mantissa are set of point from 2^(|exp|-1) to 2^|exp| divided into 2^|mantissa| points
                                                    => the gap between alternate numbers goes on increasing with exponent value.
                                            Add/ Subtract
                                                    check for zero
                                                    align the mantissa (by exponent thru shifting)
                                                    add/sub mantissa
                                                    normalize result
                                                    round off result
                                                    Flow chart- refer to notes.
                                            Multiplication/ division
                                                    Check for zero
                                                    Add/sub exponents
                                                    multiply/divide mantissa
                                                    Normalize result
                                                    Round off result
                                            Errors
                                                    Exponent Overflow
                                                    Exponent Underflow
                                                    Mantissa Overflow
                                                    Mantissa Underflow
                                    </FloatingNumber>
                                    <Shifting>
                                    Shift Right/Left
                                            Arithmetic- The last digit recurs
                                            Logical- Rotate through carry.
                                    </Shifting>
                            </NumberSystemForALU>
                            <RegisterTypes>
                                    GPR- General Purpose
                                    Data
                                    Address- Base, Index, Segment, Stack Pointer (SP)
                                    Condition Codes/ Flags- 
                                            Carry
                                            Overflow
                                                    change of n-1th bit (positive addition overflow)
                                                            Eg- +2 + +3 = 010 + 011 = 101 (Wrong)
                                                    change of nth bit (negative addition overflow)
                                                            Eg- -2 - +2 = 110 + 110 = 1110
                                                    Both is not error (overflow twice on the scale)
                                                            Eg- -1 + -1 = 111 + 111 = 1110 = 2
                                                    fine otherwise.

                                            Sign (Jump on negative instruction)
                                            Parity (even/ odd)
                                            Interrupt Enable
                                            Supervisor
                            </RegisterTypes>
                    </Uncat>
                            COA
                                CPU execute instructions. Devices attached to Computers thru Bus- they have their controllers
                                Memory is shared- data from keyboard, mouse clicked sw- thru bus.
                                Concurrent execution of CPU and devies competing for memory cycles- 
                                    Device controller is in charge of Device type. It has local buffer if PC is busy.
                                        Eg- 
                                        Monitor connected to Graphics adapter.
                                        Keyboard,Mouse, printer- USB Controller
                                        Disk- Disk Controller
                                        IO have their own execution. COncurrently they do.

                                        CPU moves data from memory to local buffers and vv.
                                        IO is placing data from device (mechanical key press) to local buffer of controller.
                                        Device Controller informs CPU that it has finished operation thru interrupt.
                                            Interrupt transfers control to ISR (interrupt service routine) thru Interrupt vector (contains addresses of all ISR)
                                            CPU sees whih interrupt and accordingly ISR. Current address of context is saved.
                                            while executing an interrupt, others are disabled- lost interrupt!
                                            @you are interrupted, you go to another room, you are not available for interruption.
                                            Software generated interrupts is called trap (by error or user request)- int a = 5/0;
                                            OS is interrupt Driven. Keyboard typing- generates an interrupt notified to CPU (in its exection cycle)- it writes to monitor.
                                        Storage Structure
                                            RAM- or MM- Only storage media CPU can access. So, called MM.
                                                Random access- not sequential reading head. Any address read in equal time.
                                                volatile- switch off, data is lost.
                                                Costlier to HDD.
                                                Faster than HDD.
                                                @Conscious Mind vs subconscious mind (that's why RAM is much lesser)
                                            Secondary storage- to provide non-volatility (persistence)
                                                Eg- Magnetic Disks.
                                                divided into Tracks and subdivided into sectors divisions. Device Controller determines logical interaction between device and computer.
                                            Caching- Copying information into faster storage System
                                                MM can be viewed as cache for secondary storage.
                                                Kept above RAM for faster access.
                                            Registers very fast but costly kept near CPU.
                                            Info checked in cache, then RAM if missed then HDD. Copy to cache.


                </Defn>     
                <Purpose>
                        <Convenience>
                                so that User can harness hardware easily. 
                                User has to write lotta code for simple hardware functions
                                say printf- makes a system call- OS makes it convenient for us to use hardware.
                                you just say what OS should do and leave remaining to OS.
                                called system calls- write is system call for printf of C.
                                without this system call, you had to write all the code of write inside of your application.
                                many people need same functionality, rather than telling e1 to implement it, OS gonna provide in 1 place.
                                we don't care for their implementation detail- just call them (interface with it).
                                B4 OS e1 would write mundane programs of prining.
                                Primary- Convenience- for users to use it. DOS you have to type eth- but mac- convenience.
                                Giving GUI in place of LUI access.
                                Execute User programs and make solving user problems easier.
                                Shell- interface to give commands to OS.
                            System Calls
                                User wants to interact with hardware to solve problems- so system calls are APIs or functions (Programming interface (C or C++) to OS Services) that help us interact with hardware
                                they keep system protected also and user also gets to use.
                                3 most common API- win32 API, POSIX API for POSIX based systems (Mac,unix,linux),Java API- for JVM.
                                a number associated with each- a table indexed acc to these numbers.
                                The syscall interface invokes syscall in OS kernel and returns status and return values of syscall.
                                    need not know implementation; only obey API for I/O. Eg- write syscall- need not know.
                                    Eg- Open in user mode from user application- System call interface- in kernal mode- the opening code is executed.
                                    Pass parameters to syscall thru 
                                        1. parameters in registers 
                                        2. stored in block or table, in memory and address of block passed as param in a register. (used in linxu)
                                        3. Params placed and pushed onto stack by the program and popped off the stack by OS.
                                Types
                                    Process COntrol= end/abort; load/execute; create process, terminate; get set proc attribs, wait event, allocate and free memory (alloc,free, malloc)
                                        Unix- fork, exit, wait; windows- createProcess(), ExitProcess, waitforsingleObj
                                    File Management- CRUD files. close open file; getset file attribs.
                                        open, read,write,close; createFile,etc
                                    Device Mgmt- Request, release, read/write; device attribs, logically attach or detach devices.
                                        ioctl,read,write; readConsole, etc
                                    Information maintenance- Getset time/date, getset system data; getset proc,file or device attrib.
                                        getpid(), alarm,sleep; setTimer, getcurrentProcessId
                                    Communications (amongst processes)- Create, delete communication connection; send, receive messages, transfer status info, attach or detach remote devices.
                                        pipe, shmget, mnap; CreatePipe, etc
                                    Protection- chmod, unask; setFileSecurity, InitializeSecurityDescriptor.
                                        <Chmod>
                                            Access of directory
                                                When applying permissions to directories on Linux, the permission bits have different meanings than on regular files.
                                                        The write bit allows the affected user to create, rename, or delete files within the directory, and modify the directory's attributes
                                                        The read bit allows the affected user to list the files within the directory
                                                        The execute bit allows the affected user to enter the directory, and access files and directories inside
                                                        The sticky bit states that files and directories within that directory may only be deleted or renamed by their owner (or root)
                                                        https://unix.stackexchange.com/questions/21251/execute-vs-read-bit-how-do-directory-permissions-in-linux-work
                                                        https://stackoverflow.com/questions/3740152/how-do-i-set-chmod-for-a-folder-and-all-of-its-subfolders-and-files-in-linux-ubu
                                                        What is a directory? It's just a list of items (files and other directories) that live within. So: directory = list of names.
                                                Network Drive using cmd - pushd \\inblr7g101\sapall\BYD\ByD_India\50_ByD_India_Public\Maintenance_Coordination\1802Upgrades\ and popd.
                                                I have rx for all directories and 
                                                For files, no read, write and execute.
                                        </Chmod>

                                Eg- copying a file from source to destination. Syscalls involved.
                                    keyboard input for acquire input file name-
                                    prompt on screen- enter file name
                                    acquire file name
                                    write for displaying on monitor.
                                    Open file- if doesn't exist abort else open.
                                    read from 1 and write into another until read fails- close when done.
                                Eg- ReadFile in Win32- handle filename, LPVOID- buffer of keyboard, Dwords- buffer bytes to read or write; LPDWORD last read; 
                                <Virtualization>
                                    Xen, VMWare- Extending an existing interface so as to mimic another system.
                                    Eg- Virtual Private Network (VPN)
                                        Virtual Memory
                                            User thinks he is writing at address 5 but 5 of his space- in reality, he might be writing at 205 of his workspace that starts from 200.
                                        Virtual Machine (VM)
                                            Physical machine has hardware (NIC,CPU,Disk) but underutilized often- cuz OS tightly coupled hardware.
                                            Solution- give a virtualization layer of abstraction- wherein same physical hardware becomes virtual hardware (which multiplexes for resource utilization)
                                                Secure MUX- Eg- Memory cycles shared across original and VM.
                                                Virus in 1 can't affect the other.
                                                Performance Isolation
                                                Shortcomings
                                                    Lotta delay- any request passes thru virtualization layer to hardware- consumes time and competition.
                                            VM is a file- transfering is easy. We can have snapshots to restore.
                                                Decoupling.
                                            Uses
                                                Run Legacy S/W on non-legacy hardware.
                                                Many OS on 1 H/W.
                                                Reduced costs by consolidating services onto fewest physical machine.
                                                Dynamic Data Center- Resource Util improved- breaks 1 service per server model- if load increases then add VM.
                                    <IIITB>
                                        VM
                                            concept- create- modify
                                            how to change hardware settings
                                            why
                                                    Usage- running > 1 OS simultaneously
                                                            no need of reboot to use s/w made for specific OS
                                                            old os installation for which hardware no longer supported- dos, os/2
                                                    ?Quickstart implementation- Easier software installations
                                                            hadoop environment set up thru vm vs tedious installations
                                                            Eg- mail server "appliance" installation
                                                    Testing and disaster recovery
                                                            vm and its virtual HDD- container- as good as a machine- frozen, woken, copied, backed up, transported.
                                                            do stress testing of hadoop vm- at what stage does VM OS crash.
                                                    Feature- using snapshots- save a particular state
                                                            virus- switch back to previous snapshot.
                                                    saves hardware and electricity costs
                                                            systems use fraction of potential power and system load. 
                                            useful links
                                                    https://www.virtualbox.org/
                                                    distributions
                                                            http://www.ubuntu.com/ (Preferable 14.04 LTS)
                                                            http://www.openbsd.org/
                                                            http://www.debian.org/
                                    </IIITB>

                                </Virtualization>
                        </Convenience>
                        <ResourceManagement>
                            <Uncat>
                                Resource Management
                                    Resources
                                            Processor
                                            Memory
                                            Devices
                                            Information
                                    Management
                                            Allocate
                                            Decide who gets how much
                                            Keep Track
                                            Deallocate on completion or forcibly.
                            </Uncat>
                            You listen to song while you code- who manages RAM allocation of data and code. How to control and coordinate.
                        Resource Allocator
                                When many program running simultaneously or many users sharing Computer,
                                Resource means CPU,memory,file,printing devices,etc
                                who will run; when and where. Resolve conflicting request of resources.
                                handles program errors (runtime)
                                Allocation means giving resource to the process.
                                we have to allocate  to some of them (how much, how long)
                        Manager- book-keeping. 
                                mainframes on other hand- used by experts don't care for convenience much. Main goal is efficiency there.
                                WHich resources to which process- 
                                which process to which resources and free resources, capacity, etc.
                                <ProcessManagement>
                                    for processes- for every program that has to run. For every process, its states,etc.
                                    <Program2Process> you wrote a C program ex.c, compiler reads and converts into a.out (executable or machine code)- written into hard disk of PC (secondary) from primary (main or RAM).
                                        Shell (GUI click or LUI command) starts the execution of a program.
                                        when executed, it is loaded into main memory and OS creates a data structure for execution is created called process.
                                        Program is passive entity; Process is active.
                                        Process is real. Program is virtual; body:soul::Program:Process.
                                        1 Program can have several Processes- consider n users executing same program simultaneously.
                                        Job is high level (application level) usage of the word process.
                                        Data Structure looks like this- whole area called process boundary.
                                            text section- a.out- text or code section
                                            Data Section- static and global variables- created once and remain for lifetime. Global given access to whole program.

                                            stack- local variables, function params. useful in recursion and function calls.
                                                Stack grows with function calls.
                                            heap- a need for Dynamic allocation during run time.
                                                    alloc, malloc, etc
                                                    not created unless reqd.
                                            no strict division between heap and stack.
                                            they grow in different direction- I don't know which will take more space.
                                                    @TOC and OS notebook- start writing from opposite ends of the notebook- they will meet somewhere- whichever maybe larger.
                                                    cuz don't know which will take more space.
                                            CPU takes instructions from a.out 1 by 1 and executes. can't cross the process boundary (else segmentation fault)
                                    </Program2Process>
                                    <PCBOrContext>
                                        Concept- Process Attributes remembered by OS
                                            Contained within PCB (Process Control Block; aka Context) for every process.
                                            All PCB are connected by Linked List. How many processes are executing (OOPS! there in the system)
                                            when reinstating a process after pre-emption- the context has to be restored (called Context Switching) by dispatcher. wastes time but i/o time saved and interactability achieved (multitasking)
                                                Dispatch Loop is the code in infinite loop that runs [continuously]- this is the skeleton
                                                    Loop{
                                                        RunThread();    //for the Time Quantum decided.
                                                        ChooseNextThread(); //Replace Thread by processs for this.
                                                        SaveStateOfCPU(curTCB);
                                                        LoadStateOfCPU(newTCB);
                                                    }
                                                    RunThread
                                                        Load its state (Reg,SP) and environment (Virtual Memeory space,etc) and jump to PC.
                                                        How does dispatcher get control back?
                                                            REL Thread running line 32, it should stop now
                                                            Internal Events: Eg- Thread returns control voluntarily
                                                                Blocking on I/O- The act of requesting I/O implicitly yields the CPU.
                                                                Waiting on a "signal" from other thread- thread asks to wait and yields.
                                                                Executes a yield()- infinite loop computePI- yield after computing every next digit.
                                                                    should be called by programmer frequently enough.
                                                                    trap is generated to OS-  kernal executes and switches to newly picked thread- (housekeeping)
                                                            External Events: Eg- Thread gets pre empted.
                                                                Interrupt comes- Interrupt controller takes over immediately- switches to ISR.
                                                        Threads not killed right away on finish cuz
                                                            Move them in exit state- housekeeping- deallocates finished threads but other threads of proc may need memory.
                                            @Studying all the pages- I was studying page number 133 b4 i started dbms and notebok n1 opened- remembered so as to continue from where you left.
                                        <ProcessAttributes>
                                            <ProcessID> So many processes in Computer, how to identify them
                                                @like people in world, we use identification pass (adhaar card,etc). Every new born baby(process) is given a name (PID)
                                                Every process gets a different number.
                                                vs Port No- is universal. Everyone maintains the same port number. 
                                                different for 32 bit, 64 bit machines.
                                            </ProcessID>
                                            <ProgramCounter>
                                            Program counter- while executing a process, you pause it. which point to restart it.
                                                stopped execution at I6. pre-empted. Then come back to I6 when coming back.
                                            </ProgramCounter>
                                            <ProcessState>
                                                Ready, running, blocked, waiting, etc determined by Operations on processes.
                                                <Transition> Operations on Process (transitions in Process States)
                                                        Creation- Create process brought to MM.
                                                        Scheduling- Give process to CPU for exec.
                                                        Execution- CPU exec.
                                                        Killing/Delete- kill process after it is over.
                                                        [I/O Completion
                                                        ]
                                                </Transition>
                                                <States>
                                                States- Process from creation to completion (various state transition- based on nature of process or scheduling algorithm)
                                                        New- when process is about to be created in secondary memory (when picking it up).
                                                        Ready- brought in MM, ready to run. Many processes means multiprogramming.
                                                                At an instance- no process may be in ready state or all processes can be.
                                                        Run- n CPU means n running processes possible(ideally) but can be 0.
                                                        Block (aka Wait)- A process may need to Read or write (gets into block or wait)- Process and PCB still in MM but in that mode!
                                                                until they finish the I/O, they stay there.
                                                                parallelly the i/o task is going on!
                                                                At an instance, no process may be in blocked state or all of them.
                                                        Termination or Completion- after all instructions executed then process terminates. Context or PCB is deleted.
                                                                All allocation in MM also deleted, every trace of it.
                                                        Suspend Ready- 100 processes in MM and MM is falling short. High priority jobs arrive. Move Processes to back up (HDD), which process (scheduling algorithm)
                                                        Suspend Wait or Suspend Block- When the blocked or waiting processes are told to wait in HDD rather than ready ones.
                                                                anyway they are waiting for I/O.
                                                                A conference Room and VIP arrives, tell a sleeping fellow to move outside.
                                                                when I/O finishes, the process attribute in PCB is changed to suspend ready.	
                                                                brought back to MM, ready or block (if I/O finished)
                                                </States>
                                                <StateTransitionDiagram>
                                                        Events and states change they cause.
                                                        Refer to diagram!!
                                                        Minimum number of states from start state to final state (DFA)- 4.
                                                        Wait/ Block state and not ready- why? it should not be a candidate for run state- else it may get and i/o not completed yet.
                                                        <Schedulers>3 types of decisions
                                                                <LongTermSchedulers>
                                                                        aka Job Schedulers- can be slow but effective.
                                                                        Long term decision (in their impact)- create a process, it will be inside for a long time, until finish
                                                                        Determines degree of multiprogramming- max no of processes allowed in MM.
                                                                        Affects performance of system- take good mix of cpu and io bound jobs.
                                                                                if all processes picked are i/o bound, CPU idle.
                                                                                if all procs are CPU bound, starvation.
                                                                </LongTermSchedulers>
                                                                <ShortTermSchedulers>
                                                                        aka CPU Schedulers. Gotta be fast (in ms).
                                                                        Pool of processes ready for running- pick 1 of them- decision not gonna last forever.
                                                                        Short Term Scheduler or Dispatcher.
                                                                        Scheduler decides the next process to execute and it calls dispatcher for context switching of process (from ready to run state or vv)
                                                                        Job Queue (set of procs)
                                                                        Device Queue (for I/O)- eg- printf in C uses monitor to print- so the proc will in Device queue for I/O on monitor.
                                                                            Here, in algo we assume parallel exec of I/O for different processes.
                                                                        Ready Queue(waiting to exec)
                                                                        Important decision- 
                                                                                affects interactability.
                                                                                Convoy Effect- Starvation of processes
                                                                                    @One VIP and many others with him- others starve.
                                                                                    If bulky process (or high priority) arrives first, others keep waiting for their turn.
                                                                                save context switching time

                                                                        <ImportantTimeParameters>
                                                                            Important Time Parameters of Processes (Points in time and Duration in Time)
                                                                                Arrival Time - Point in time when process gets into ready queue from New.
                                                                                Burst Time (aka Execution Time)- Amount/Duration of CPU time to finish.
                                                                                        Problem is you can't tell exactly beforehand.
                                                                                        A process may have sever bursts of execution b4 termination.
                                                                                Completion Time- Point in Time at which process finishes.
                                                                                        Depends on CPU time. Ignoring IO time (we generally do for analysis)
                                                                                Turn Around Time- Duration between AT and CT is TAT (=BT+WT=CT-AT)
                                                                                Waiting Time- Duration of time process spent waiting. (=TAT-BT)
                                                                                    @Time for which person waiting for his turn (God knows their criteria!)
                                                                                Response Time- Point/Duration in time when process hits CPU.
                                                                                        (=first schedule - AT)
                                                                        </ImportantTimeParameters>
                                                                        When a proc moves
                                                                                Run- Terminate- when finished
                                                                                Run- Wait- when io request by process.
                                                                                Run->Ready- when pre empted thru interrupt.
                                                                                New->Ready- when created.
                                                                                Wait->Ready- back to waiting for CPU and gets immediately if high priority.
                                                                        <Algorithms>
                                                                            Lots of Ready queue processes. 1 CPU and What is criteria of picking jobs from Ready Queue.
                                                                            All have their own criteria; if they tie then AT; still tie, then PID.
                                                                            We test algorithms for different scenarios (problem or situation instances)
                                                                                We compare the different algorithms and what real life situations they suit and what they don't
                                                                                Determine the data structure to implement it. 
                                                                                    Check the time complexity also.
                                                                                    Analyse its performance in different scenarios.
                                                                                        Model Execution Trace thru Gantt Chart- visualize.
                                                                                            Relative times are used to indicate AT,BT,etc.
                                                                                                Find CT (completion Time) by running algorithm 
                                                                                                    (include context switching time if stated (scheduler runs to for algo and change context(minimize it- 1. reduce T(n) 2. Minimize Context Switches)))
                                                                                                WT = TAT - BT
                                                                                                Average or Total TAT = SIGMA (all procs)/No of Procs
                                                                                                If CPU doesn't wait End Time on Gantt Chart = SUM(BT)
                                                                                                for RT, check from first, the first completion in Gantt Chart, subtracted by their AT.
                                                                            <FCFS>
                                                                                Criteria: Arrival Time- One that comes first gets CPU first. It is practical.
                                                                                Mode: Non-preemptive- won't be removed until finishes- never in waiting state (assumption) so N-R-Run-T
                                                                                @Queue for railway reservation.
                                                                                See Diagram- 
                                                                                    Pick the first least AT, mark a cross against it.
                                                                                    Then after it is over, note the current time and completion time (update in table)
                                                                                    check amongst ready queue candidates (1. AT <!-- < --> current time 2. unmarked)
                                                                                    if none arrived, wait until the next arrives (CPU wastage)
                                                                                    else, pick the least AT amongst them, mark a cross against it.
                                                                                    if processes not finished goto Step 2.
                                                                                    else stop.
                                                                                Evaluate its performance finding all time parameters.
                                                                                    Simple to Implement
                                                                                    Suffers Convoy Effect.
                                                                                    Road Ahead- Let's schedule the smaller jobs first to protect against this.
                                                                                How to implement it (Data Structure)?
                                                                                    Use queue. T(n) = O(n)- constant time to enqueue and dequeue.
                                                                            </FCFS>
                                                                            <SJF>
                                                                                Criteria- Burst Time
                                                                                Mode- Non Pre emptive.
                                                                                Algo- 
                                                                                    Wait till some process arrives.
                                                                                    If more than 1, Pick the one with least burst time.
                                                                                    After it is over, check processes in ready queue (CT > AT), pick the 1 with least burst time.
                                                                                    if no process stop else go to step 1.
                                                                                    The algo guarantees, Shortest available job first. if shorter job arrives later, it waits.
                                                                                Performance
                                                                                    Advantages
                                                                                        Maximum throughput- number of processes finished per second. (=No of processes/Length of the schedule)
                                                                                            because we are finishing as many processes in given amount of time- by picking smallest among them.
                                                                                        Minimum TAT and WT-
                                                                                    Disadvantages
                                                                                        This also suffers convoy effect.
                                                                                            say at time 0, Burst time 100 arrives and time 1 and 2, BT 1 and 2 arrive.
                                                                                            starvation of longer jobs! Solution Aging.
                                                                                        Not practical- we never know BT b4- so it will give good performance as such.
                                                                                    Solution- SJF with Prediction
                                                                                        Prediction Techniques
                                                                                            Static- You are not going to fix anything
                                                                                                Based on process size- if size matches with a previous finished process and use same BT.
                                                                                                    Wrong! Size may be similar but nature may be different.
                                                                                                    St it may be right.
                                                                                                and process type.
                                                                                                    OS Process- Scheduler is process; process manager is process- 3 to 5.
                                                                                                    User Process- 
                                                                                                        Interactive- gaming- 5-8
                                                                                                        Foreground- 10-15
                                                                                                        Background- 15-18
                                                                                            Dynamic- Keep on changing while performing the schedule
                                                                                                Works better than Static.
                                                                                                Simple averaging 
                                                                                                    Next burst will be based on average of bursts till now.
                                                                                                    Tn+1 = SIGMA(Ti)Over all i till n / n
                                                                                                exponential averaging or ageing.
                                                                                                    PredictedNext(t) = ALPHA*Prev(t)+(1-ALPHA)PredictedPrev(t)
                                                                                                        ALPHA- smoothening factor- their weightage.
                                                                                                        first guess matters- if you expand it.
                                                                                    Implementation
                                                                                        Minheap to pick least BT. Always on head.
                                                                                        Addition takes log(n) time and deletion also- so for all processes- nlog(n)
                                                                            </SJF>
                                                                            <RoundRobin>
                                                                                Most popular of all. Many OS offer it- not depending on BT.
                                                                                This is FCFS with scheduled preemption
                                                                                Process executed for particular amount of time called time quantum (Time Slice). Then pre empts next proc.
                                                                                No job waits for more than (n-1)q time units (ignoring context switching time)- cyclic manner.
                                                                                Typically TQ today is 10-100ms and cs overhead is 0.1-1ms- so 1% roughly.
                                                                                Algo- 
                                                                                    Pick a process from queue.
                                                                                    If BT <!-- < --> TQ, Excute till completion, remove proc from queue
                                                                                    else Execute for TQ. TQ expires, calculate remaining BT.
                                                                                    Update the queue with procs that entered.
                                                                                    If remaining time of the proc is 0, remove from queue.
                                                                                    else enqueue the proc and goto Step 1.
                                                                                Eg- Gantt chart along with queue and space for BT to keep updating. Keeping updating eth.
                                                                                    for CT, check from last, the first appearance in Gantt Chart.
                                                                                    for RT, first response point - AT.
                                                                                    These context switches have increased along with its time. Apt size of TQ.
                                                                                    If TQ is increased, starvation happens. too much? it becomes FCFS. If TQ is too low, lotta wastage on Context Switching time cuz of number of context switches.
                                                                                    ns + (n-1)q <!-- <= --> t for response for every proc in t time. s being CS time and q is time quanta.
                                                                                    take instance of a generic prob- we may get a clue.
                                                                                Performance
                                                                                    No Starvation- cuz all have their time.                                                                                        
                                                                                DS- Not Lot of DS like heap- only queue will do it.
                                                                            </RoundRobin>
                                                                            <SRTF>
                                                                                Check if smaller BT proc is arriving until it finishes it BT. Update BT.
                                                                                SJF after all have arrived.
                                                                            </SRTF>
                                                                            <LongestRemainingTimeFirst>
                                                                                vs longestJobFirst- non-pre emptive.
                                                                                Shorter doesn't finish until the longest does. All finish together.
                                                                                2 hands, 2 breads. eat from longer- bite it and other becomes longer and bite that and so on.
                                                                                Choose longest remaining time walla proc.
                                                                                Run the proc until
                                                                                    BT finishes or 
                                                                                    a new longer proc arrives or                                                                                             
                                                                                    it becomes shorter than some other pre existing proc.
                                                                                    When there is a tie, choose smaller AT, still tie then PID and give it TQ 1 unit and they will reduce together.
                                                                                Update BT.
                                                                                Update Ready Queue.
                                                                                Goto Step 1.
                                                                            </LongestRemainingTimeFirst>
                                                                            <PriorityScheduling>
                                                                                Every proc comes with a priority associated with it.
                                                                                2 types-
                                                                                    Static- Doesn't change throughout the execution of the process (assume by default)
                                                                                    Dynamic- Changes at regular intervals of time
                                                                                can be pre emptive or not.
                                                                                default- bigger number bigger priority.
                                                                                Non-preemptive
                                                                                    Check all arrived procs after burst- do with highest priority.
                                                                                    for non-preemptive, RT is same as WT- cuz once it gets, it finish its purpose.
                                                                                Pre emptive- run until a higher priority job arrives. pre empt- update BT and ready queue.
                                                                                    once all arrive then it's non pre emptive. Like SRTF converts to SJF.
                                                                                    waiting time of highest priority has 0. RT also 0.
                                                                                    RT is 0 if it was highest priority when it arrived.
                                                                            </PriorityScheduling>
                                                                            <HRRN>
                                                                                Highest Response Ratio Next.
                                                                                Criteria- Response Ratio = (w + s) / s (or w/s) (so far waiting time; service time- remaining BT)
                                                                                HRRN not only favors shorter jobs but also limits the waiting time of longer jobs.
                                                                                Mode: non pre emptive.
                                                                                Algo:
                                                                                    Select the process with highest HRRN amongst those in queue.
                                                                                    Execute it till end (or update BT). Update the ready queue (remove done procs and add new).        
                                                                                    Evaluate HRRN for all candidates. Remaining Burst time (service time) and Waiting time = Current Time- AT + Original BT - Current BT.
                                                                                    Simlar to SJF but doesn't allow starvation of longer procs.
                                                                                    Non-practical once again.
                                                                            </HRRN>
                                                                            <withIO>
                                                                                In Gantt Chart- indicate with a cross over the time period a proc is busy in waiting state.
                                                                                for WT, TAT - SUM (CPU Time)
                                                                                Assuming that parallelly IO is possible.
                                                                                <SRTFWithIO>
                                                                                    Remaining time by adding burst time - Done.
                                                                                    Pick the one with least remaining time.
                                                                                    Run it until new arrives or till end of its current burst.
                                                                                    If new smaller proc arrives, pre empt- allow it to run as in step 1.
                                                                                    Else If Burst ends, marks next io cells invalid for current process thru some decoration under Pi tag.
                                                                                    List the candidates for next CPU allocation, pick 1 with least burst time.
                                                                                </SRTFWithIO>
                                                                            </withIO>
                                                                            <MultiLevel>
                                                                                System Process- OS- FCFS
                                                                                Interactive- Online game; Listen music; work with computer- SJF
                                                                                Batch- Submit jobs and come later for results- RR
                                                                                Student Processes- Priority

                                                                                Can't put them all in 1 queue and 1 algo but they contend in different queues under separate algorithms with procs of their types.
                                                                                Highest level has highest priority and lowest has lower.
                                                                                Top level does then comes the turn of lower levels (lower levels starve cuz sth always there on top)
                                                                                Advantage is separate algo for different types of procs.
                                                                                Solution is- MLFQ (Multilevel feedback queue)- proc moves from low priority to high.
                                                                                    different TQ for different queues.
                                                                            </MultiLevel>
                                                                        </Algorithms>
                                                                </ShortTermSchedulers>
                                                                <MediumTermDecisions> 
                                                                        Suspension decisions of processes- not for ever nor for short term.
                                                                        this is swapping decision. Efficient- because swapping takes lotta time.
                                                                </MediumTermDecisions>
                                                        </Schedulers>
                                                </StateTransitionDiagram>
                                            </ProcessState>
                                            <Priority>
                                            Priority- tells the importance. Higher priority executes first (useful in CPU scheduling)
                                                    OS process is executed b4 user process (higher priority)
                                                    a number given to process to indicate precedence.
                                                    @ Politicians given higher priority than people. on road (blocked for others when he passes)
                                            </Priority>
                                            <GPR>
                                            General Purpose Registers
                                                    while execution. process uses some registers
                                                    Pull it out and put the next one there.
                                                    CPU has some registers- R1,R2,R3. Process P1 in execution- has numbers in Registers. I4 instruction says R1 = R2 + R3 (not only from MM)
                                                    If P1 pre-empted (why we see later), coming back- I see Program Counter I4 was to be executed and also update Registers else previous values (of process)=> wrong outcome. 
                                            </GPR>
                                            <ListOfOpenFiles>
                                                    During process execution, some files may be opened for reading/writing to avoid reopen/close.
                                                    when written by 2 processes, the file should remain consistent.
                                                    1 process trying to delete a file, it should be checked that no other process is using it!"file cannot be deleted"
                                            </ListOfOpenFiles>
                                            <ListOfOpenDevices>
                                            List of open devices- printers, scanners and maintain a list of it.
                                            </ListOfOpenDevices>
                                            <Protection>
                                            Protection- Don't get into others' workspace and vice versa.
                                                We don't want a bad application to crash the system.
                                            </Protection>
                                        </ProcessAttributes>
                                    </PCBOrContext>
                                    <Threads>
                                        Process executes an app- Even in single application we want parallelism- like Web Server.
                                            when a request comes it has to wait until the previous one is over.
                                            Let 1 handle GUI, 1 handle I/O, so on. (pieces of code concurrently executing both belonging to same process)
                                            In multicore CPU- CPU scheduler can allot 4 procs at a time. Also, hyper-threading.
                                            computePI is infinite function- the next will never come- but with threads, others will be done ASAP and computePI will go on.
                                                they compete for resources and finish.
                                                Eth remains same in Process Data Structure- only stack is divided into pieces.
                                                    How to position stacks relatively? Max Size? threads violation.
                                            Process spawns a thread- 
                                                shares contents of memory (global,heap) and I/O state- files, network.
                                                private to a thread- TCB (Thread Control Block), Registers/PC, [Execution] Stack- remembers the return address of previous call also.
                                            Per Thread State- TCB for every thread
                                                Execution State: CPU Registers, PC, SP (Pointer to Stack)
                                                Scheduling Info: State, priority, CPU time
                                                Various pointers: for implementing scheduling queues.
                                                Pointer to enclosing process (PCB) and more
                                                OS keeps track of TCB in protected memory- in array, LL?
                                                    now all PCB in the LL- point to LL of the TCB that proc spawns.
                                            Lifecycle of a Thread
                                                New, ready, running, waiting, terminated.
                                                TCBs are Organized in queues as per their state
                                                Sleep(5000) means it will sleep for at least 5 seconds cuz it will get into ready queue after that.

                                    </Threads>
                                    <InterProcessCommunication>
                                        aka IPC
                                        Tasks want to talk with each other.
                                            Faster computation (1 prob addressed thru unanimity)
                                            Info sharing; Modularity (division of labor); Convenience
                                        @1 cuts veg and other cooks- 1 supplies resource to the other- studying fella maybe separate (no interaction)
                                        2 models of IPC
                                            <SharedMemory>
                                                @a common notice board- "please cook for me"
                                                Process A writes in shared memory used by process B.
                                            </SharedMemory>
                                            <MessagePassing>
                                                @SMS sent to others.
                                                Process A sends message thru kernel to process B
                                                Synchronization- 
                                                    Block the sender until message is received.
                                                        @Knocking the door- waiting for him- like a costly gift.
                                                    Blocking Receive- the receiver until message comes
                                                        @Girl waiting for a gift on Valentine's day.
                                                        Eg- Server.
                                                    Non-blocking Send/Receive- Send message and continue; opens the door and checks if there's a mail.
                                            </MessagePassing>
                                            <ProducerConsumerProblem>
                                                Info produced by 1 process and consumed by another thru shared memory- buffer may be bounded (fixed) or not.
                                            </ProducerConsumerProblem>
                                    </InterProcessCommunication>
                                    Multiprocessing
                                            Fork-Join
                                            Cobegin-coend
                                    Critical Section
                                            Mutual Exclusion
                                            Progress- only participants should poll for access.
                                            Bounded Wait- After a definite time, a requesting process is bound to get the access. 
                                    Deadlock
                                            4 necessary conditions
                                                    ME
                                                    HW
                                                    NP
                                                    CW
                                            CS Traffic Control
                                            Prevention
                                            Avoidance
                                            Detection and Recovery

                                </ProcessManagement>
                                <MemoryManagement>
                                    <Uncat>
                                        Memory
                                            CPU Reg
                                        <Cache>
                                            Cache
                                                Associative
                                                        TLB translates into physical address- block No and offset
                                                        Block number- individually XOR with ?some tags (partition on msb), their valid to set match bit- which selects the cache block
                                                                offset extracts the relevant address.
                                                                13 tag, 3 word in block.
                                                        Maths
                                                                No of cache blocks- ?
                                                                Size of each cache block = 2^3
                                                                Selector extracts the relevant address.
                                                Direct Mapping
                                                        Tag (5), Group (8), Byte (3)
                                                        MM divided by Tags (MSB), each tag further broken down by groups.
                                                        In cache, there's a block for every group (division is by groups (2^g=2^8=256))
                                                                for every group, candidates are any tags of the group.
                                                        Use decoder to select a group!
                                                        for group selected, use comparator to match Address' tag with the cache-obtained tag.
                                                        if hit on both, then selected the block and use offset to obtain address value.
                                                2-way set associative
                                                        blocks from 2 different tags for a group can be selected.
                                        </Cache>
                                            MM
                                            Mag Disk
                                            Mag tape/ optical disk
                                    </Uncat>
                                    Code has data and instructions that comes into MM.
                                        for memory- how much memory you have, how much is free (Monitor)
                                    <BareMachine> 
                                        1 proc executes and leaves and then next proc arrives and so on.
                                        No translation or protection needed. App can access any physical memory.
                                    </BareMachine>
                                    <Multiprogramming>
                                        necessitates that Programs are shared in MM without overlap, separate address space.
                                        <NeedForLogicalAddressing>
                                            Compile Time Relocation- 
                                                Compiler decides that this instruction is address 0,1,2, etc
                                                Problem is all compilers tell their instruction addresses without communcation/ coordination. 
                                                    => clashes/ collisions/overwritings.
                                            Load Time Relocation- The addresses are relative. Relocation register is maintained.
                                                So run time address will be obtained as relocation register value of the process + offset (relative address)
                                                All procs have their base and limits to avoid segmentation fault.
                                                Mapping is done dynamically by MMU- CPU still sees virtual or logical data but MMU sees physical. Hardware does the mapping.
                                                Algo for translation:
                                                    Logical address is produced by CPU- 
                                                    hardware (supports relocation) check if < limit register (max program size)
                                                    if no, then trap: addressing error
                                                    else add to relocation register (start address), to get physical address.
                                                    Translation of Branching to functions in different modules- done by linker/loader- only then we know their address.
                                        </NeedForLogicalAddressing>
                                        <StrategiesForMultiplexing>
                                            Why?
                                                The complete working state of a process or kernel is defined by its memory and registers.
                                                can't let different processes use the same memory- results become wrong except for shared memory.
                                                Protection- can't let access others' memory else others' results spoilt.
                                                    Address Space- what a process can touch- all have their own.
                                            Contiguous Allocation (fixed, variable partitions)
                                                MM divided into 2 partitions- Low memory for Resident OS and remaining for user procs.
                                                Degree of multiprogramming limited by number of paritions.
                                                Holes- internal fragmentation. When a proc arrives, give it hope enought to hold it. 
                                                    First Fit- first hole that matches.
                                                    Best Fit
                                                    Worst Fit- allocate largest hole.
                                                Free partitions are kept track of.
                                                Problem of Fragmentation
                                                    Internal- Process uses lesser than partition- wasting ununsed space. Process wants 5 MB from 6 MB parition.
                                                    External- Total memory exists to satisfy a process request, but it is not contiguous.
                                            Without Translation
                                                Must sh prevent overlap. Adjust addresses while program is loaded.
                                                Bug in a program can crash the OS.
                                                Add Protection- add base address and Limit Address to registers to prevent straying outside designated area. Else, error.
                                                New addresses are loaded from TCB during context switch.
                                            Base Address at run time- pretty common in early days.
                                                Fragmentation Problem
                                            Buddy    
                                            Segmented MM
                                                Process has different components (CDHS)- all become different segments.
                                                    Where does the text segment of this process start from? add offset.
                                                This memory is not contiguous- reduces fragmentation.
                                                ?Segment Map resides in processor- 
                                                SMT gives base address of a segment- added to offset (check < Limit) to generate Physical Address and check valid flag.
                                                Fragmentation within segments.
                                                Options for swapping to disk is limited.
                                                Variable sized chunk concern.
                                            Paged
                                                To solve external fragmentation and internal to much degree.
                                                Divide Physical Memory (MM) into frames and logical memory (process data) into pages (size same as frame)
                                                    Change the following at time of Context switch.
                                                        PTBR (Page table base Register) points to the page table.
                                                        Page table Length register (PTLR) tells size of the page table.
                                                    Keep track of free frames in MM.
                                                    When a program which needs n free frames- allot from free frames list.
                                                Keep track of location of all pages of a process- thru Page Map Table (PMT)(sitting in MM) for every process- responsible for logical to physical translation.
                                                    so at process creation- create also a PMT for it by OS.
                                                    @index in last of a book.
                                                    [logical] Address from CPU- divided into (p,d)- Page number, Page Offset (size m-n,n)
                                                        Page number is mapped to unique frame number using PMT for every process and framenumber is added to offset.
                                                            Eg- 1015 is logical address- say 1 is page number and 15 is offset- 2015 means 2nd page so on- then 1 is added to PTBR- to get Frame number.
                                                        Maths
                                                            Logical Address Space = 2^m
                                                            Page Size = 2^n
                                                            Number of page = 2^(m-n)
                                                            Last page suffers internal fragmentation- but that's ok. Total = 1/2 frame size
                                                        If page is invalid or missing- then check for a free block
                                                            if free block, then refer to FMT (File Map Table) to fetch a block from disk.
                                                            else use replacement policy to select a victim page
                                                                modified? write some frame back to disk.
                                                                not modified- replace.
                                                    TLB used; hardware driven- so memory cycles not wasted.
                                                    Can even use 2-level Page Table for better indexing of PMT.
                                                Small frames desireable?
                                                    Each page table entry takes memory to track.
                                                    Solaris support 2 page sizes- 8KB and 4MB. 
                                                Architectural Change
                                                    Need 2 MMU accesses- 1 for PMT and 1 for data/instruction fetch.
                                                        Time gets doubled.
                                                    vs TLB (Translation Look Aside Buffers)- special fast Look Up Hardware Cache
                                                        Faster but costlier so limited. Has some important pages from MM.
                                                        Keep the PMT in TLB- 
                                                            if hit, then fetch Frame number add it to offset and fetch from MM.
                                                            if miss, then look up PMT in MM and get Frame number, add offset to get data from MM.
                                                                Effective Memory Cycle Time = hitRate*(TLBLookUpTime+MemAccessTime) + (1-hitRate)*(TLBLookUpTime+(2*MemAccessTime))     //average of 2 cases- miss and hit.
                                                    vizualize
                                                        Bare Machine
                                                            Resident Monitor- Fence address- OS, User area.
                                                                    Fence register stores it- all CPU addresses checked b4 RAM fetch else trap.
                                                                    Swap processes in and out of RAM.
                                                            Partitions- Lower Bound (base register), Upper (base + limit register)
                                                                    CPU address- check against limit register- add to base register.
                                                            Process1	Process2
                                                            E0		E0
                                                            E1		E1
                                                            E2		E2
                                                            D01		D02
                                                                            D12

                                                            PMT
                                                            FrameNo	ValidBit
                                                            1	1
                                                            3	1
                                                            7	1
                                                            2	1

                                                            PMT2
                                                            FrameNo	ValidBit
                                                            1	1
                                                            3	1
                                                            7	1
                                                            9	1
                                                            11	1

                                                            MemoryMap
                                                            0	O/S
                                                            1	E0
                                                            2	D01
                                                            3	E1
                                                            4
                                                            5
                                                            6
                                                            7	E2
                                                            8	
                                                            9	D02
                                                            10	
                                                            11	D12


                                            Paged Segmented (aka Multi-level Translation)
                                                Divide Segments in pages- to save from fragmentation.
                                                Page table contains permissions like Valid bits, read, write, etc.
                                                From page size in 32 bit machine tell the number of pages possible.
                                                If a page is to be shared- insert into PMT of both procs.
                                                Any logical address contains, Virtual Segment number- gives the base address of PMT- Check validity and Limit- Use PMT as in Paging to get Physical Address.

                                        </StrategiesForMultiplexing>
                                        <Swapping> Long Term Schedulers (Extreme form of Context Switching)
                                            Swap in/out or Roll IN/OUT- Lower priority process is swapped out so higher priority process can be loaded and exec.
                                            1 way was compaction- reshuffling is changing physical copying and changing their registers (base and limit)
                                            Helpful by keeping only active portions of a process in memory at any time.
                                            More control over physical memory.
                                            Keep working set of PMT in memory cuz not all used at the same time (invalid bit)
                                        </Swapping>
                                     </Multiprogramming>
                                    Role of TLB in reducing time.
                                </MemoryManagement>
                                <DeviceManagement>
                                    I/O Device Management
                                        Spooling- when different printers send data to printing device- the buffer maintains a separate streak for each and doesn't mix up.
                                    <VirtualMemory>
                                        User can imagine that he has unlimted RAM to work with.
                                            Gmail says you have unlimited Memory.
                                            Some servers with finite memory.
                                            Because of Virtual Memory- if people use more than 2 GB of memory, I will reallocate.
                                        Logical Address Space is much larger than physical cuz only a part of program needs to be in memory for execution.
                                            Eg- say a menu- only 1/5th of code will be used.
                                            Useful code is a little and huge lot of error/exception handling that rarely happen/ seldom used.
                                            if only 3 MB of 10 MB of process will be active- I can make room for other processes in MM- increasing degree of multiprogrammng.
                                            if the seldom code really happens then we will fetch it from disk.
                                        Implemented via:
                                            <DemandPaging>
                                                Bring page into memory only when it is needed.
                                                    Eg- If 4 procs all need 100 pages, only 1 will fit in MM. Bring all 4 25 pages.
                                                        you think they will all execute simultaneously?
                                                    Thus, Less I/O => Faster Response; More Memory needed=> high degree of multiprogramming/ more users.
                                                    Using Parachor curve, we claim that N/2 frames in MM is best trade-off for performance.
                                                Page Fault
                                                    If reference=>Page is needed- then if invalid reference- abort; not in memory- Page Fault Happens
                                                    Gotta Fetch 
                                                        if empty frame then fit in there
                                                        else free a frame using some algo.
                                                            Page Replacement Alogrithms- 
                                                                finds a victim frame- so as to reduce page fault in future.

                                                                    FIFO- Replace the oldest arrived.
                                                                        Belady's anomaly- more frames => More Page Faults.
                                                                        First arrivals are counted in page faults (number of frames) and add with number of cross
                                                                    Optimal- Offline algo- not practical- choose page that will not be used for longest period of time
                                                                        when page fault- check which page from frames will be called the last or never.
                                                                        Good to keep this as landmark to aspire up to.
                                                                    LRU- good approximation of optimal.
                                                                        Least Recently Used
                                                                        Assumption- 1 not used recently will not be used in future, most likely.
                                                                        Oldest Used process is replaced- check to the left- the one which comes at last.
                                                                            ?T(n) = O(m*n^2)
                                                                        Or keep track of count for frame id with their latest reference number.
                                                                            ?T(n) = O(mn) worst case; best case O(m+n)
                                                                        Stack Implementation (thru doubly LL)- 
                                                                            If not on frame, keep pushing on stack
                                                                            else take element to the top
                                                                    LFU- Least Frequently Used
                                                                    MFU- Most Frequently Used

                                                                Add Modify/Dirty Bit (to PMT?) 
                                                                    when pages are not modified, don't write them back so as to reduce overhead of page transfer 
                                                                    if modified then write back
                                                                Use the empty Frame.

                                                    Effective Access Time = PageFaultRate*(PageFaultOverhead+SwapOut+SwapIn+RestartOverhead) + (1-PageFaultRate)*MemoryAccessTime
                                                        Eg- slowdown by factor of 40 but to gain sth some compromise is reqd.
                                                Lazy swapper- won't fetch into memory until really needed.
                                                    one that deal with pages is pager.
                                            </DemandPaging>
                                            <DemandSegmentation>

                                            </DemandSegmentation>
                                            <BufferManagement>
                                                Buffer Cache
                                                        DevNo, BlockNo, Data Areas,
                                                        Status
                                                                Buffer Locked
                                                                Delayed write
                                                                Valid data
                                                                Buffer <-->DASD
                                                                waiting for the buffer to get free.
                                                        Prev/Next Buffer on Hash Queue (7 is using this block)
                                                        Prev/next Buffer on Free buffer list (no1 using this block- but may have changes)
                                                <DataStructures>
                                                Free List Buffers in Doubly linked List
                                                        Mod 0- Hash Queue 0- HQ0
                                                        Mod 1....
                                                        Free buffer list- using all buffers of different HQ.
                                                </DataStructures>
                                                <GetBlock>
                                                getblk(){		//given block no- return buffer (which contains block or empty block- later used by bread)
                                                        while(buffer not found){
                                                                if(block in hash queue){
                                                                        if(buff locked){
                                                                                sleep(event: this buffer becomes free);	//process goes to sleep but kernel continues.
                                                                                continue;
                                                                        }
                                                                        mark buff busy;
                                                                        remove buff from free list;
                                                                        return buff;
                                                                }
                                                                else{
                                                                        if(there are no buff on FL){
                                                                                sleep(event: any buffer becomes free);
                                                                                continue;
                                                                        }
                                                                        remove buff from FL;	//head of LL (if delayed write, start operation and check for next in LL)
                                                                        if(buff marked delayed write){
                                                                                asynchronous write buffer to disk;
                                                                                continue;
                                                                        }
                                                                        remove buff from old HQ;
                                                                        ?bread();
                                                                        put buff in new HQ;
                                                                        return buff;
                                                                }
                                                        }
                                                }
                                                </GetBlock>
                                                <BlockRelease>
                                                blockRelease(){		//what to do when process stops using a block
                                                        wakeUp all proc: waiting for any buff to be free;
                                                        wake up all proc: waiting for this buffer to be free;
                                                        if(buffer contents valid and not old)
                                                                enqueue buff at the end of FL;
                                                        else
                                                                enqueue buff at head of FL.
                                                        unlock(buff);
                                                }
                                                </BlockRelease>
                                                <BlockRead>
                                                bread(){		// reading a block number
                                                        get buffer for block(getblk);
                                                        if(buffer data valid)
                                                                return(buff);
                                                        initiate disk read into the buff;
                                                        sleep (event disk read complete);
                                                        return (buff);
                                                }

                                                breada(){
                                                        if(first block not in cache){
                                                                get buff for first block;
                                                                initiate disk read;
                                                        }
                                                        if(scond block not in cache){
                                                                get buff for second block;
                                                                initiate disk read(asynchronous);
                                                        }
                                                        if(first block in cache){
                                                                return buff;
                                                        }
                                                }
                                                </BlockRead>
                                                <BlockWrite>
                                                bwrite(){
                                                        initiate disk write;
                                                        if(i/o synchronous){
                                                                sleep(event i/o complete);
                                                                release(buff);
                                                        }
                                                        else(buffer marked delayed write){
                                                                mark buff old;
                                                                return buffer at head of FL;	//so as to replace it on priority.
                                                        }
                                                }
                                                </BlockWrite>
                                                Block No- used logically
                                                        but need to know block address on the disk!
                                                        In demand paging, page fault- use disk address of page request.
                                                                refer to FMT.

                                            </BufferManagement>
                                    </VirtualMemory>
                                    Administers- How print to monitor screen; how to read input from keyboard
                                    Without I/O, PC are impaired (not sensory perception?)
                                    <DifficultyInStandardization>
                                        1000s of devices, each slightly different from other- how to standardize interface to those devices.
                                            1 Pendrive wants input in French, 1 in English, German.
                                        Devices are unreliable- how to make them reliable.
                                            OS will resend so that user only sees the output.
                                        Devices Unpredictable or/and slow- how to manage them if not sure what they will do/ perform.
                                            ?I/O is a black box- what service it gives
                                        Transmission Unit- Some provide single byte (Keyboard) or whole blocks (HDD,N/W)
                                            Blocks of data- open(), read(), write(), seek()- raw I/o or file system access.
                                                Uses memory mapped file access and DMA.
                                            Character- get(), push()
                                            Network Devices- select(); OS includes socket interface- Separates network protocol from network operation.
                                                Uses- Pipes, FIFO, streams, Queues, mailboxes.
                                        Transmission Speed- Devices rates vary over many order of magnitude.
                                            Better not have high overhead for fast devices 
                                            Better not waste time waiting for slow devices
                                        Access Style- Sequential or Random- Tape vs CD or disk.
                                        Polling/Interrupts- Some devices want continual monitoring, others generate interrupts.
                                            Polling vs Interrupt- I will go to mailbox every 5 mins vs postman calls you.
                                            Blocking Interface- Wait- read() system call- requests data- puts process to sleep until data is ready.
                                                write()- puts process to sleep until device is ready for data.
                                            Non-Blocking- Don't wait- May return nothing- but won't wait- returns count of bytes.
                                            Asynchronous Interface- Tell me later- when data requested, return immediately with pointer to user's buffer, kernel later fills buffer and notifies.
                                                same for sending data.
                                    </DifficultyInStandardization>
                                    <Solution>
                                    Solution- All Devices need to be controlled by their own Device Controllers fitted in them.
                                        Eg- Disk Controllers
                                        These devices have their own hardware (CPU, memory) to perform primitive operations- write, read, close, open.
                                        Provide Uniform Interface- despite wide range of different devices
                                            Devices have their instruction set and controller on them (with instruction set)- they should provide device driver
                                                gets installed when you plug in a device
                                                Use Device Drivers to communicate with them (their language- so they make their device drivers)
                                                    @Translater- from 1 language to another.
                                                    Acts as an interface- @internation language (or standard interface)- System calls- Device driver understands and communicates to device controller.
                                        All devices centrally connected by PCI Bus (or expansion bus- serial/parallel ports)
                                    </Solution>
                                    Access Methods- Different types of files for representation to get to the record- using indexing
                                    Logical I/O- Records to Blocks translation and vv.
                                            Secondary Storage Management- File management
                                                    Every directory/file has one inode associated and vv.
                                                    Root directory's Index-node (Inode) is remembered as global variable.
                                                    Every directory inode has in its TOC- a table with file/directory contained within it and its corresponding inode.
                                                            when you traverse- every directory retrieves the inodes present within by looking up the next part of pathname cascade.
                                            Finally we get to the inode- you may want a particular Data Block contained within it- using calculate Data block to be retrieved from record.
                                    I/O overseer (how to schedule,which device (file system))
                                </DeviceManagement>
                                <FileSystemManagement>
                                    Files- Files system should be consistent.
                                        make a hierarchical structure- tree like.
                                        File Allocation- Contiguous (File as a streak), Linked, Mapped (FAT32)
                                    File Manager- Get blocks from Secondary Storage- Buffer Management
                                            Hash Queues for different blocks
                                                    brought from MM.
                                            Free Buffer Queue- Doubly LL.
                                                    Take process out from head and place at last when process is done using it.
                                                    Malicious block found- process places it at head.
                                    <FileRepresentations>
                                    Info of FMT stored in Data structure called Inode- Index Node
                                        disk layout of every directory in file system.
                                            every directory and file has an inode.
                                        this DS also stored on same file system or disk.
                                        <DiskLayout>
                                        Disk layout as follows:-
                                            Disk consists of a number of blocks
                                                page frame size in MM usually equals the disk block size.
                                            Different blocks contain diffn information
                                            <BootBlock>
                                                    contains boot volume- load OS when booted.
                                            </BootBlock>
                                            <SuperBlock>
                                            2. Super Block (1 or more)
                                                    information on state of file system
                                                    How large the Files system is
                                                    How many files it can store
                                                    where to find free blocks (or space) on the file system (or disk)
                                                    Free Inodes [in inode list]- when creating a file or directory- 1 of the free inodes is used.
                                                            on creating a new file/ dir, you get error message that file system is full even though space on disk there!
                                                                    cuz there is no free inode on disk.
                                            </SuperBlock>
                                            <InodeList>
                                            3. Inode list (1 or more- depends on how big is file system)
                                                no of inodes decided by administrator while installing the OS.
                                                        so how many files or directory you can have!!
                                                Some Inodes are put into Super block (later)
                                                Inode list- evey inode contains the disk layout of any file/ directory.
                                                Inode
                                                    <DiskInode>
                                                    Disk- Inodes are stored in the list here.
                                                        open a file and successive data (block or page) on file.
                                                        where the page of file resides- gotta refer this.
                                                        every disk access- refers first to inode list- so to minimize this, when opening a file, inode of that file is copied to main memory
                                                        Fields in Disk Inode structure
                                                            Ownership- who owns the file. 2 types in unix
                                                                    1. Individual ownership
                                                                    2. Group ownership- when account created, a user is attached to a group.
                                                            3. Type- Inode of file/ directory?
                                                            4. Permission- owner can read, write and execute the file.
                                                                    rwx (individual); rwx (group); rwx (others)
                                                                    Eg- r_x- can read and execute but not write.
                                                            5. Access time- when file was last accessed
                                                                    6. Modified time- when last modified
                                                                    7. Inode modified- when inode was last modified.
                                                            8. File size
                                                            9. TOC- Disk address of different different data black
                                                                called TOC (table of content)
                                                                Pointers to disk blocks which contains different pages (or parts) of a file.
                                                                Unix System 5- 13 entries (0-12) containing block address
                                                                    0-9- direct pointers (to blocks that contain file data)
                                                                    10- single indirect pointer (to block that contain a set of pointers to the blocks containing file data)
                                                                    11- double indirect pointer (to block that contains pointers to a block which again contains pointers (disk block addreses) to file data)
                                                                    12- triple indirect pointer (3 levels of indirection)
                                                                Max allowed size of a file = depends on size of block
                                                                    imagine, Block size = 1 KB and Address of block takes 4 Bytes => 256 pointers / block
                                                                    direct- 10*10KB
                                                                    Single Indirection- 256 * 10 KB
                                                                    Double- 256 * 256 * 10 KB
                                                                    Triple- 256^3 * 10 KB
                                                                    Max size > 16 GB (taking triple alone)- sufficient for any process.
                                                    </DiskInode>
                                                    <IncoreInode>
                                                    Incore- the inode of the file copied to MM is called incore copy of inode.
                                                        eg- open command- open a file- get inode of the file from disk and copy that to MM.
                                                        <AdditionalFields>
                                                            Status
                                                                locked (used by some process)- wait if locked.
                                                                A process is Waiting for Inode to be unlocked (different from free)
                                                                Changed- if modified, different from disk copy
                                                                File changed- or not
                                                            Device No of File System- from which it is being copied.
                                                            Inode Number- on disk they are sequential. but here, it is needed- any sequence- need 5 after 2.
                                                            Pointer Fields
                                                                2 kinds of list- hash list and free inode list (different from block)
                                                            Reference count- how many instances of inode are active simultaneously
                                                                2 procs want to use the same file- increment reference count- how many procs accessing it.
                                                                2 instances of incore inode are active.
                                                                for every single byte to refer from file- refer to inode- so frequent access (using TOC)
                                                                1 proc closes file- then decrement the reference count.
                                                                w/o this field, 1 proc leaves, the inode may be overwritten by another copy of inode (like blocks)
                                                                    locked and used but unlocked doesn't mean inode has become free.
                                                                    Inode becomes free when the reference count becomes zero.
                                                                Eg- P1 wants to use offset d1 of a file; P2 also wants
                                                                    P1 will lock inode -> getBlkAddress -> unlock it
                                                                        unlock doesn't mean P1 has closed the file.
                                                                        P1 closes the file then reference count is decremented.
                                                                    P2 also closes file, then ref count = 0 and inode can be overwritten (can be taken to free list)
                                                        </AdditionalFields>
                                                    </IncoreInode>
                                            </InodeList>
                                            <DataBlocks>
                                            4. [Actual] data blocks
                                                    content of any file or directory actually stored in this location.
                                                    and the location information is in Inode list.
                                            </DataBlocks>
                                        </DiskLayout>
                                        <Operations>
                                            <FileOperation>
                                                Using a file, get its inode number
                                                    REL Buffer Management
                                                        b4 reading any data from Disk, check in buffer cache (data block in there?)
                                                        if not, then get a free buffer to load data from disk (getblk())
                                                    Check if Inode in MM- maybe locked
                                                        else get a free inode (ref count = 0) and overwrite it.
                                                        <getInode>
                                                            lockedInode iget(inodeNumber){
                                                                while(not done){
                                                                    if(inode in inode cache){       //already in MM?    REL HQ in BuffMgmt
                                                                        if(inode locked){           //some process using it, then wait.
                                                                            sleep(event: inode is unlocked);    
                                                                            continue;
                                                                        }
                                                                        else if(inode is on free list)	//refCount=0 => no proc using it (in Free Inode List)
                                                                            remove inode from freeList;     
                                                                        increment referenceCount field;
                                                                        return (inode);
                                                                    }
                                                                    else{
                                                                        if(no inode on free list)               //victim inode for replacement- none (all used)
                                                                            return (error);                     //no point waiting for file to be closed by a process
                                                                        else{                                   //victim inodes exist in free list
                                                                            remove new inode from free list;    //using LRU technique (processes may still want to use them)
                                                                            reset inode number and file system;
                                                                            remove inode from old hash queue;
                                                                            put in a new hash queue;
                                                                            read disk inode(bread);	//block read algorithm
                                                                            initialize inode;	//opened earlier then closed- refCount = 1 made
                                                                            return (inode);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        </getInode>
                                                        Comments
                                                            If no free inode?
                                                                vs in buffer management- if buffer free list is empty- buffer goes to sleep mode
                                                                        Y? likely that some process will free it.
                                                                        buffers used only for transfering contents to user area and disk. No processing there.
                                                                if Free Inode List is empty- means every inode is active by some process or other.
                                                                        no guarrantee that inodes will become free- until file closed by process- so rather than sleeping for process- we give error message and terminate the process.
                                                inode is read from secondary structure and get incore copy (in MM)
                                                check permission fields (if allowed) then do action
                                                Use TOC to get block address on file to do action- read/ modify
                                                then get block using buffer management.
                                                <ReleaseInode>
                                                    Releasing INode (not freeing it- depends on #processes using it)
                                                    void iput(pointer to inode to be freed){
                                                        lock inode if not already locked;	//cuz we gonna manipulate some fields in inode- others should not execute same piece while we do this.
                                                        decrement referenceCount;
                                                        if(referenceCount == 0){
                                                            if(inode changed)	//incore field
                                                                update disk inode;
                                                            put inode on free inode list;
                                                        }
                                                        release inodeLock;
                                                    }
                                                </ReleaseInode>
                                            </FileOperation>
                                            <Directory>
                                                special file- which has a set of inodes (files and other directories) in it.
                                                    obtained from type field- can be file, directory or free (meaning not allocated to anything)
                                                    There is a particular directory in every file system called root directory (with its inode)
                                                        on booting, stored in global variable accessible to every process
                                                    contains files and directories with their corresponding inodes.
                                                    Eg- etc directory
                                                        File Name       Inode
                                                        . (current dir) 83
                                                        .. (parent dir) 50
                                                        passwd          61  (type of inode no 61 tells if it's a file/directory)
                                                        bin             30
                                                        mkfs            99
                                                        ...
                                                <OpenSystemCall>
                                                Open system call- passwd or /etc/passwd
                                                    former means passwd in current directory.
                                                    INodeNumber namei(pathname){
                                                        if(pathname starts from root)
                                                            working inode = root inode;     //global variable has root
                                                        else working inode = current directory inode;       //stored in user area
                                                        while(there is more components in path name){
                                                            read next pathname component from input;
                                                            verify working inode is of directory and access permission ok;  //execute permission in directory means you can search the directory.
                                                            read directory;     //use blockRead algorithm
                                                            if(component matches an entry in dir){
                                                                get inode number for matched component;
                                                                release working inode;  //let go so that 7 else can use it.
                                                                working inode = inode of matched component;
                                                            }
                                                            else return (no inode);
                                                        }
                                                        return (working inode);
                                                    }
                                                    assumes that inode is already bound to the requested file/dir.
                                                </OpenSystemCall>
                                                <CreateAFileSystemCall>
                                                Create a file
                                                    get a new inode- not allocated to any till now from inode list.
                                                    super block- info on free blocks, size of file system, number of free inodes- where available.
                                                        Already have a file- add more data to the file- where free data block is available
                                                        get type field = 0 (not allocated)
                                                    Superblock free Inode list (SFIL)
                                                        contain a subset of inodes which are free (not all)
                                                        1 of these will be allocated- if no free inode in SFIL then take other free inodes from disk.
                                                        Nth but a list of integers- inode no is integer.
                                                    Eg- 499, 498, ...., 401, 400
                                                        first time 400 is given and this gets empty, next time 401 and so forth
                                                        Remembered Inode- first one = 499
                                                            when the inode 499's turn comes- this inode gives an indication where a new free inode will be available in the disk inodes.
                                                                size of every inode is fixed so easy to find out block number where that inode exists (on disk) (start address being known)
                                                                start searching for inodes with type = 0 (unallocated) from the remembered inode
                                                            100 new inodes are read and are filled in superblock.
                                                                500 thru 599 filled.
                                                                haphazard eventually but high expectations that next free inodes are after that.
                                                    iAlloc(){
                                                        while(not done){
                                                            if(super block locked){
                                                                sleep(event superblock becomes free);
                                                                continue;
                                                            }
                                                            if(superblock Inode list empty){    //all inodes exhausted
                                                                lock superblock;
                                                                get remembered inode for free inode search;
                                                                search for free inodes until superblock is full     //starting from remembered inode
                                                                    or no more free inodes;
                                                                unlock superblock;
                                                                wakeup (event superblock free);
                                                                if(no free inode found on disk)
                                                                    return (no inode);
                                                                set remembered inode;
                                                            }
                                                            get inode number from superblock inode list;
                                                            get inode (iget);       //get its incore copy from disk.
                                                            initialize inode;       //ref count, etc
                                                            write inode to disk;    //to reflect the changes made
                                                            decrement filesystem free inode count;  //maintained in superblock
                                                            return (inode);
                                                        }
                                                    }
                                                </CreateAFileSystemCall>
                                                <DeleteAFileSystemCall>
                                                A process Delete a file
                                                    Inode that is freed or unalloated.
                                                    check status in SFIL- put it in 1 of the empty entries.
                                                    if no room, check remembered inode
                                                        if smaller than remembered inode, replace inode with remembered inode
                                                            I don't lose 499- eventually I will get to it.
                                                        if more, do nth just mark its type field to 0 on disk (write it)
                                                            search would start from remembered and eventually get it.
                                                    ifree(){
                                                        increment free inode count;
                                                        if(superblock locked)
                                                            return;
                                                        if(superblock free inode list full){    //SFIL full with inodes
                                                            if(inode number < remembered inode)
                                                                set remembered inode = input inode number;
                                                        }
                                                        else
                                                            store inode number in superblock inode list;
                                                        return;
                                                    }
                                                </DeleteAFileSystemCall>
                                                <DataBlocks>
                                                Process opens file/ directory- some modification it may make
                                                    data blocks where contents are stored and changes reflect
                                                    if file is deleted then all data blocks should go to free data blocks list.
                                                    size increase or decrease- so may get data blocks or release them.
                                                    <Allocation>
                                                    allocation of data blocks
                                                        Free block list- single block- list of other blocks
                                                        All free blocks in form of linked list of blocks containing serial numbers of blocks that are free.
                                                        Eg-
                                                            Super Block- 40, 45, 65, ....70, 71
                                                            Block No 71- 80, 81, 87, ...., 100, 110
                                                            Block No 110- 150, 200, 210, .. , 340, 350
                                                            ...
                                                        Why?
                                                            size of every disk inode was constant- access was easy
                                                            checking its status was just looking at its type field
                                                            but here, data blocks may contain arbitrary data- so can't check.
                                                            mkfs- make file system function- does this organization.
                                                        How allocation?
                                                            when allocating or deallocating must put them back here.
                                                            process request- take out smallest from superblock in sequence.
                                                            when 71 (last) block is requested- b4 allotting- copy contents of 71 into superblock
                                                            now 71 can be used and so forth. if we had not copied then would have lost so many blocks.
                                                                the last block continues to maintain the property
                                                        Process doesn't write on disk block but buffer- from where it is written back
                                                        alloc(file_system_No){        //allocation of disk block
                                                            while(super block locked)
                                                                sleep(event: superblock not locked);    //process has to go to sleep.
                                                            remove block no from superblock free block list;
                                                            if(removed last block from list){
                                                                lock superblock;    //to modify
                                                                read block just taken from free list;   //71 in eg- bread() algo returns buffer.
                                                                copy block numbers into superblock;     //from buffer to superblock in disk.
                                                                release block buffer;               //release buffer.
                                                                unlock superblock;
                                                                wakeup processes (event: superblock not locked);
                                                            }
                                                            get buffer for block removed from superblock list;  //getblk (getblock previously)
                                                            initialize buffer;
                                                            decrement free block count;
                                                            mark superblock modified;
                                                            return buffer;
                                                        }
                                                    </Allocation>
                                                    <Deallocation>
                                                        Block released-
                                                            can it be put in superblock lists?
                                                            if no free room in super block, copy all super block contents into 500.
                                                                and put only 500 into super block so that on demand- 500 will be used before copying its contents back to superblock.
                                                            such releases- the sequence gets disturbed and average disk access (seek time) increases
                                                                vs sequential- very short seek time.
                                                                frequent deletes and updates- so defragmentation is done- at regular intervals- rearrange to restore.
                                                    </Deallocation>
                                                </DataBlocks>
                                            </Directory>
                                        </Operations>
                                    </FileRepresentations>
                                    <FileSystemArchitecture>
                                        stored on disk is inode.
                                        With file, 4 terms become important (data organized in form of table)
                                            field- basic element of data
                                                in file- student records- rollno, name, grades, etc
                                                each entity like rollNo is field
                                                Instance of field- there are values for each entity of these fields- like 999 for Thomas.
                                            records- set of related fields form a record.
                                            file- collection of similar records (whole table)
                                                if regular structure, just have streak of these field values or attribute values.
                                                if not regular, then gotta store as tuple- {(rollno, 999), (name, thomas), ..}
                                            database- collection of related data. RDBMS- collection of relations.
                                                2 sets A and B- Binary relation between A,B,C,D
                                                R SUBSEToF A X B X C X D
                                                can be used by multiple applications- sequence independent
                                                    program has to know 1st entry is rollno, second is name
                                        User need not know structure, architecture, etc of disk.
                                            open a file- fopen()- however the opening happens none of my business.
                                            Requirements of system level software must give
                                                Storage, Retrieval and Manipulation
                                                Validity of Data- Data is valid in there
                                                To optimize performance- user related (response time) and system related (throughput)
                                                Support to varieties of devices.
                                                Standard set of i/o interface routines
                                                    a set of standard system calls- so system independent software I can build.
                                                Multiuser support- diffn apps and users want to access file system simultaneously.
                                            To support all of these- we have file system architecture.
                                                on 1 end- application/ user softwares and other side we have file systems
                                                in between actual file system.
                                                So, different layers of functions
                                                    User Programs
                                                    File Structures/ Access Methods (routines)
                                                        Pile, Sequential, Index Sequential, Indexed, hash files
                                                        a set of softwares which takes care of file structure
                                                        Aim: of any file structure
                                                            Rapid Access for information retrieval.
                                                            Ease of updation- updation on disk isn't trivial.
                                                            Economy of storage (no redundancy)- no unnecessary reqmt (contradicts 1st)
                                                            Simple maintenance
                                                            Reliable
                                                        Viz
                                                            Pile- data as it comes collect it (not much time)
                                                                organize it later.
                                                                Name first, roll no next or roll No, name next
                                                                maybe no ordering on fields- have to tell which field is what
                                                                Ordered pair storage: {(rollNo, 999),(Name, Thastal)}
                                                            Sequential File:
                                                                Records of fixed length- fixed lengths of fields
                                                                sequence is decided.
                                                                1 string of char is roll no, 2nd string is name, ...
                                                                There's a 'key field' (unique) for every record on which ordering is done
                                                                    searching on that record becomes easy.
                                                                    can't use binary search- all records not in MM- in different blocks.
                                                                    Update or insert- push records below? to maintain the ordering.
                                                                        that's crazy (imagine for banking we use it)
                                                                        so updation or insertion- not immediately- in free hours.
                                                                        log file/ transaction file captures it all- merged EOD
                                                                        withdraw 1000 Rs- deducted immediately but pass book doesn't reflect- why?
                                                                            merged later- so see in next day.
                                                            Index Sequential File- to avoid sequential access for records.
                                                                main file containing records in sequential form.
                                                                    say 5000 key values- 50 key values selected uniformly distributed.
                                                                index file- in pyramidal form
                                                                    those 50 key fields with pointers to blocks that contain them.
                                                                    look for greatest key value which is lower than you are searching for.
                                                                    Thus, searches are reduced.
                                                                        imagine 5000 vs 25 (average index searches) + 50 (block search)
                                                                    Second Level index, to index entries in 1st level index.
                                                                    so on and on.
                                                                Here also insertion and updation done in overflow file
                                                                    keys with 60 and 75 in main file- insert 72- keep pointer of 60 to 72.
                                                                    updation done in EOD- following pointers- advantage.
                                                                    even during the day- I can search for them following pointers.
                                                                    imagine inserting 74- additional overflow file- set pointer of 72 to 74.
                                                            Tree Index- B+ Tree Indexed Tree
                                                                AVL tree- Difference between left and right child is at most 1
                                                                Leaf Nodes- contain records
                                                                Nonleaf Nodes- contains keys to arrive to records.
                                                                A block contains- (n-1) values and n pointers.
                                                                    depends on size of block and size of key value and pointers.
                                                                    trace a path depending on comparing Kp with Ki, Kj, etc.
                                                                To maintain balanced nature
                                                                    node has to be at least half filled.
                                                                    for n=3, at least 2 pointers.
                                                                    check parent node if leaf node splits- parents may have to split.
                                                                complicated insertion and deletion but time reduced remarkably- log n base 50 search operation.
                                                            Fully Indexed
                                                                all students who have cgpa > 8.5 -> get records of those.
                                                                do indexing for all fields or many- searching will be faster.
                                                            Hashed File/ Direct File
                                                                Ordering of key values- ordering depends on hash function
                                                                H(Kp) = l then lth entry gets value of Kp.
                                                                Linked list for every hash values.
                                                            Unix
                                                                every access thru Inode TOC- file is just sequence of byte
                                                                Here no direct relation to Inode TOC- these types of files are not understood.
                                                                    I don't have index file, etc.
                                                                    if I go for sequential file- which part would contain index and which part for data- app program decides.
                                                                    Unix doesn't decide- No OS decides in general.
                                                                    DBMS- between File and DBMS- another layer.

                                                    Logical I/O
                                                        so that Application programs get to access records
                                                        Program needs not blocks but records or fields.
                                                    Basic I/O Supervisor
                                                        It monitors all these operations on the device chosen
                                                        does buffer assignment- which buffer will be taken
                                                        performance optimization- reschedule all the arbitrarily ordered request- to optimize performance
                                                            Eg- Magnetic Tape- Serial storage Device
                                                                if request arrive in sequence as- 100, 105, 70, 90, 45, 41, 50
                                                                if head has to move forward backward- a lot of travel vs reorganize them in ascending order- so as to finish all tasks in 1 pass.
                                                                collect over a period of time.
                                                            Eg- Magnetic disc- plate or cylinders- situ can be head on every track or 1 head/ face.
                                                                8 msec/ 1 revolution and 8 msec for R/W h movement from 1 track to adjacent.
                                                                Track, Block- (0,2), (1,2), (1,3), (1,5), ....
                                                                How to organize them?
                                                                    flatten it out- we have track, block pairs- after 7 comes 0.
                                                                    desired sequence is- (0,2), (1,3), (1,5), (1,2), (2,3), (2,4)                                                        
                                                    Basic File System (primary interface between computer system and envt outside of it)
                                                        getting block of data from device and placing it on buffer cache and other side.
                                                        Initiate I/O operation and finishes it.
                                                    Device Drivers (disk driver, printer driver, etc)
                                                        sends interrupt to CPU that particular I/O is complete- does reading.
                                                        softwares that control the device.
                                                    Devices
                                                Process
                                                    User command
                                                        File Structure
                                                    File Manipulation Functions (access methods)
                                                        Records/ fields (in block of file)
                                                    Blocking (disk understnads blocks)
                                                        Blocks
                                                    Free Storage Management

                                                    We have not yet seen- Records to block and vv.



                                    </FileSystemArchitecture>
                                    Device Driver- sent by the device to inform the device controller (in its terms)
                                            eg- for Magnetic Drum- which Cylinder No, Track No, Sector No you want.

                                </FileSystemManagement>
                                <Security>
                                    when resource allocated, others should not use it.
                                </Security>
                                <DistributedFileManagement>
                                    Remote Procedure Call (RPC) a high level model for Client Server Communication.
                                        vs Local Procedure Call.
                                        It provides programmers with a familiar mechanism for building distributed systems.
                                            Caller blocks until response comes.
                                        As if you are calling a program in your computer but communicates with remote PC for procedures over network thru API.
                                        How?
                                            Marshalled Request is sent to Remote machine- it receives request- selects procedure- Unmarshalls argumenets- executes procedure, marshalls results and sends reply which is unmarshalled and used.
                                                Marshall means- String pass by value- sum int 5 int 10.
                                                Servers advertise their API so it is universal.
                                        Why?
                                            Easy way to get services from server
                                    Backbone network (LAN, say) and machines connected over network
                                        powerful machines- CPU, memory, etc
                                        files are distributed across workstations.
                                        File servers (powerful) and clients (less powerful)
                                            file server[s] delivers files desired by client
                                        2 Models
                                        1. Client process puts request for a file- file is transferred to client- stored in HDD Of client or MM.
                                            clients writes back on file server after modification.
                                            download and upload operations
                                        2. Remote File access- client process
                                            not entire file is downloaded- file exists on file server.
                                            request and response system for part of files.
                                            less storage requirement of client.
                                        File name or path name to get to inode- then read/ write
                                            either model we access file on 1 server- any location (transparent to client)
                                        Say Directory structure part ABC on machine 1 and DE on machine 2.
                                            same view of Directory structure or different?
                                            global view is necessary- root directory branching into each server's directory structure.
                                                clients see this complete picture.
                                                or use a leaf of server1 to use tree for another. (but same view we want)
                                        Every file name has inode number and machine number to identify.
                                            these 2 together uniquely determine a file
                                            for a path like a/b/c- we get to a machine.
                                                if b in another server- server1 tells client to refer to server 2.
                                                fresh request to another server.
                                                vs forward request to next server and so forth and send result to client.
                                                    reduces network traffic.
                                        If upload/ download model- entire operation on file is complete and then written back
                                            but updated info not there with server- 7 requests for it- client2 gets obsolete data
                                            write through mechanism- the modification is immediately transmitted.
                                                server copy- updated data with server.
                                                delayed write problem- 
                                                client 2 gets the older version of file
                                                    client 2 should get not cache version (old one)- what is latest version no or time stamp
                                                    compare with cache copy- if match use cache, else invalidate cache and bring server 1 file.
                                                    called cache consistency problem.
                                            Replication- same file on multiple servers- if 1 crashes/ fails, still no worries.
                                                also load balance- if S1 is busy, S2 can be used.
                                                modification- has to be made to all copies. Costly!
                                                    voting method is used- n copies of file f
                                                        Nr- read quorum
                                                        Nw- write quorum
                                                        Nr + Nw > N
                                                        if Nw machines agree on writing- then write.
                                                        Nr must agree for read operation- for read.
                                                            latest version copy is used here.
                                                        If Nw write and Nr are read- at least some machines contain recent data version.
                                                            client sees the latest one and picks it (it will be the best one)
                                                    If machines are down- then fulfill thru dummy files.


                                </DistributedFileManagement>
                        </ResourceManagement>
                </Purpose>
                <Types> Types of OS
                        Batch OS- Long back (70-80), single computer ( being scarce, mainframes) to which e1 given access- give programs to mainframe 1 after the other in queue.
                                Non-interactive
                                        later users will come and pick it up. J1J2J3J4...Output(J1)saved somewhere and so on.
                                        give the input a, given; give b, nope!!
                                So starvation 
                                        Problem- 1 bulky process may starve others. Say J1 takes 10 days.
                                throughput (jobs finished per second) is less
                                        Processes take time. 2 types- 
                                                CPU bound- using CPU time more than I/O time.
                                                I/O bound- using peripheral devices- HDD,scanner,etc more than CPU time.
                                        while a process is in i/o phase, the cpu time is wasted, could have been given to J2.
                                Not used generally but supercomputers, you submit jobs, they will wait in queue. in queue, your turn.
                        Multiprogramming- while i/o of a process, CPU can take other process and execute it. Many processes "READY" (Ready State) to run.
                                More throughput
                                        So CPU is busy all the time- so efficiency or throughput improves.
                                        this paradigm doesn't support preemption.
                                Multiplexing of CPU,etc.
                        Multitasking (aka Time Sharing (Y))- extension of Multiprogramming- pre-emption facility (forcefully stopping a process in middle of execution for other process' execution) 
                                no starvation
                                        CPU multiplexes between jobs in round-robin fashion without any job finishes- no job waits for a long time.
                                        Here also CPU is busy all the time but no starvation.
                                        although slight difference- used interchangably with multiprogramming.
                        Multiprocessing- Not 1 but many CPU.
                                So parallel execution of jobs. So, throughput increases
                                Similar to having many computers but less costly. Memory, etc are shared though.
                                Reliability increases- if 1 CPU fails, crippled but dual(2),quad/octa(4/8)- multicore- 1 CPU fails, other will take over.
                                different CPU can have their own style of execution- batch, etc.
                        Realtime- jobs have the deadline- finish within strict deadline.
                                giving result after time is of no use.
                        Distributed/ Network OS/ Parallel Computing/ Cloud Computing
                </Types>
            </Ravula>
            <RTOS>
                Evolution
                Batch- results after hours also valid.
                Online- some indication of response on IRCTC, delay not catastropic.
                RTS- it can be useless or catastrophic after deadline.
                        Concerns
                                How much memory- stack should not overflow.
                                How much time- 
                                        like robot coco-robo (automatic vaccum cleaner- sees cliff, directions_
                                        cockpit computer hangs!!
                                How much power
                                        unused parts should not consume power
                                        should be able to recover disaster or perform still
                                        Use 1V for 1 not 5V if possible.
                                        Eg- wifi turn off!
                                Eg- Airbag should come out at right time for automated cars.
                                        OS for car? Yes, if on H/W change the configuration may be very difficult. Update it to newest.
                                No buggy codes- bugs in s/w part of life- what if h/w guy says so!
                                Schedulers eg-
                                        ping, search dhcp server, clock.
                                        Memory cleaners are not- if system busy, they can't clog the processor time.


                        We don't want to waste time on interrupt servicing
                                while in ISR, another interrupt comes, if low priority do nth; else save the context and reload after done.
                                this is wastage of time.
                                        so may even deny,allow on another kernel thread or keep priorities of proc high.
                                        RTOS is also preemptive (many processes) and utility busy I/O.
                        3 types
                                Hard- Missing deadline is catastrophic. Of course, some may demand still finish the process.
                                        The degree of strictness we have with results b4 deadline but not deny the process if missed.
                                        go negative on value.
                                        Eg- fire alarm, Parachute, cockpit control.
                                        Eg- Anti-braking system.
                                Soft- After deadline, the utility of results keep on reducing.
                                        go exponential degrading.
                                        eg- cricket update, stock exchange, weather forecast.
                                        Eg- printer, DSL Modem (resending the packets).
                                Firm- Result are useless after deadline.
                                        Eg- OTP of bank transaction.
                                        Eg- real-view mirror.
                        Characteristics
                                It should be predictable.
                                        can demonstrate and have confidense that the process will finish by deadline.
                        Aspects
                                Firmware- any program that is tied to H/W. in that sense, OS also but not hard-coded.
                                        Eg- BIOS, device-controllers.
                                Implementation of printf within compilers- of course, call write but no magic here.
                                        Eg- int printf(const char* str,...);
                                                ellipses- meaning function arguments just catch- pointer to str- the string and no other args passed.
                                                How get those values- The str is pointer value on stack of the program- right next/behind to it are the values of int/float.
                                                so, char **fm = &str; int p = (int)*(fm-sizeof(int));

            </RTOS>
            <Eg>
                <LINUX>
                    <Overview>
                    Overview b4 starting to use LINUX- no GUI, only understand it.
                    LINUX has benefits- but things that catch you up with problems.
                    What LINUX is; where came from.

                    LINUX is an OS- 
                            OS is Software layer- between hardware and software used for sth productive.
                                    Medium to talk to hardware.
                                    Windows between office and hardware.
                            Desktop Software applications not of same type as windows.
                                    office or adobe- No! Mainly servers- apache, DB server, web server, virtualization server.
                                    LINUS torvolds- 91 to 94- Hobby Project. From scratch and not sth's derivative
                                    X in end- cmds similar to UNIX- so LINUX is type of UNIX- No! They are separate.
                                    He wanted to create Open Source OS for people to use.
                                            Now UNIX is Open Source for most part but in 90s not- pay somebody to use it.
                                            Microsoft pay always.
                                            Why? He and his buddies wanted to create programs without having to pay someone.
                                    Gonna look different and is separate from all others.
                    </Overview>
                    <Distributions>
                            Made available to world and allowed e1 in world to change OS as they thought fit.
                            Berkley- all creating their own versions of LINUX. E1 (china,brazil) playing with the code that he allowed.
                            You like free and LINUX is more secure.This created Distros or Distributions we will run into.
                                    Versions of LINUX ppl have created
                                    94 only LINUX but educational institutes and Companies- started creating their own versions- Redhat,ubuntu,googleAndro,
                            Every distribution unique in doing sth- Trusted (solid- no antivirus attack, secure)
                                    secure system- trustix
                                    call center help when needed- redhat
                                    ubuntu prob- not supported by redhat fella.
                                    DSL- Damn Small Linux (52 MB)
                    </Distributions>
                    <OpenSource>
                            Open Source Software doesn't mean free software.
                                    Programmers reveal you the source code they wrote, that's it.
                                    How it was written b4 object code.
                                    Huge OpS happens to be free but doesn't mean.
                            How to they earn?
                                    1. mysql absolutely free- be it amazon (use it)- but when help is needed, for support like training, they get money.
                                    2. OpS- Lincense issues and how it works. For personal and non-commercial purposes it is free. Not for commercial, no production environment. 50-10K $.
                                    3. Buy the software- and you can see the code- enterprise can see the code- but can't modify.
                                            can't remove a code- illegal.
                                    4. Download the server- legal right to continue using- recurring amount. 250$ per year redhat on rent.
                                            massive damage if you don't know these. 
                                            If you go talk to CEO- you gotta talk Lincensing issues.
                    </OpenSource>
                    <Shell>
                            Shell of OS- screen u use to interact with OS- 
                                    <GUIOnWindows>
                                            right click, sounds, etc 
                                        Add,change,remove Startup programs in windows 8
                                                task manager start up tab- disable
                                                Run->shell:startup- 
                                                        if you want to add manually startup program
                                                        a folder in location in users/.../start menu/programs/startup
                                                        drag and drop OR create a shortcut of app and copy in that location
                                                Run->msconfig
                                                        which OS boots
                                                        which services will run
                                                        Startup programs- check/uncheck.
                                                Run->regedit
                                                        it maybe somewhere else- for all users
                                                        current_user
                                                        to do for all users- local machine- software-> Microsoft->Windows->currentversion->run
                                        Windows7 speedup
                                                personalize->windows basic
                                                        no sound (windows sounds)
                                                        no screensaver.
                                                mycomputer->properties->advancedsystemsAnd Settings-> advanced->performance settings (what you want and not visually)
                                                        adjust for best performance (or custom)
                                                turn off windows search option- always running in bg
                                                        computer->manage->services and applications->services->windows search->startup type->disable from auto.
                                                turn off windows features
                                                        control Panel->program and features->turn windows features off->remove games, internet explorer
                                                defragment the OS drive
                                                search->settings->power textbox->high performance
                                                search->settings->disk cleanup->
                                                regedit->currentuser->control panel->desktop->menu show delay- reduce to 10.
                                                        mouse hover time- 10.
                                        GUI
                                                slower and lesser control


                                    </GUIOnWindows>
                                    <LUI>
                                    LUI on DOS prompt- Line User Interface.
                                            LINUX people, geeks like using LUI.
                                            More powerful in LINUX world than GUI.
                                    LUI is not dead but for geeks
                                    <LINUXCommands>
                                        <IIITB> included others
                                                                                        what does vm show on commands? what is their windows equivalent commands?
                                            ctrl-alt-t, man ls, Submit using tex
                                            why
                                                    software implementation has external dependencies- cmds help monitor/ control envt for implementation and testing.
                                                            use netstat to check if tomcat port is open
                                                            why is system slow
                                            how
                                                                                        configuration
                                                                                                hardware
                                                                                                        uname [-sr|-m]? - linux kernel version
                                                                                                                machine hardware type- 32/64
                                                                                                        cat /proc/cpuinfo - processor family, model, cores, speed, cache
                                                                                                        lspci- i/o devices on system
                                                                                                                machine's ethernet card- brand and model
                                                                                                                video card
                                                                                                software- 
                                                                                                        uname also
                                                                                                        which version?
                                                                                        State
                                                                                                Hardware
                                                                                                        df [-h] - total/free space of root fs
                                                    mount- root fs type
                                                                                                                partitions in HDD- /dev/sda
                                                                                                                different fs in system- what used for.
                                                                                                        top also
                                                                                                        du- space a file takes
                                                                                                        file [options] filename- type of data within file
                                                                                                Processes
                                                                                                        ps- running processes, users, smallest proc id (recognize 2)
                                                                                                                -efl- to get ppid also.
                                                                                                                aux- gives in percentage
                                                                                                                pstree- nice gui form of spawning.
                                                                                                        top- cpu activity = task manager (q to exit)
                                                                                                                memory used by system mode/ user mode; cpu used for modes;
                                                                                                                learn the impact of browser opening/idle/working/closing on top command metrics
                                                                                                                learn impact of a C program's stages
                                                                                                                find 5 biggie procs consuming most cpu, most memory- which procs are these.
                                                                                                Memory
                                                                                                        vmstat 5 5- how much virtual memory is in use.
                                                                                                        top again
                                                                                                Network
                                                                                                        ifconfig- info on network devices on PC.
                                                                                                                        interfaces- mac, ip; packets sent/received.
                                                                                                                        eth0, lo (no h/w why)
                                                                                                        ping, pathping, telnet, ftp, route, arp, sbstat, getmac.
                                                                                                        netstat- list of open connections. (use why connected remotely)
                                                                                                                        -rn- routing table- default gateway
                                                                                                                        netstat -ntlp | grep LISTEN
                                                                                                        nmap
                                                                                                                sudo yum install nmap (check filtered status in firewall)
                                                                                                                nmap -A localhost -p 3306
                                                                                                                nc -z host.example.com 20-30
                                                                                                        tracert
                                                                                                        nslookup - contacts converts domain name to IP and vice versa.
                                                                                                        ssh
                                                                                                                ssh sheena@192.168.0.11
                                                                                                                On VM
                                                                                                                        sudo apt-get update
                                                                                                                        sudo apt-get install -y openssh-server
                                                                                                                        device > (virtualbox insert guest additions cd image) allow installation 
                                                                                                                        bridged adapter mode
                                                                                                        telnet
                                                                                                        scp
                                                                                                                syntax- scp from to
                                                                                                                        scp ~/my_local_file.txt user@remote_host.com:/some/remote/directory
                                                                                                                        scp user@remote_host.com:/some/remote/directory ~/my_local_file.txt
                                                                                                                        scp user1@remotehost1:/some/remote/dir/foobar.txt user2@remotehost2:/some/remote/dir/
                                                                                                                Multiple files
                                                                                                                        scp foo.txt bar.txt username@remotehost:/path/directory/
                                                                                                                        scp root@192.168.1.3:~/\{abc.log,cde.txt\} .
                                                                                                                Directory
                                                                                                                        scp -v -r ~/Downloads root@192.168.1.3:/root/Downloads
                                                                                                                Options
                                                                                                                        Directory -r
                                                                                                                        verbose -v
                                                                                                                        compression -C
                                                                                                                        Limit Bandwidth -l 400 (Kbps)
                                                                                        Actions
                                                                                                processes- kill- stop process (-9 to force)
                                                                                                file
                                                                                                        <chmod>
                                                                                                        chmod [options] mode file
                                                                                                                r- read
                                                                                                                w- write
                                                                                                                x- execute
                                                                                                                grant permission by +, revoke by -
                                                                                                                chmod u+x filename
                                                                                                                chmod u+r,g+x filename
                                                                                                                chmod u-rx filename
                                                                                                                chmod a+x filename
                                                                                                                chmod --reference=file1 file2
                                                                                                                chmod -R 755 directory-name/
                                                                                                                chmod u+X *
                                                                                                        </chmod>
                                                                                                <TraversalRelated>
                                                                                                        ls [dir]- list directory content
                                                                                                        cd /path- change directory
                                                                                                        pwd- present working directory
                                                                                                </TraversalRelated>
                                                                                                <fileContentsRelated>
                                                                                                        grep- search for a pattern
                                                                                                        tail [options] file- last n lines of a file
                                                                                                        locate file- search for file in directory contents
                                                                                                </fileContentsRelated>
                                                                                                <PromptRelated>
                                                                                                        man- manual help
                                                                                                        clear- screen clear
                                                                                                        less- paging the output
                                                                                                        echo- write on stdout
                                                                                                </PromptRelated>
                                                                                                <FileManipulations>
                                                                                                        touch file- create a empty file
                                                                                                        rm [options] file- remove file/ dir
                                                                                                        rmdir- delete empty directory.
                                                                                                        cat file- display file on stdout, concatenate
                                                                                                        cp- copy
                                                                                                        mv- rename or move
                                                                                                        tar [options] fiilename- store or extract to/from tar file
                                                                                                </FileManipulations>
                                                                                                <Administrative>
                                                                                                        passwd- change password
                                                                                                        su- switch to another user                                        
                                                                                                        ssh [options] user@machine- remote login to another LINUX machine over network
                                                                                                        who- displays who is logged on.
                                                                                                </Administrative>
                                                                                                <Experience>
                                                                                                    mv presto-server-0.170/ /opt/presto- to move a directory to another place with name
                                                                                                    ctrl+alt+f1/f7- switch cmd/ gui modes in ubuntu
                                                                                                    top -n 1- to print it out only once.
                                                                                                    sudo su -/username- to switch user modes
                                                                                                    command clear screen
                                                                                                            tput reset vs clear/ ctrl+l
                                                                                                            ctrl + l or clear for moving shell prompt to top of screen.
                                                                                                    Username- whoami
                                                                                                    Username- whoami
                                                                                                    LINUX (centos v7?) commands
                                                                                                    whereis hadoop
                                                                                                    ll = ls -l
                                                                                                    find . -name "Fin*"
                                                                                                    curl ~ wget but more unrestricted over protocols
                                                                                                    sudo easy_install pip; pip install pg8000 simplejson
                                                                                                    yum install clean- to clean up the installed cache of yum.
                                                                                                    rpm -i DeathStar0_42b.rpm- to install, -U to upgrade using rpm file.

                                                                                                    /usr/bin/gcc

                                                                                                    /root/.bash_profile
                                                                                                    /root/.bash_history
                                                                                                    /root/.bashrc- for changing envt vars

                                                                                                    yum upgrade/install/remove gcc
                                                                                                    export ANT_HOME=/path/to/ant/dir
                                                                                                    export PATH=${PATH}:${ANT_HOME}/bin:${JAVA_HOME}/bin
                                                                                                    ping from ssh- not allowed!
                                                                                                    scl enable devtoolset-2 bash- to see upgrade of gcc
                                                                                                    make file
                                                                                                    maven
                                                                                                    yum groupinstall "Development Tools"
                                                                                                    rpm, rpmbuild
                                                                                                    CLI OS- shift + PgUp
                                                                                                    ls
                                                                                                            * marked files- executable (when -F is passed)
                                                                                                            yum install tree
                                                                                                                    tree . (very useful for thorough listing)
                                                                                                    in ubuntu, sudo -i or sudo su instead of su- ?cuz ubuntu root account is disabled or su influx to get back to a user.
                                                                                                            todo- linux user, root, group, others- how it works
                                                                                                    copying shell script from windows to linux
                                                                                                            problem was end of line in windows = '\r\n', mac \r, linux \n.
                                                                                                            \r is not special in linux (C lang)- so \r was taken as a character and mkdir was creating a mess!!
                                                                                                            teletype- \r would mean take carrier to leftmost and \n meant to take to next.
                                                                                                            Generally programs are neutral towards \r,\n. Shell script mkdir folder was making folder containing ascii 10 at its last
                                                                                                    LINUX shell is smart-
                                                                                                            first arg has to be a program in envt path- tab won't show otherwise.
                                                                                                            if executable in current directory, ensure ./executableFile for tab to detect- being .sh aint sufficient make it with +x for user.
                                                                                                            missing 'http://ip' in the config.properties of presto/etc- it threw error of 'Unable to create Injector'
                                                                                                    Install for all users in Progra~1 but for alone- inside ~/username/..
                                                                                                    alternatives not required if path is set with updation prepended to the path and not appended cuz 1st one wins.
                                                                                                            problematic only when a code specify uses that path to refer the program.
                                                                                                </Experience>
                                        </IIITB>
                                    </LINUXCommands>
                                    <WindowsShellScripting>
                                            <About>
                                                    list of comands in order to perform a task
                                                        wife gives a list to purchase for dinner- get all items. you find all items 1 by 1.
                                                        commands one by one till final result.
                                            </About>
                                            <EnvironmentSetting>
                                                    make folder- scripts
                                                    desktop->new shortcut->windows->system32->cmd.exe
                                                            looks and UI thru properties
                                                                    open app-> properties-> options->QuickEdit mode- to enable copy paste (?thru right click)
                                                                    layout- increase buffer height- to be able to view
                                                                    change defaults (target)- to different directory
                                                            shortcut properties->shortcut->target and start in? change to c:scripts dir
                                                    system32->notepad.exe->send to desktop.
                                                            making bat file (executable script,shell script, batch file)
                                            </EnvironmentSetting>
                                            <WriteBatchFile>
                                                    <Comment>
                                                    comment to read it yourself later
                                                            using rem commands	//rem this is my first script
                                                                    shows on screen
                                                                    @rem- to not show it.
                                                            using ::	//:: this is my first script
                                                            @- hides the current command to show up on command prompt (not output)
                                                    </Comment>
                                                    <EnvironmentVariables>
                                                            When need to refer a path (repeatedly), we can hardcode it or use envt var.
                                                            Eg- C:/windows (what about PC with D: drive containing OS) or winNT.	//also solves paths of diffn PC
                                                                so rather than relying on it being hard coded, find where the path to window directory is and use that.
                                                                    use ?set to see all path variables.
                                                            Setting
                                                                    use- 'set' to see the [environment] path variables. 
                                                                            By default it's global so write outside of script to avoid reuse.
                                                                    computer->properties->advanced->envt var->
                                                                    Set local to avoid spoiling system variables
                                                                            setlocal		//prefer local to avoid accidently affecting system variable or using prev inapt value.
                                                                            set data = c:\data	(or set data = 25)
                                                                            echo %data%	//local overrides
                                                                            endlocal
                                                                            echo %data%	//global executes
                                                            Using
                                                                    use them in scripts like dir %windir%	// path variable in % sign.
                                                                            execute it without echo off/@ and you will see - C:/Windows
                                                                            Eg- to use desktop page- use administrator path- and cascade to reach desktop
                                                                                    dir %administrator%/desktop- you yell this is correct path (console doesn't like you space)- quote the entire command- "hey presto" it works.
                                                                            Eg- copying a file- copy "%systemdrive%/new file.txt" "%userprofile%\desktop"
                                                                    data folder to be made path variable (new)- set data=c:\data	// has global scope (continue to exist beyond running script (name be unique))- e1's computer has.
                                                                            use echo data or set to confirm.
                                                    </EnvironmentVariables>
                                                    <Operators>
                                                            /A- using /A intimates that envt var should interpret value as integers
                                                            Operations- LSS (less than),GTR (greater than), LEQ (Less or Equal),GEQ (Greater or Equal),NEQ (Not Equal), EQU (Equal)
                                                    </Operators> 
                                                    <InputOutput>
                                                        <Arguments>
                                                            ping cmd	//does nth (args b4 using). tell args to use.
                                                            input to the script in form of %1,%2- use these argument variables in the script somewhere.
                                                                Null is taken if script uses args which are not supplied thru cmd.
                                                                Pay attention to space- space makes a new argument.
                                                                    Use "" for spaced filenames and %~1 to remove quotes.
                                                                %~f1- full path
                                                            %~d1- is on drive
                                                            %~x1- file extension
                                                            %~t1- file created on.
                                                            %~z1- size of file
                                                            If Exists %1
                                                            ~ to ignore double quotes.
                                                        </Arguments>
                                                        <Echo>
                                                        Echo- like you yell and it comes back- hello world- most experienced programmers love to see!
                                                                Echo off
                                                                        stops showing commands on console
                                                                        put @ in front.	//@stops current line from being displayed. and other commands also.
                                                                        @echo on to show commands on console.
                                                                @ hides the current line- not the output.
                                                                echo to tell the path echo %windir% (%later)
                                                        </Echo>
                                                        <Redirection>
                                                                to print output to text file and not console (echo)
                                                                if file doesn't exist it will be created for us.
                                                                >> is appending- not exists, created.
                                                                    append is for logs.
                                                                > overwrites if sth already in there of not interest.
                                                                    //html uses ^> cuz > has special meanings- escape char
                                                                    to hide output use dir > NUL (no output)
                                                                space delimiter handled automatically so delims doesn't need to be informed
                                                                Eg- @echo off
                                                                    FOR /F "tokens=1-4 delimns=/ " %%I IN ('DATE /t') DO SET mydate = %%J_%%K_%%L
                                                                    echo Yet another script >> append_%mydate%.txt
                                                                    Echo second line >> append_%mydate%.txt
                                                                Eg- @echo off
                                                                    echo .LOG >> append.txt

                                                                1> is default, 2> for errors, else ugly errors show up. incompatible not written.
                                                                both in a cmd; 2>&1 means also to 1> only.
                                                        </Redirection>
                                                    </InputOutput>
                                                    <ControlStatements>
                                                        <Conditionals>
                                                                gives flexibility to do anything on condition
                                                                    if exists if a file or folder exists.
                                                                        @echo off
                                                                        If Exist "C:\Text.txt" echo the file exists else echo the file doesn't exist
                                                                        If Not Exist "C:\Text.txt" echo file doesn't exist.
                                                                        If Error level 0 GoTo :EOF
                                                                    using relational operators
                                                                        Eg- @echo off
                                                                            set name=Bob
                                                                            If %name%==Bob Echo %name% and Bob are the same.
                                                                            //can replace % by .,!,etc.
                                                                //ctrl+z to bring file back from recycle bin.
                                                        </Conditionals>
                                                        <Loops>
                                                                Need to loop over list of items- list of directories, file to retrieve a list of values
                                                                say, 10 PC hostnames in a text file- ping e1 to see if they respond.
                                                                        10 PC pinging is not difficult (only boring), 1000 PC or more.
                                                                        Iterate
                                                                options( /f to loop thru file, /d to loop thru directory)
                                                                %%i- iterator- gets vals- 
                                                                        if from cmd prompt then %i only.
                                                                        shell script then %%i.
                                                                    do it from list of script.
                                                                        Eg- in (enumeration1 en2 en3) Do @Ping -n 1 %%i
                                                                token = 2, to get 2nd token from the parse
                                                                for /f "tokens=1,2 delims=," %%i in (C:\tokens.txt) Do Echo %%i %%j
                                                                        - the value gets moved to the next variable/ iterator.
                                                                        %%j can come b4 also and data will move towards it.
                                                                set /A some arithmetic here- without /A it is string.
                                                        </Loops>
                                                        <Labels>
                                                            Labels-goto cmd. :number- create a reference to return to.
                                                            Eg- 
                                                                @Echo off
                                                                set /A no = 0
                                                                :number
                                                                set /A no = %no%+1
                                                                echo %no%
                                                                If %no% LSS 100 GOTO :number
                                                            Variant- <!-- ^<href=http://www.images.com/image_%no%.jpg^>Image_%no%^<^/a^>^<BR^> -->
                                                        </Labels>
                                                    </ControlStatements>
                                            </WriteBatchFile>
                                            <Commands>
                                                explorer "C:\Progra~1"
                                                        explorer.exe from task manager if windows appearance is gone!
                                                start chrome.exe
                                                start chrome.exe google.com
                                            </Commands>
                                    </WindowsShellScripting>
                                    </LUI>
                    </Shell>
                    <Root>
                            The highest level of anything.
                            Root user is highest level of admiministrator you can be on PC.
                            if log in as root then you have highest previliges.
                            Root of OS- the highest level where it is installed. eg- C:/
                            Root of User- where use can get in- home directory.
                    </Root>
                    <Capitalization>
                            Uppercase and Lowercase are different.
                            Home and home and HOME are different- Windows doesn't care except password.
                            HOME won't be found in linux if only folder is home.
                            Y? LINUX created for/by Computer professionals; different ASCII character.
                            many websites ignore cases of usernames.
                    </Capitalization>
                    <ServerVsDesktop>
                            You wanna install LINUX but 2 versions of distributions.
                            I want server- may be a mistake. Don't start with that.
                                    It is stripped down version- no GUI. 
                                    No tools automatically download.
                                            every additional function you add is a potential weakness, a hacker can manipulate
                                            reduce functionality to reduce hacking opportunity
                                            eg- mac OS is hard to hack like brick and they hack flash of adobe and get in.
                                    only DOS prompt- only bare bones for what you need- security.
                                    But rock solid for any server applications for your clients
                                            no reboots (memory leaks, crashes)
                                            Secure
                            Better Desktop to start with- looks sth like Windows and mac.
                                    and learnt he envt. Redhat,fedora, susi,etc.
                                    are little buggy. 
                    </ServerVsDesktop>
                    <WhyUseLINUX>
                            Vista came out and e1 wanted to move to LINUX.
                            As desktop OS, LINUX is not of speed, it pains, quirky, freezes up and weird stuff like Windows 98.
                                    Stupid problems
                                    Windows 7 is quite functional; does what it promises well.
                                            works well with all softwares I buy.
                            LINUX is rock solid for server- runs till hardware burns out.
                                    reboot only for maintenance.
                                    No memory leaks like windows or crashes or weekly reboot.
                                    web server- it steals the show. Run website from home.
                    </WhyUseLINUX>
                    <InstallingLINUX>
                            download ubuntu- popular- little google search like apt-get vs yum same stuff but different commands.
                                yum update yum is perfectly ok
                                yum list
                                pip install --upgrade pip
                            <ServerVersion>
                            Server Version- download only for server no GUI;only blinking cursor in end)
                                    even commercial, it is absolutely free.
                                    download iso- Ubuntu.com->server, of many versions->prefer 64 bit version.
                                            if doesn't dowload then 32.
                                            all processors for long had been 32 bit but lately 2006 or so 64 bit became popular.
                                    burn on cd or USB
                                    insert cd on virtualBox (by oracle, sun before) or otherwise.
                                            for install
                                                    english->install->US and yes-> what kinda keyboard->use entire disk.changes to disk yes.
                                                    answer yes in US you are fine.
                                                    Do not encrypt your home directory- can't recover data if linux crashes.
                                                    any proxy server to connect- no. Updates is reqd ew- say no automatic- cuz new.
                                                    what kinda server you want- if you knew it was web server- LAMP (LINUX Apache MySql and PHP).
                                                    Windows throw in everything in installation. not this. windows makes it vulnerable cuz of this.
                                                    GRUB bootloader to master boot record- yes. dual boot- or any number- another class.
                                                    ends with the terminal screen- success!
                            </ServerVersion>
                            <DesktopVersion> looks file systems and looks familiar
                                    little GUI version that's familiar.
                                    It's not quite there yet to throw windows and mac to garbage cans.
                                    for learning b4 on server.
                                    use recommeded bit version if you don't know.
                                    Download
                                    Burn on cd or USB
                                    insert cd for virtualbox or otherwise
                                            for live- OS on CD- learn by booting directly. create docs, eth.
                                                    nothing changes on hard-drive.
                                            for install- English, USA time zone, USA keyboard, erase and use entire disk or partition
                                                    who are you? Computer name. 
                                                    Login automatically- data recovery; but files safety then password et.
                                                    see the hardware requirements for GUI- 512MB RAM, 5-6 yrs old PC will do.
                                                    Applications- have microsoft equivalent softwares. evolution for outlook, etc. Libreoffice.
                                                            terminal for terminal prompt
                            </DesktopVersion>
                    </InstallingLINUX>
                    <BasicLinuxTasks>
                            (thru commands)
                            on LUI- all serious administration thru CLI; graphic not enough.
                            sudo- super user do- different distro, security. Root admin of windows- can do anything on PC (hackers try for administrator rights)
                                    Ubuntu decided they won't anything to enter as root. Login as root- No!
                                    equivalent to run as administrator in windows.
                                    eg- sudo apt-get- run commands as administrator.
                            man- came from unix. manual
                                    man pages so as to know eth you should know about a cmd (eg- man ping)
                                    google seems better these days than man.
                                    hit q to quit from the man page. there is no other way- stuck! you will want to throw PC outta window.
                            tasksel- part of ubuntu distribution. Premier provider of LINUX distribution- done lotta job- user friendly like LINUX.
                                    task select. When you are setting up a server- you need to install- set of softwares with connectors.
                                    Ubuntu says hey! install all of them- we will use script for all of them. 
                                    Checkbox for the server type you want- all softwares installed for that package.
                                    30 mins and your server up and running.
                                    sudo tasksel- need root admin.
                            Install Applications
                                    Most of these stuffs are free. Pay in strange ways.
                                    Eb has insane procedures in windows- to protect piracy- right cd, right code, hit activation servers.
                                    Repositories- install application from there. All or huge softwares sit in those repo. grab from there.
                                    Other ways also but later. Going to repo is simplest as of now.
                                    sudo apt-get install apache2
                                            apt-get- it will go and get from repo.
                                            install- install it.
                                            softName- name of the software
                                            do google search to choose most apt software.
                                    sudo apt-get remove apache2
                                            to uninstall
                                            special backup proprietary softwares- follow different rules.
                                            no copilation here.
                                    sudo apt-get upgrade
                                            every software package needs upgrade or update	
                                            any software of repo has version greater than urs.
                            Services
                                    LINUX is good for servers. Once a year reboot is overkill- changing config files necessitate restart the services.
                                    sudo /etc/init.d/apache2 start/stop/restart
                                            you can go and update but the service of web stops for 2 seconds.
                                            vs windows web service offline for 4-10 minutes.
                            top
                                    task manager of linux.
                                    how much of cpu and memory is being used and for every proc with pid.
                                    to kill a process- k (PID). eg- kill pid of top.
                                    kernel or important process- then it won't allow- then once a year reboot is to be done.
                            Navigation
                                    folder navigation- cd (change directory within current directory) or absolute path.
                                            to go to lower level folder cd subFolder
                                            cd /abc will look for abc folder within root directory.
                                            cd /ABC is different cuz of capitalization. that's why linux keeps its own files and directories in small cases.
                    </BasicLinuxTasks>
                </LINUX>
            </Eg>
            <Uncat>
                Making OS
                https://www.youtube.com/watch?v=ViNnfoE56V8
                https://www.youtube.com/watch?v=6MJUGVFAXKg
                System Calls Wiki	
                    System calls can be roughly grouped into five major categories:
                            Process Control
                                    load
                                    execute
                                    end, abort
                                    create process (for example, fork on Unix-like systems, or NtCreateProcess in the Windows NT Native API)
                                    terminate process
                                    get/set process attributes
                                    wait for time, wait event, signal event
                                    allocate, free memory
                            File management
                                    create file, delete file
                                    open, close
                                    read, write, reposition
                                    get/set file attributes
                            Device Management
                                    request device, release device
                                    read, write, reposition
                                    get/set device attributes
                                    logically attach or detach devices
                            Information Maintenance
                                    get/set time or date
                                    get/set system data
                                    get/set process, file, or device attributes
                            Communication
                                    create, delete communication connection
                                    send, receive messages
                                    transfer status information
                                    attach or detach remote devices
            </Uncat>
        </OS>
        <CN>
            <Foundation>
                <Intro>
                Networks 
                    VIZ - We have networks (mutual exchanges thru communication) in everywhere around us
                            Biology- neurological, ecosystems.
                            communication (Broadcast)- TV, Radio, phone, credit card, Internet, Post.
                                Social (unicast, multicast)- Friend, family, club.
                            Utility- Water, sewage, Power.                                
                            Transports- air, water, land.
                    CN Apps- Important and visible in our day today aspects
                            Proof- we are dependent on it- How? what happens when it taken away. we are upset. CN is 2nd O2.
                                    REL Imagine in office, Internet goes off- a lot of things may stop because of that.
                                    REL Telephone stops working or is stolen- we complain- how talk to family.
                                            JOK Family may be secondary though!
                </Intro>
                <Protocol>
                        Defn
                            A set of rules and standards.
                            at all layers.
                            Why?
                                E1 has unique way of doing things,have differences [in H/w,s/w] and consistency is a must for compatibility
                        That for internet set by
                                IETF- internet engg task force.
                                    has WG- working group to which ideas can be sent which are discussed and analysed for which is best b4 implementing.
                                    Protocol setting standards for Application, presentation, session
                                            w3c- world wide web consortium- standardization of web-browser (User Agent; client)
                                                    st client can act as a server- giving files to another computer.
                                RFC- Request for comment
                                    Protocol Setting for Physical thru Transport.
                                3GPP(3rd generation project partnership) for mobiles/IEEE for Wifi in laptops- for data link layer and physical layer
                                    IEEE- ethernet, wifi, w:max
                                    3GPP- LTE4G, 3G, LTE-advanced- 4G-A
                        Both have to agree on same formats of their expression!!
                                2 RAMs can't communicate
                                Early Man couldn't comm
                                if 2 people don't know same language
                                same knowledge of maths
                        Before starting a commn, we say Hi- to
                                establish a session- get attention
                                confirm he knows same language
                                you are not busy
                                to sync
                </Protocol>
                <Layering> 
                    Many complex sub-problems in which 1 has dependence on other for solution.
                    <AirTravel>
                            Layers
                                    Tickets	Purchase	Complain	//Promise of Taking you to other side on a day,time. You agree to their terms and condn
                                    Baggage	check-in	claim or check out
                                    Gates	Load		Unload
                                    runway	takeoff		land
                                            //Security Check		Secure exit
                                    Airplane routine thru ATC.
                            vs Tier- Tiers means they are physically present like that but layers are just logical for ease of understanding for implementation.
                            Passenger is just a packet to be deliver at other end.
                            Pilot follows the Protocol of Air Traffic Control for eth.
                            All layers taken together guide me to destination.
                            E1 concerned with just their role and do that perfectly and not others'.
                                    Then knowledge and training is very specific to their role and matches on both the ends.
                                    There is a handshake between to peers like bag delivery for check-in/out.
                                            they almost communicate with each other but not directly.
                            ~Knowledge of all browsers is same.
                            Error at any level is unacceptable!
                                    Imagine security allowed a terrorist to enter inside.
                            Same brains at everylevel.
                            Also, there is vertical communication. Every layer relies on those below.
                            Travelling by air was a complex problem with so many issues like security,baggage,travel, complaints but handled seemlessly by layering.
                            Any Complex problem in life break it down to layers.
                    </AirTravel>
                    <HumanBehavior>
                            We are best N/w machines when we speak to a group of people- networking is at work
                            Talking Technical Paper in CN to another person		Both have their CN software of brain active		"I don't agree with you"	//Does anyone think about longitudinal waves while such discussion- that's layering.
                            Presenting ideas in same jargon				Both understand same jargon as a language		"What's that?",BodyLang,face expression
                            Session- Maintaining other people different subjects	keep track of status of discussion individually/face alignment.
                            Transport-words/sentences sematically organized		Multiplexing i/f to that part of brain.(i/f as neurological signals)	//"Amm..Could you repeat!"
                            Network- My face tells the direction of receiver	Who is the intended receiver.	"Are you speaking to me"
                            Data Link- Same Language Constructs Grammar		Standardized to make sure thoughts are transmitted through external words	"I am unable to understand your language"
                            physical- Vocal cords are sender			Ears are receiver.	"Oh! Throat problem- I am not loud!"
                            Medium- Longitudinal Waves that travel through the air.		"There is a lot of noise of wind.Come In."

                            All Layers function well? Communication made possible!
                     </HumanBehavior>
                        Any problem at one end will be addressed at same level at other end.
                        Will it be right to say that brain of Mr.X is communicating with brain of Mr.Y- Logically Yes, physically No.
                        //OR Check-in Baggage communicates with Check-out Baggage team!
                    <CNLayeringNeed>
                        different rules of communication
                        different browsers giving services
                        machines have different hardware.
                        different media.
                        -->divide the problem into logical layers to solve them where 1 layer serves the other layer.
                                while we focus on 1 problem we are not bothered by other.
                                we either assume them or give them a service.
                    </CNLayeringNeed>
                </Layering>
                <CNLayeredArchitecture>
                    <Intro>
                    7 Layers communicate with their peer using these protocols by means of header taking the services from below layers.
                            All Layers add their headers to communicate with their peers so this is addition over the message.
                            All Layers keep making the header fatter until the end and on other end, it becomes thinner as it goes to upper layers.
                                    Hey! Message is broken down right? So are headers added to the broken pieces or Main Piece!
                                            GUESS It might be the case that application header is added and then whole message including app header is broken and Transport header is added to e1.
                                            @Shifting home from India to USA- we pack luggages in packets along with the information where its position should be in new place.
                            Why 7 and not more or less?
                                    We defined them as the complexity of a problem increases (data abstraction- Focus on prob and assume services).
                                    Too Less/too much, complex problem at a level
                        Encapsulation- All layers take services of layers below them to serve their purpose.
                            Eg- Application layer assumes Transport Layer for process to process communication and doesn't bother over that- just consumes its service and serves its purpose application level talk.
                                 Application A tells Application B on specified Domain Name- give me this file- it doesn't care how communication will happen.
                            Eg- TL will just ask NL to send to PC of specified IP so that 2 procs (ports) can talk.

                        Peer To Peer Protocol- All layers talk to corresponding layer of other side.
                            Achieved by every layer adding its header from top to bottom and then on other PC- bottom to top.
                                Message adds application header (meta-talks for application layer on process on other PC)
                                This message (along with its header is broken down into pieces (segments) to transmit end to end PC)
                                TL wants to talk to corresponding TL of other PC- so adds its meta-data (or header or talk/content for TL of other PC) added to every segment.
                                This segment is broken down into many pieces- called packets- packet have their Network header (to talk to routers- where to go?)
                                Packet broken down into frames- tranmssion of packets for every hop is thru even smaller chunks. NL header broken somewhere- DLL header added.
                            Virtual feeling that they talk to each other.
                    </Intro>
                    <UserLevel>
                        UI Or UXD- User Experience Design.
                        <Browser>
                            browser- chrome- 56.0.2924.87
                                Freemybrowser- saurabh.devgun.iiitb- N4JSP8
                                firefox- 51.0.1
                                                            Rats! WebGL Hit a Snag
                                                                    Use Hardware Acceleration when available- reset
                                                                    chrome://flags- reset
                                                                    restart browser
                                                            Chrome blackout- chrome needs to be updated
                        </Browser>
                        CN Apps- Important and visible in our day today aspects
                                Proof- we are dependent on it- How? what happens when it taken away. we are upset. CN is 2nd O2.
                                        REL Imagine in office, Internet goes off- a lot of things may stop because of that.
                                        REL Telephone stops working or is stolen- we complain- how talk to family.
                                                JOK Family may be secondary though!
                    </UserLevel>
                    <ApplicationLayer>
                            To allow access to network resources.
                            Top-Down Approach- Only layer we can touch and experience.
                            It is one piece of app which defines messages exchanged (communicating) between apps (distributed processes) running on different hosts and actions taken to implement application.
                                    use communication services provided by lower layer protocols (TCP, UDP)
                            Implemented by User Agents (browsers,outlook,Putty,etc)-The software application which implements App Layer to get CN services.
                                    software process, interfacing with user “above” and network “below”. 
                                    Mozilla,Google Chrome are instances of User Agents.
                                    Some syntax (formats) are standardized for semantical(meaning)/information exchanges with server.					
                            <InterProcessCommunication>
                                    2 Programs kept on 2 different machines communicate and give/get services.
                                            GUESS Must have been in terms of output of 1 becomes input for other and maybe,some handshake.
                                    Inter-Process communication within a computer happens on OS level
                                            REL When we run a program there is a communication 
                                                    betw IDE and compiler (button click invoke inform when done)
                                                    & shell and console.
                                    Here the processes on different systems are supposed to communicate (using services offered by below layers)
                                    <ClientServerArchitecture>
                                            since the birth of I/N for 3 decades now ('15)
                                            2 hosts that want to communicate take on 2 roles:-
                                                    Client:
                                                            initiates conversation (contact) with server (“speaks first”)
                                                                    typically requests a service from server, 									
                                                                    Web: client implemented in browser; e-mail: in mail reader
                                                    Server
                                                            Response- provides requested service to client
                                                            Eg- Web server- sends requested Web page
                                                            eg- mail server delivers e-mail
                                                    Socket 
                                                            Socket is an [Internet] API which gives abstraction for all the layers below.
                                                                    API: application programming interface
                                                            Socket has a part in application layer which we can use in our user agent/program for taking services of bottom layers.
                                                                    and other part which is in transport layer attached to OS,System controlled.				
                                                            @Socket behaves sth like a door which opens for communication to take place.
                                                            defines interface between application and transport layers
                                                            two processes communicate by sending data into socket, reading data out of socket
                                            <VIZ>
                                                    <DHCP>
                                                    DHCP- Dynamic Host Configuration Protocol- provides static and dynamic address allocated (manual or automatic)
                                                        when PC turns on- you contact it to get IP address from its heap.
                                                            Routers generally have a DHCP built in them
                                                        Manual- is when you ask for 172.17.6.7 (should be unique else "IP Conflict" happens)
                                                        Static- when fixed IP is requested and is given. Let DHCP do maths for you.
                                                        Dynamic- when it is given dynamically based on availability (not sure that same it will remain)
                                                        DHCP packet (sth like a form to fill): 
                                                            Operation Code (request/reply); Hardware Type;  Hardware Length ; Hop Count (max I allow my packet)
                                                            Transaction ID- for naming a communication session (discern different calls)
                                                            Number of seconds (duration for which IP is granted); Unused
                                                            Client IP Address- I will not fill it while sending
                                                            Your IP Address- When Server gives that's where it comes
                                                            Server IP Address- DHCP's address
                                                            Gateway IP Address- to send packet to internet
                                                            Client Hardware Address
                                                            Server Name
                                                            Boot File Name
                                                            Options
                                                                DHCPDiscover- Broadcast! Please gimme a IP (sender's IP:0.0.0.0- UDP port 67. and recipient- 255.255.255.255, UDP port 68). DHCP responds
                                                                    REL "can somebody gimme an address".
                                                                DHCPOffer- DHCP- take this IP- take it- this is your DNS.
                                                                    you may get more than 1 offers.
                                                                    REL "I can offer you 192.168.1.3 for next 3600 seconds.
                                                                    Sender- 192.168.1.1, UDP port 67
                                                                    Receiver- 255.255.255.255, UDP Port 68
                                                                DHCPRequest- Broadcast that this offer I am interested in.
                                                                    0.0.0.0, UDP port 68
                                                                    Receiver- 255.255.255.255, UDP Port 67
                                                                DHCPDecline- Server may decline the address- given to 7 else in that period
                                                                DHCPAck- Agrees to give it
                                                                    "As of now, you can use for 3600 sec.
                                                                    Sender- 192.168.1.1, UDP port 67
                                                                    Receiver- 255.255.255.255, UDP POrt 68
                                                                DHCPNack- Rejects the offer.
                                                                DHCPRelease- I don't need this address anymore.
                                                        Connection- 
                                                            Client Port used is 68 and server port is 67 (?Confirm)
                                                                ports so that not confused with any other process.
                                                            All connections are done on UDP based connections.
                                                            Client broadcasts DHCPDiscover Request (mac address is given) for port 67.
                                                            DHCPOffers arrive- 172.1.2.3 and 172.1.2.1 broadcasted to port 68 client. 
                                                                Client will know from its transaction id.
                                                            Client does DHCPRequest broadcast.
                                                            Server responds DHCPAck or DHCPNack
                                                                if DHCPAck, then sent IP Address, DNS, Gateway for a duration
                                                            B4 duration expires, DHCP requests again, no response, then repeat.
                                                                If DHCPNack, then repeat the process.
                                                                DHCPAck, then good.
                                                            Client at any point can do DHCPRelease- I don't want it.
                                                            DHCP Transition Diagram
                                                                Initializing
                                                                Selecting
                                                                Requesting
                                                                Bound
                                                                    Initializing
                                                                Renewing
                                                                    Bound
                                                                    Rebinding
                                                                        Bound
                                                                        Initializing
                                                    </DHCP>
                                                    <HTTP>
                                                    HTTP- Browsing- RFC 2068standard 
                                                            All Browsing we do- uses this.
                                                                    Defined by RFC- Request for comments.
                                                                    Original Version was http 1.0 created for browsing.
                                                                    Tim Berner's Lee idea was from Bell's lab he told.
                                                            http messages (application-layer protocol messages) exchanged 
                                                                    between browser (http client) and Web server (http server)
                                                                    Services from bottom layeres using socket
                                                                            client initiates TCP connection (creates socket) to server, port 80
                                                                            server accepts TCP connection from client
                                                                            http messages exchanged and connection closes
                                                            Properties 
                                                                    Reliable so uses TCP
                                                                    Stateless
                                                                            server maintains no information about past client requests
                                                                            then how does server remember us to have interactive pages.
                                                                            You don't have to send login and password all the time.
                                                                            Server sends you a number called cookie and from cookie server maintains the data of pages visited, bought items, liking and advertise accordingly its products.
                                                                            Protocols that maintain “state” are complex!
                                                                                    past history (state) must be maintained
                                                                                    if server/client crashes, their views of “state” may be inconsistent, must be reconciled
                                                            How it works?
                                                                    1a. http client initiates TCP connection to http server (process) at Port 80 is default for http server.
                                                                            1b. http server at host waiting for TCP connection at port 80.  “accepts” connection, notifying client
                                                                    2. http client sends http request message (containing URL) into TCP connection socket
                                                                            <!--
                                                                            GET http://www.iiitb.ac.in/student/a.html HTTP/1.0 
                                                                            User-agent: Mozilla/4.0 
                                                                            Accept: text/html, image/gif,image/jpeg 
                                                                            Accept-language:Eng
                                                                            (extra carriage return, line feed) -->
                                                                            Authentication : control access to server content
                                                                                    authorization credentials: typically name, password 
                                                                                    But stateless: 
                                                                                            So, client must present authorization in each request
                                                                                            authorization: header line in each request
                                                                                            if no authorization: header, server refuses access, sends
                                                                            3. http server receives request message, forms response message containing requested object (someDepartment/home.index), sends message into socket
                                                                            4. http server closes TCP connection. 
                                                                    5. http client receives response message containing html file, displays html. Parsing html file, finds 10 referenced jpeg objects
                                                                            HTTP/1.0 200 OK 	<!--status line(protocol,status code,status phrase)
                                                                                                            Status codes- 
                                                                                                            200 OK
                                                                                                                    request succeeded, requested object later in this message
                                                                                                            301 Moved Permanently
                                                                                                                    requested object moved, new location specified later in this message (Location:)
                                                                                                            400 Bad Request
                                                                                                                    request message not understood by server
                                                                                                            404 Not Found
                                                                                                                    requested document not found on this server
                                                                                                            505 HTTP Version Not Supported-->
                                                                            Date: Thu, 06 Aug 1998 12:00:15 GMT 	//header lines
                                                                            Server: Apache/1.3.0 (Unix) 
                                                                            Last-Modified: Mon, 22 Jun 1998 …... 
                                                                            Content-Length: 6821 
                                                                            Content-Type: text/html
                                                                            data data data data data ... 		//response of requested data (eg- Html file)
                                                                    6. Steps 1-5 repeated for each of 10 jpeg objects
                                                                            http 1.0 does handshaking for all 11 objects. 22 RTT.(round trips)
                                                                                    suited for CBSE exam- 50 lakh clicks in 1 sec, send pass fail information before images, individual marks.
                                                                                    Non-persistent
                                                                                            http/1.0: server parses request, responds, closes TCP connection
                                                                                            2 RTTs to fetch object
                                                                                            TCP connection
                                                                                            object request/transfer
                                                                                            each transfer suffers from TCP’s initially slow sending rate
                                                                                            many browsers open multiple parallel connections
                                                                            http 1.1 (w/o pipe) does handshake once and sends 11 objects later. (11 RTT)
                                                                                    Good for business servers.
                                                                                    Without Pipelining: on same TCP connection, client sends next request after the previous request’s object successfully received 
                                                                            http 1.1(with pipelined) uses 2 RTT- 1 for handshake and 2nd for all objects.
                                                                                    With Pipelining: client sends requests for all referenced objects in one go after the tcp connection is established (i.e., handshaking is done)
                                                            URL + "go" -->socket opens the gate- handshake happens, data transfered and socket closes.
                                                                    Welcome port at server is kept at 80 which can change eventually by the server to avoid queuing and jamming 1 port.
                                                                    http used to send html files on request of client by server.
                                                                    Browser says I am capable of communication on http 1.0 & server has all the versions so he uses that.
                                                                    if browser capable of communicating on 1.1 but server has 1.0 browser, complies.
                                                                    Server sends the web objects in response to the request.
                                                                    client receives the response and displays the web objects.
                                                            <DNSServer>
                                                                    What?
                                                                        I ask DNS what's IP for udel.edu- it replies- 128.175.13.92
                                                                        OR what's hostname of 128.175.13.74- it replies strauss.udel.edu
                                                                        @Phone book- to make a phone call, we look up the name.
                                                                    Why?
                                                                        You may purchase domain name from say godaddy.com and hosting account from say hostGator- we need to connect them.
                                                                        We write names (called domain name) that are easy to remember
                                                                            URI- We never write IP addresses in browser.
                                                                        Little extra time for translation but worth it.
                                                                            @In mobile phone, we remember phone numbers from names mapping, and not numbers.
                                                                            REL google.com vs 152.52.2.11
                                                                    How? Uses both UDP (for local) and TCP (for global) connections
                                                                        3 components
                                                                            Namespace- specifications for a structured name space and data associated with the names.
                                                                                root
                                                                                    net
                                                                                    org- organization
                                                                                    edu- educational website
                                                                                    com- commercial website
                                                                                        Domains- facebook
                                                                                        ...
                                                                                            engineering
                                                                                            ...
                                                                            Name Server- Server Program that hold information about structure and names.
                                                                            Resolvers- Client programs that extract information from Name Servers.
                                                                                map name to an address 
                                                                                queries name servers and gets back response.
                                                                                Iterative
                                                                                    The resolver tries out all the Name servers in hierarchy itself and no delegation.
                                                                                        Govt office- you have to do eth yourself.
                                                                                Recursive
                                                                                    the servers take responsibilities to find out the answers.
                                                                        Process- http://www.slashroot.in/difference-between-iterative-and-recursive-dns-query
                                                                            Browser/OS tries to find on system cache memory, if found (path) return.
                                                                            Send the query to Resolver Server (aka Local Name Server) thru recursion
                                                                                How
                                                                                    we have given settings at time of network connections- default DNS and port No as 80.
                                                                                    If not given, it goes to ISP by default.
                                                                            LNS sends iterative request to Root Name Server.
                                                                                    DNS is a server in LAN which keeps a DB to return IP address to us. Found? Return to PC. If not found goes to higher domains.
                                                                                    looked up into DB for match- Name, value, Type, TTL
                                                                                        meaning- domain name, Corresponding IP value
                                                                                        Type- A means take literally, cname (canonical name) means- check out the server in geographical proximity (win-win) 
                                                                                            IP,MX meaning mails.
                                                                                        TTL what it be valid in DNS.
                                                                            Root Name server- iterative servers which check out the DB and return list of IPs responsible for handling the domain (.ca)
                                                                                @Security asked for a startup task- directed to director who informs who looks the dept- Dean which tells specific contact person.
                                                                                14 in world. Guides search to apt name server like .ca
                                                                                RNS asks corresponding com/ org/ net/ etc servers for response for Domain name
                                                                                    The Nameserver .ca searches and tells whom to contact for IP.
                                                                                    they may further check with some servers to get the IP.
                                                                            LNS Send iterative request to TLD (Top Level Domain) Servers (.edu) which return a list of IP addresses of the DNS server's responsible for the domain (authoritative name server for the domain) www.example.com.
                                                                                this can be thru intermediate server (dns.umass.edu) to authorized Name Servers (dns.cs.umass.edu) which resolves gaia.cs.umass.edu
                                                                            our DNS server will select one of the IP from the given list of authoritative name servers, and queries the A record for www.example.com which ANS returns.
                                                                                The result is cached in local server to avoid next time travel time (TTL field along)
                                                            </DNSServer>
                                                            Proxy Server- If there is bottleneck in network edge say only 40 Mbps.
                                                                    Then it is a good idea to keep a copy of some of the web pages (can be frequent) with a server which can be quickly delivered to you without going to server at all.
                                                                    if not found, then accept the time taking response from server.
                                                                    Someone keeps track of proxy servers- which time which all sites were accessed by a particular user.
                                                                    When a data comes- it is notified to proxy server which can maintain a copy.
                                                                            buffer size if limited to some algorithm required for replacement when necessary (LRU,LFU).
                                                                            can update itself like sensex,news require frequent updates in mins.
                                                    </HTTP>
                                                    <SMTP>
                                                    SMTP - Email
                                                            Push protocols- When I send a mail- I may use html page; 
                                                                Message is sent to server thru SMTP protocol is pushed into destination server from sender server.
                                                                http to put it on web mail (mail is never transferred to client machine), request is composed on server and 4
                                                                SMTP to transmit between servers to reach server of you pal.
                                                            Pull Protocol- Pop3 or http used to download the messages when user desires.
                                                                Pop3- irregular sync
                                                                IMAP- regular sync
                                                                can use http to connect to server- email composed on server (not PC)- http just sends- email not stored on client machine.
                                                            Pictures laid in text using SMTP- how does that work?
                                                                Boundary No is used as tag b4 any mime type. (type of data sent) is informed to be mixed at top and aptly later parts.
                                                            Mime Types
                                                    </SMTP>
                                                    <FTP>
                                                    FTP-file transfer
                                                        Filezilla instead of browser- copies files from your flash drive to servers.
                                                            keep in password protected.
                                                            Browser can access what you placed on server thru filezilla!
                                                    Telnet- remote terminal access
                                                    Streaming Multimedia,internet telephony-Proprietory (eg- Real N/ws and Vocaltec resp)
                                                    NSF- Remote file server.
                                                    </FTP>
                                                    <SSH>
                                                            winscp- sandbox cred to transfer files- version- 
                                                            Moba- ssh connection 
                                                                    22 shows every change but 2222 to access services (for HDP2.5- docker)
                                                                    passwordless in ssh
                                                                            ssh-keygen -t rsa
                                                                            ssh sheena@192.168.0.11 mkdir -p .ssh
                                                                            cat .ssh/id_rsa.pub | ssh sheena@192.168.0.11 'cat >> .ssh/authorized_keys'
                                                                            //ssh sheena@192.168.0.11 "chmod 700 .ssh; chmod 640 .ssh/authorized_keys"
                                                                            ssh sheena@192.168.0.11
                                                                            confirmed using git command shell
                                                                    moba allows key generation and nested ssh in 1 shot.
                                                                    Configuring moba for passwordless connect
                                                                        SSH- get hostname no username, no password
                                                                                advanced ssh settings- use private key- select the .ppk private key file.
                                                                                network settings- proxy settings- proxy type- http and ip/port = ip:port
                                                                                ssh hadoop@aws_domain_name -i /path/to/key.pem
                                                                        SCP- for aws connection- s3 is just a machine (file system)
                                                                                advanced authentication- private key file
                                                                                proxy
                                                            getting ssh server installed thru VM
                                                                    sudo apt-get update
                                                                    sudo apt-get install -y openssh-server
                                                                    device > (virtualbox insert guest additions cd image) allow installation 
                                                                    bridged adapter mode
                                                            Password is asked irrespective whether user exists or not for ssh and do remember to stop process b4 exit.
                                                            for linux to windows-
                                                                prefer winscp, ssh/scp server is to be looked into.
                                                                install open ssh in windows using cygwin and you can use scp to copy to linux- didn't work
                                                                installed freeSSHd and it opened ssh port 22 but linux shell ssh request- asks credentials and denies permission.
                                                                For now, internet exchange is only option if winscp defies.
                                                    </SSH>
                                                    <ProxyServer>
                                                        For faster response, monitoring (check by firewall mainly)
                                                        Using Proxy Server for apps	
                                                        GIT- 
                                                                git config --global http.proxy http://proxyuser:proxypwd@ip:port
                                                                git config --global --unset http.proxy
                                                                git config --global --get http.proxy
                                                        yum install proxy
                                                                add to /etc/yum.conf
                                                                # The proxy server - proxy server:port number
                                                                proxy=http://ip:port
                                                                # The account details for yum connections
                                                                proxy_username=yum-user
                                                                proxy_password=qwerty
                                                        pip install proxy
                                                                sudo pip --proxy http://proxyuser:proxypwd@ip:port install somepackage
                                                                OR export https_proxy=http://proxyuser:proxypwd@ip:port
                                                                        sudo -E pip install somepackage
                                                                                                                    Proxy configuration script just writes which ip to use in its pac file
                                                    </ProxyServer>
                                            </VIZ>
                                    </ClientServerArchitecture>
                                    <PeerToPeer>
                                        New video circulaation- original website slow- fans trying to download
                                            overwork from single stream in case of server-client.
                                            download via bit torrent (like browser)- like need web pages- need torrent files to work.
                                            downloaded torrent file and used utorrent.
                                                all downloaders become source. Provide pieces to each other- it becomes a network of file components.
                                                torrent file contains all parts needed to complete the file and uses A special computer called tracker that keeps track of downloaders called peers.
                                                that way more downloaders means more sources and faster.
                                        How to use Torrents
                                            get torrent downloading app- utorrent.com, filehippo.com/bitcomet
                                            search torrent file for the app- torrentz.com, thepiratebay.org, etc (even google search)
                                                    use tor browser, or proxy site or proxy site in tor browser.
                                                    search- use torrentreactor,etc
                                            launch the file or it gets launched (open in the app)
                                    </PeerToPeer>
                            </InterProcessCommunication>
                            @Communication between 2 brains on CN,Maths,etc.
                            <MessageSending>
                            Message is anything at application level- like file to send- text, program, etc. they are huge
                                    Sending whole message may block the channel so we divide message into smaller parts (segments in Transport Layer).
                                    Demands for applications may demand different requirement
                                            For Voice,live video telecast, Real Time > Reliability (timely reception)
                                                    Our protocol will use UDP protocol(transport Layer) which is fast not handshaking,no retransmission and not reliable.
                                                    We tell socket to go for UDP protocol when sending data.
                                            For Banking,Email- Reliability > Real Time. (better slow than wrong).
                                                    TCP protocol of Transport Layer is slow but reliable- we will choose that in socket.
                                    Types of message sending - based on number of receivers
                                            Unicast- 1 sender, 1 receiver.
                                            BroadCast- 1 to all.
                                                    sent to all at once- not necessarily received at once.
                                                    Something like broadcast ping/eMail- Not that all message signals but sent at once. Even that is multicast. Because logical group is distributed across networks.
                                                    This has died down.
                                            Multicast- 
                                                    1 to many.
                                                    Widely used. Some members of the network receive and send signal.
                                                    Eg- Teleconferencing, 5 people on tata-sky watching movie- not all.
                                     Types of message sending
                            </MessageSending>
                    </ApplicationLayer>
                    <PresentationLayer>
                        Conversion or transformation layer- when 1 PC to another- we send bit stream with fluctuation of sth (light, electric)
                            interpret it as text, color, movie, sound? What next data bit stream is going to be (for interpretation)
                            Coding/ encoding
                            Eg- ASCII- we looking at text of this type- interpret as characters.
                                EBCDIC- text andnumbers
                                JPEG,GIF,TIFF- pictures
                                MPEG- movies
                            It's very close to application- AL uses it.
                                Thus have a lot of data stream to go out and will be sorted out there.
                        Encryption/ compression  (decompression) of data message; to translate data.
                    </PresentationLayer>
                    <SessionLayer>
                        App has thrown bit stream along with its types.
                        Handles the session- when to start/ establish, resume/ manage/ handshake, end/ terminate transmission.
                            Protocols- not very famous.
                                RPC- Remote Procedure Call
                                ZIP - Zone Information Protocol
                                SCP- Session Control Protocol
                            How communication is going to take place- messages from AL is not yet sent.
                                2 PC have to know that they can communicate and send message.
                                how fast can you exchange info? 2Mbps- can you do the same- I can do that- go ahead- decide on speed.
                                I will send these many pkts at a time and wait for reply.
                                doesn't control delivery- other layers do that.
                        session layers remember session information going on- dialogues mgmt,etc. but MUXing to segments is done by TL.
                        Billings happen here.
                    </SessionLayer>
                    <TransportLayer>
                            How 2 processes communicate with each other.
                                responsible for delivery of a segment (message portion) from one process to another
                                Reliable process to process message delivery and error recovery.
                                S/w for this layer is written in OS.
                                Message is broken into segments for checking order and checksum.
                            <ServiceExpectedByApps>
                            What transport services do apps need?
                                    Data loss
                                            some apps (e.g., audio) can tolerate some loss
                                            other apps (e.g., file transfer, telnet) require 100% reliable data transfer
                                    Timing
                                            some apps (e.g., Internet telephony, interactive games) require low delay to be “effective”
                                    Bandwidth
                                            some apps (e.g., multimedia) require minimum amount of bandwidth to be “effective”
                                            other apps (“elastic apps”) make use of whatever bandwidth they get 
                            </ServiceExpectedByApps>
                            While 3 sessions are going on- for chat,browsing and email, My browser has to keep track of 3 applications separately.
                                    @While talking with some a subject- I have to keep track of both person and subject mapping for transport to be perfect.
                                    All 3 sessions are managed by TL- by bundling/ MUXing segments/pkts? together to form segments.
                                    works only on end systems. Data transfer betw end processes (& not end PC's- that's Network Layer).
                                    Ensures reliable and orderly data transfer although medium of data transfer is unreliable.
                                    2 problems- 1. data never reaches- then wait for some time expecting Acknowledgement and declare time out and send again
                                            2. Corrupted data arrives at that end. Many ppl fit some func into DLL so that prob id earlier instead of reaching far off destination.
                            Host computer process is uniquely Identified by- IP address(service from Network Layer) and port No(unique for every process (browser Tab) 
                                    2 OS happen to generate same port No of client process for communicate- no problem for server to distinguish.
                                            - but IPs different. 
                                            If same IP then OS so designed to make sure that same port_no never happens.
                                                    16 bits for port no- 65536 connections- so many processes client never opens- 15 is exaggeration.
                                                            0-1023- Reserved
                                                            1024-49151-  client can use. Server can also use these ports (generally 1 suffice). portnetting if more.
                                    So Name:subject::IP:Port_No.
                                    Port No
                                            created (assigned by our OS for client side)).
                                            Port No for server applications is standardized
                                                    HTTP-80
                                                    SMTP-25
                                                    Telnet-22,23 or so.
                                            Server maintains a DB for communication. IP to reach PC and port No to reach process.
                            <Types>
                                    <TCP>
                                            aka Connection Oriented
                                            3 way handshake
                                                wanna connect
                                                Sure!
                                                Alright then
                                            Eg- Text communication, retransmission = if sth missed out- file transfer, remote access.
                                            slow but reliable,handshake,retransmission
                                            worries flow control, congestion control.
                                            Eg- Offline multimedia download,Banking transaction- penalty of 1 wrong digit
                                            TCP service:
                                                    connection-oriented: setup required between client, server
                                                    reliable transport between sending and receiving process
                                                    flow control: sender won’t overwhelm receiver 
                                                    congestion control: throttle sender when network overloaded
                                                    does not providing: delay & minimum bandwidth guarantee
                                            Disad
                                                bigger overhead; larger header; not sent immediately.
                                            <WhyInternetSurvives>
                                                How internet is surviving
                                                Any change TCP is thoroughly discussed/researched for decades b4 implementation
                                                whole world complies to it.
                                                @home is not built everyday. once, it is built it is not devastated in a day.
                                                What a model- no denial of service unlike Telecom and no centralized authority.
                                                What if I change my TCP in OS- server will deny the service(format expected) and you can't.
                                                1 having better algo for congestion control gets better service?
                                                        such trade-offs are already considered b4 proposition.
                                                        1 reduces to half and not 1 but grows linearly other exponentially growth but drops to 1.
                                                                these are for situations specific.
                                                                thus, TCP is fair to all (not biased)
                                                TCP has these rules not other protocols- well, universally acceptable.
                                                same goes with supreme court judgments,genuine politics- they need to think of repercussions of a decisions over decades.
                                                TCP congestion works for itself- UDP,etc don't suffer!!
                                                        TCP is good because every app conforms to this TCP.
                                                                yea, but internet in the hands of rules setter 
                                                                they consider all trade-offs b4 proposing other protocols and if they need changes.
                                            </WhyInternetSurvives>
                                            <FlowControl>
                                                TL guarantees end to end transmission of message
                                                All throughout we use word packets for simplicity- but it factually is segments- segments in sliding window.
                                                <TimeEfficiencyAnalysis>
                                                    Extra packets are destroyed.
                                                    send 1 packet- Acknowledge 1 packet- send another packet and so on.
                                                    Why ACK? cuz many packets drop in the way or get delayed etc.
                                                    Draw on time line to study time taken (vertical time and Sender-Receiver either side)
                                                    Tt (last one on channel) + Tp (last one reached) + Tq + Tproc + Tack + Tp 
                                                        Tp same in both case- for 1 packet to pass thru channel time is same.
                                                        Tack is small and st we piggyback Tack on Tt from receiver.
                                                    Round Trip Time (RTT) = 2Tp
                                                </TimeEfficiencyAnalysis>
                                                <CapacityOfChannel>
                                                    or wire and link
                                                    FullDuplex- data can flow in both direction simultaneously without collision
                                                    Capacity- no of bits (max) a channel is carrying at any given time
                                                        As per band width we can keep throwing bits on channel.
                                                        the bits will flow and will remain in channel for Tp duration.
                                                        No of bits will depend on the size of channel (or time on the channel or Tp)
                                                        In 1 sec, I can put BW bits on channel, I have Tp time until a packet will remain within channel- by that time I would have thrown,
                                                            BW * Tp bits on channel.
                                                            For duplex, 2*BW*Tp
                                                </CapacityOfChannel>
                                                <StopAndWait>
                                                    Data sent, 
                                                        Data pkt lost- causes Deadlock problem
                                                            No acknowledgement
                                                            Deadlock- both processes waiting from other process.
                                                            wait Time out Timer (TO Timer), send again (ARQ- automatic repeat request)
                                                            @You are your friend have misunderstanding- no1 saying sorry- wait for st and you call her.
                                                        ACK pkt lost- causes Duplicate Packet Problem
                                                            No ACK!
                                                            TO Timer, send again. Duplicate- reject 1 pkt but how to distinguish packets?
                                                                Duplicate packet problem
                                                                Sequence Numbers added to the packets
                                                        Delayed ACK - causes missing packet problem
                                                            maybe mistaken with acknowledgement to current data packet- which might have been lost
                                                            Sender will imagine it is received and next pkt sent
                                                            Solution- Acknowledge the packets received- D1 received, send A2 (I expect D2 next)
                                                                so when delayed ACK comes- reject it. Latest A2 has already been consumed.
                                                        Eg- 10 packets to send every 4th packet lost
                                                            1234 4567 78910 10 = 13 times
                                                        Eg- Error property is 0.2 (20 packet lost out of 100). If 400 packets to send how many to be sent?
                                                            400 packets but 80 lost. So resend 80 but outta them 16 are lost. so on
                                                            400 + 400.(0.2) + 400.(0.2)^2 + ... = 400 .1/(1-p) = 500
                                                    Total Time = Tt + 2Tp (but useful time is only Tt when actual data is thrown)
                                                        Efficiency = useful/total = Tt/ (Tt+2Tp) = 1 / (1+2a) where a = Tp/Tt
                                                            Also, Eff = 1/(1+(2*d*B)/(v*L))
                                                            velocity and bandwidth are properties of medium- can't change
                                                            Distance increases, eff decreases (better for LAN but not WAN)
                                                            Length inc, eff inc (bigger packets inc Tt time)
                                                                Effective Bandwidth = Throughput = Bus utilization (bits delivered/sec) = L /(Tt + 2Tp) 
                                                                    = Tt * B / (Tt+2Tp) = 1/(1+2a) * B = Efficiency * Bandwidth
                                                            Eg- Tt = 1ms and Tp = 1ms so Efficiency = 1 / 1+2 = 1/3
                                                            Eg- Eff = 1/2 then 1/(1+2a) = 1/2 so 1+2a = 2 means a = 1/2.
                                                                Also, Tp/Tt >= 1/2 or Tt >= 2 Tp or L/B >= 2 Tp => L >= 2Tp.B
                                                    Disadvantage- The channel capacity is grossly wasted- 1 pkt bits goes when BW*Tp could.
                                                        Thick pipe (huge capacity) wasted.
                                                    Solution- Pipelining.
                                                </StopAndWait>
                                                <SlidingWindowProtocol>
                                                    Tt sec- I send 1 pkt
                                                    1 sec- 1/Tt packets
                                                    Tt+2Tp sec- (Tt+2Tp)/Tt = 1+2a packets.
                                                    That's why, Eff = 1/(1+2a)
                                                    To increase efficiency we have to increase number of packets.
                                                    Tp is completely wasted!
                                                    While Tp, sender can send window of packets and ACK keep coming.
                                                    Eg- 1ms Tt and 3ms 2Tp, then transmit 3 more packets by the time ACK for first comes.
                                                        Window is buffer to hold the packets.
                                                        save packet 0 until its ACK comes to retransmit if data pkt lost
                                                        window size is packet preserved- keep removing packets and so on.
                                                        free it up after ACK- 1 by 1- keep removing/ adding more packets in queue- so sliding window.
                                                        Keep window dize = 1+2a to increase efficiency.
                                                    Numbering of segments- if after packet 0 is ACK, I can put Ws+1 packet but don't need 0 again- so can number it 0 again (thus reducing numbering)
                                                        so no of bits reqd to use those numbers- 0-3 means only 2 bits. reducing overhead of TCP header.
                                                        Ws = 1+2a and min seq = 1+2a (why? if ACK is delayed then it will mess up)
                                                        bits reqd = lg(1+2a)
                                                    Eg- Tt = 1ms and Tp = 49.5 so Ws = (1+2a) = 100
                                                        Seq number = 100, #bits = 6.8 = 7
                                                        if bit field has only 6 bits, then only 64 seq numbers then can't send 0 (cuz ACK not arrived) so limited.
                                                        So, Eff = 64/100 = 0.64
                                                    Ws = min(1+2a, 2^p)
                                                    Theoretical Concept based on pipelining- Practically implemented in 2 ways.
                                                        <GoBackN>
                                                            N=1, means stop and wait.
                                                            GB10, standard window size = 10.
                                                            Tt = 1ms, Tp = 49.5ms
                                                            W=1+2a = 100; N = 10 packets decided
                                                            so eff = N/W = 10%
                                                            Receiver window size = 1, if pkt 2 is lost pkt 3,4,5 are also rejected.
                                                                also all transmitted latter, would have been rejected.
                                                                From wherever lost- go back to start of window.
                                                                Go back N is from the point of last transmission.
                                                            In GB3, if every 5th pkt lost then #transmission?
                                                                retransmissions are high here.
                                                                1234,5;6756,7;8978,9;A9A- here we sent 18 packets
                                                            Eg- GB4, 6th pkt lost- to send 10 pkts
                                                                12345,6;78967,8;9A89A = 17
                                                            Cumulative ACK
                                                                for every pkt, ACK independent is consumption of channel
                                                                less traffic in cumulative
                                                                1 ACK lost means all pkts are lost (less reliable)
                                                                Difficulty is #pkts not divisible by N of GBN- then receiver may keep waiting.
                                                                    Solution is Time out for ACK also- if no ACK in that time- send ACK cumulative.
                                                                    too big ACK, then 1 for many pkt but time out on other side
                                                                    too less ACK, ack for every pkt. To (sender) > Tack (receiver)
                                                            Relp of window size and Sequence numbers GB4
                                                                sent 0 1 2 3 and receiver waiting for 0.
                                                                If their cumulative ACK are lost, sender resends them all after time out- thinking data pkt lost.
                                                                but receiver thinks that this is next set of 012 etc- which is wrong.
                                                                Solution- Increase no of sequence numbers.
                                                                    after they are lost, receiver gets next inorder 5 but what's sent is 0. discarded!
                                                                    and appeal for pkt no 5, get 0 (reject it)
                                                                    We need (N+1) seq numbers reqd to detect duplicate packets.
                                                                        bits reqd = lg(N+1)
                                                                        To have seq of N, Ws = N-1 and Wr = 1
                                                                    Ws + Wr <= ASN (available seq numbers)
                                                                    if k bits, then seq = 2^k. so Ws = 2^k-1 and Wr = 1.
                                                            Discarding Silently
                                                                Any out of order packet is silently discarded b4 it gets its time out after To at sender.    
                                                                Corrupted packet is also discarded silently
                                                        </GoBackN>
                                                        <SelectiveRepeat>
                                                            Tt = 1ms, Tp = 49.5ms and Ws = 50 then eff?
                                                                Max = 1+2a = 1+2.(49.5) = 100
                                                                Eff = 50/100 = 1/2
                                                                Throuput= eff * BW = 1/2 * 4 = 2Mbps
                                                            Wr = Ws
                                                                receiver also waits for those packets
                                                                Advantage- out of order packets are not rejected, even if lost, others are not rejected.
                                                                    only missing pkt is resent after time out- so called selective repeat.
                                                                very few retransmissions.
                                                                    Eg- 10 pkts to send; every 5th pkt lost, Ws = 3
                                                                        1234,56758,9A9 = 12 pkts. (18 for GBN)
                                                                    Eg- if every 4th
                                                                        12344567789AA = 13 pkts sent
                                                            Acknowledgements are independent
                                                                For pkt discard at receiver, A NAK (negative ack) is sent (unlike others)
                                                                thus, sender doesn't have to wait till timeout b4 sending again (time saved)

                                                        </SelectiveRepeat>
                                                        <Compare>
                                                                        SNW         GBN         SR
                                                            Efficiency- 1/(1+2a)    N/(1+2a)    N/(1+2a)
                                                            Buffers-    1 + 1       N + 1       N + N
                                                                not good memory prefer GBN
                                                            Seq NO-     1 + 1       N + 1       N + N
                                                            Resend      1           N           1
                                                            BW          Low         High(retr)  Moderate
                                                            CPU         Low         Moderate    High
                                                            Impl        LOw         Moderate    Complex
                                                                SR gets reordered out of order packets and other things- so sorting reqd; duplicate removal.
                                                                GBN never gets out of order pkts- it rejects. no search or sorting.
                                                                Depending on situ, we prefer GBN and SR.
                                                                    Eg- High BW and low CPU, Buffers low- prefer GBN.
                                                                    Eg- low BW, High CPU, high buffers- prefer SR.
                                                                    Eg- say hearing video on airtel- mobile connect to base station and base stn to routers to Youtube server.
                                                                        inside wires, high BW but error rate low (no bits corruption); out of order not posible; CPU- routers busy for routing packets so not available.
                                                                        GBN in such scenario- error is less so retransmissions will be less. 
                                                                    Eg- In wireless, the error rate is high and BW is low- if GBN then many retransmissions, out of order possible and CPU available.
                                                                        So End to End (Transport layer) will use SR protocol.
                                                                        But link to link (DLL Layer) we will prefer GBN.
                                                                        Both are used in CN.
                                                                    Every process has its own buffer to not intermix. all have their own packets.
                                                                        these packets go to next router following GBN.
                                                                        TCP uses 75% SR and 25% GBN.

                                                        </Compare>
                                                </SlidingWindowProtocol>
                                            </FlowControl>
                                    </TCP>
                                    <UDP>
                                            aka Connectionless
                                            fast not handshaking,no retransmission and not reliable
                                            Eg- Multimedia- lately started TCP.
                                                UDP- some packet loss is ok.
                                            1985 after multimedia,VOIP came.
                                            Eg- Online Cricket
                                            UDP service:
                                                unreliable data transfer between sending and receiving process
                                                does not provide: connection setup, reliability, flow control, congestion control, timing, or bandwidth guarantee 
                                                Smaller packet size.
                                                More control over data sent.
                                                No error recovery- only warns corrupted segments.
                                                Gone is gone. Order out of- okay.
                                                No congestion control.
                                    </UDP>
                            </Types>
                            <PortIsOpenCheck>
                            check if a port is open on remote system
                                open telnet- control panel/program/programs and features/turn windows features on or off- telnet client.
                                telnet ip port, nmap, etc also useful- ssh clients- telnet, putty, moba, ssh
                                    To exit telnet connection- use ctrl + ], then from telnet shell, use quit
                                sudo yum install nmap, nmap -A 192.168.1.26 -p 8086 (roughly takes over a minute), nc -z host.example.com 20-30
                                netstat -ntlp | grep LISTEN, nmap -A localhost -p 3306, check for filtered status when windows firewall has blocked a port.
                                More- Check if port is open
                                        netstat -tuplen
                                        telnet
                                                activate telnet client- control panel/program/programs and features/turn windows features on or off- telnet client.
                                                os cmd shell- telnet ip port (blank screen it gets means port's listening)
                                                        opens a client port which contacts remote host on specified port for answering.
                            </PortIsOpenCheck>
                    </TransportLayer>
                    <NetworkLayer>
                        How Computer communicate with each other- Communication between computers (not processes)
                            iow, responsible for the delivery of individual packete from source host (PC) to the destination host using IP address (internetworking)
                            (identify a unique computer and send data)
                            protocol to ensure end to end transmission of computers.
                        Router has 3 layers- physical, DLL, NL. So it communicates at the level of communication between 2 PC and helping that process.
                            @works like a converyer belt to serialize all packets to be sent.
                            ICMP
                                For debugging the network
                                divided into 2 broad categories
                                        error reporting messages- report probs that a router or destination may encounter when it processes an IP packet.
                                        query messages- occur in pairs, help a host or network mgr get specific info from router or another host.
                                Error reporting/ correcting in IP
                                        TTL = 0 or router not found?
                                        There are a set of error messages that router could encounter.
                                                Destination unreachable!
                                                Source Quench- IP has no flow control mechanism- source quench message to source- "keep send at a slower rate"
                                                TTL- if loop in routers or hops count exhausted. TTL decrements to 0.
                                                        ICMP responds to source.
                                                Time Exceded- if not all frames reached the node.
                                                        inform source- time exceded.
                                                Code = 0 (TTL =0) and Code = 1 (by destination host to show that not all of the fragments have arrived within a set time)
                                                Parameter Problem- 
                                                Redirection Concept- Router says you better go thru R2 but for now I am forwarding. Routing table is thus updated.

                                        Format
                                                Type, Code, Checksum
                                                rest of header
                                                data
                                        response sent to sender.
                        Discern PC on internet
                            IP Identifier- identify deivices connected to Internet (using 32 bit address to uniquely and universally address each device- unique address)
                                => 2^32 computers possible (big number but IPv6 cuz falling short)
                                Representations
                                    Dotted Decimal Notation- Human readable- 128.11.3.31 = 10000000.00001011.....
                                        !Eg- 171.56.06.78 ; 1.2.3.4.5; 75.45.301.14 ; 11001101.12.12.41
                            Internet is so arranged that it is a network of networks- where each network has hosts in there (NetId, HostId)
                                NetId to search Network, Host Id to search PC in the network
                                @022 STD code for Mumbai so accordingly.
                        <Ravula>
                            URI Address- 1. Network Identification (Network Part of IP) 2. Host Identification (host part/ private networking), 3. Process on the Host Identification (Transport Layer)
                                Domain name (easy to remember) converted (overhead) to IP Id (represented in hexademial, binary, 4 octets dotted representation) by ISP given Domain Name Server (DNS)
                                go to caliphornia, connect to the process there to get the requested web page.
                                IP is unique Id for a PC/ host.
                                IANA controlling authority of IP addresses.
                            Classes
                                I select 1 bit- I divide a range in 2 parts- for 0 and for 1. 2bits- 4 parts, so on.
                                    k bits, then 2^k parts- each of size 2^(n-k)
                                    2 IPs are reserved in all classes- for host and broadcast- so #IP - 2 = #Hosts
                                Class A- 0......- 2^31 IPs (0.0.0.1 to 126.255.255.255)- 2^7 Networks, each of size 2^24 (1crore 70 lacs) (eg- Big Organizations like NASA, Pentagon)
                                    Unicast to class A- destination address = IP of class A.
                                    Internal/ Limited Network Broadcast- to every IP (PC will go crazy)- destination address = 255.255.255.255 and throw that packet in network.
                                    External/ Directed Network Broadcast- destination address = 11.1.2.3 to 20.255.255.255 (to all 20.0.0.0 network)
                                        (Network part and Host part- set to 255.255...)
                                Class B- 10.....- 2^30 IPs (128 to 191)- 2^14 Networks, each of size 2^16 (65,000 PC) (eg- Banks, IRCTC)
                                    Intra broadcast- 
                                Class C- 110....- 2^29 Ips- 2^21 Networks, each of size 2^8 (256) (Eg- small orgs like offices, colleges)
                                    Subnet Mask- 255.255.255.0 (by default)- ANDing to get start/network address of network.
                                Class D- 1110...- 2^28 IPs- Used for multicasting like 256M groups but even today- but less than 1000 groups. Disadvantageous.
                                Class E- 1111...- 2^28 IPs- not revealed- special purposes they say- reserved, for military purposes. 
                            Subnetting- A big Network should be divided for departments
                                Advantage                                
                                        Security to departments (development, testing, maintenance, HR)
                                        Maintenance of machine is easy.
                                        1 server common to all!?
                                Disadvatages
                                    4 steps- Id N/w, id Subnet, id Host, id process (port)
                                        Network Id- set all host part of IP to 0's.
                                        broadcast- set all host part of IP to 1's.
                                Eg- Class C- 200.1.2.0-200.1.2.255 reserved- so 254 PC can be divided.
                                    choose 1st bit for subnetting (sid)- divide whole network in 2 parts- .0..... and .1.....
                                    range- 200.1.2.0-127 and 200.1.2.128-255 (network id and broadcast- first and last addresses)
                                    So, 200.1.2.0 and 200.1.2.255 was reserved IP for network- outsiders view them as so- for insiders they are subnet IPs.
                                        External router for network selection and internal router for subnetting
                                        internal router- sees packet coming from outside asking broadcast then whole network but from inside- then specific subnet.
                                        There is also a loss of IP address cuz of subnetting- (-2) per subnet.
                                    Eg- Dividing into 4 parts- choose 4 parts.
                                        logical view- pie chart- with IP range relative size.
                                        Physical view- internal networks, internal router, external router, interfaces (a,b,c,d,e)
                                            how to identify interface- a host belongs to- given an IP!
                                                so we use subnet mask (or network mask)- (we can see and tell but PC needs a mechanism)
                                                    a number- which represents NID and SID part by 1's streak and HID by 0's.
                                                    Eg- Subnet is 255.255.255.0 before but after subnetting- 255.255.255.192 (11000000)
                                                ANDing of IP address with Subnet Mask to obtain the interface (network ID of network to go)
                                                The internal router- has a routing table- to find the interface to forward to.
                                                    Match network id with the list- where it matches- forward to interface.
                                                    0.0.0.0 default entry- send it outside.
                                                subnet mask for network will be same for equal size subnetworks.
                                VLSM (variable length subnet masking)
                                    I want 3 parts- 128,64, 64 (say) => at least 2 bits reqd.
                                    Eg- 200.1.2.0 (IPs are there)- 8 bits in HID part- 2 bits taken out.
                                        0 bit reserved for 1 subnet and 10 and 11 for others.
                                            Network Id- first address and broadcast address- last address
                                            So, 200.1.2.0-127 and 200.1.2.128-191 and 200.1.2.192-255.
                                            Subnet- 255.255.255.128 (1 bit chosen for first) and for others- 255.255.255.192 (2 bits chosen for others)
                                        could have chosen as 00,01 and 1 also.
                                        Router table-
                                            NID             SM              Interface
                                            200.1.2.0       255.255.255.128     a
                                            200.1.2.128     255.255.255.192     b
                                            200.1.2.192     255.255.255.192     c
                                            0.0.0.0         0.0.0.0             d
                                            Eg- 200.1.2.135- ANDed with all of SM- check where we get NID equal- to that interface we need to redirect.
                                            when 2 matches- longest 1 gets precedence
                                        #SID bits = 32 - #HID bits - #NID bits
                                            we can even choose any random bits for subnetting but don't
                                            If lsb for SID but IP distribution will be ugly- even numbers in 1 network and odd numbers in other (not in range)
                                Remember- 0, 128, 192, 224, 240, 248, 252, 254, 255.
                                Draw a pie chart of IPs
                                CIDR- Classless Inter Domain Routing
                                    Need- If small network you need- then, 2^8 minimum- 256 but I need 100?
                                        @cake piece is cut- you have to take full even if you don't want- and others starve.
                                        after 90's classless- any IP address- give exactly the 'block' you need.
                                        Class A and B networks are wasted and Class C fall short (st big also)
                                    No classes- what part is Network Id (or block ID) and what is Host ID?
                                        CIDR Representation- 20.10.50.100/20 - NID part is 20 bits and remaining 12 bits for HID.
                                        Rules for CIDR Block
                                            IP addresses should be contiguous
                                            Block size should be a power of 2. Eg- Not 50 but 64.
                                                why 500 page size in OS? divide by 2- shift operation; multiply also- addressable part reduces from Instruction.
                                                division is simple!- k bits is remainder and msb n-k are quotient
                                                REL divide 1234 by 10- divide digits.
                                                Similarly- finding block No is very easy and offset also.
                                                Now, a customer can have 2^10 hosts, 7 can have 2^4 hosts.
                                            First IP address in block should be evenly divisible by size of the block.
                                                32 Addresses required? then first IP should have 00000 in the last part (1st Network IP)
                                                You will fit in that space- if last part of first IP is not 00000(apt no of zeros)- then it would cross the boundary and move to the other side.
                                            Eg- 100.1.2.32-47 for 16 addresses- all rules satisfied- 00100000. 16 accomodated.
                                                #HID_bits= log 16 base 2 = 4; BID = 32- 4 = 28
                                                thus 100.1.2.32/28 or even 100.1.2.40/28 (entire block is understood)
                                                first address is BID and last address is directed broadcast address.
                                                given an IP- draw it- find HID #bits- put 0's to 1's to get the range.
                                                    given an IP range we can tell its subnet mask.
                                Subnetting in CIDR
                                    Eg- 20.30.40.10/25 into 2 subnets
                                        20.30.40.00001010/25 means 7 bits for HID
                                        20.30.40.0,0... and 20.30.40.0,1...
                                        Subnets are- 20.30.40.0-63/25+1 and 20.30.40.64-127/26
                                    Eg- for 4 subnets should have chosen- 2 bits from HID bits.
                                        20.30.40.0/27 , 20.30.40.32/27 , 20.30.40.64/27 , 20.30.40.96/27
                                        number of hosts of all of them added up get to /25
                                    Eg- VLSM in CIDR- 20.30.40.10/25- ISP get blocks from IANA/ ICANN- using smae principles.
                                        Tata has taken /20- means host id part has 12 bits- 2^12 by them.
                                        IANA list on their websites- who has taken what?
                                    ISP wanted network divided into 2^7 size into 2^6 and 2^5 and 2^5.
                                        20.30.40.00001010 - 20.30.40.0,0.../26 and 20.30.40.0,10../27 and 20.30.40.0,11../27
                                    Eg- 40.30.10.10/20
                                        40.30.0000,1010.00001010
                                        2 parts- 40.30.0000,0... and 40.30.0000,1....
                                ISP gives 4 things
                                    IPv4 address- to identify you.
                                    Default Gateway- default router connected to your network= to get internet access.
                                    Subnet Mask- Subnet mask you should use.
                                    DNS- Domain name to IP address conversion.
                                    1st gotta know within network or outside- send accordingly.
                                        every host also has a subnet mask.
                                        A to B packet to be sent
                                        A: Ia (address of A) and Subnet A (Sa). A comes to know IP of B (thru DNS or someway)
                                            Ia AND Sa = NID of A according to A.
                                            Ib AND Sa = NID Of B according to A (belongs to my network or not)
                                            if NID of A as per A = that of B- then no need of default gateway- else send to gateway.
                                        Eg- Ia = 200.1.2.10 and 255.255.255.128 and 200.1.2.130
                                            maybe CIDR or class C
                                            NID (ba) = 200.1.2.128 and NID (aa) = 200.1.2.0 so send to gateway.
                                            we can give A illusion that B is in different network- how? by giving different subnet to A (to force gateway)
                                                but router will know, of course.
                                        Eg- A: IP- 200.1.2.10 and subnet- 255.255.255.128
                                            B: IP- 200.1.2.69 and subnet- 255.255.255.192
                                            NID (aa) = Ia AND Sa = 200.1.2.0 (on scale of 128- both would round off to 0)
                                            NID (ba) = Ib AND Sa = 200.1.2.0
                                            NID (bb) = Ib AND Sb = 200.1.2.64 (on scale of 192 (4 divisions)- both round off to different)
                                            NID (ab) = Ia and Sb = 200.1.2.0
                                            Acc to A, both are in same N/w and Acc to B, both are in different network (how? perception given by Subnet mask- can be wrong)
                                                Thus, A can send packets to B directly but B has to go thru Gateway (security)- access control risk.
                                    Subnet mask of 255.255.255.255 means you have to contact Gateway- means you will never contact any host directly.
                                    Eg- DBA: 200.1.15.255 Can we know network Id?
                                        11001000.00000001.00001111.11111111- Network Id can have >= 20
                            Supernetting or aggregation
                                smaller network we wanted till now but combining smaller network to big part.
                                Why? Routing table has entry for every network. If many networks, size increases exponentially.
                                Merge all networks and give it a name- it is only a perception.
                                    @US letter to India- the postman won't care to look at the state or city in India- it's India- that's it.
                                    Router R1 says all the networks of this range contact router R2. R2's headache to relay nicely.
                                Rules
                                    All should be contiguous
                                    Size should be same (2^n)
                                    first IP address be divisible by total size of supernet.
                                Eg- 200.1.0.0/24 and 200.1.1.0/24 and 200.1.2.0/24 and 200.1.3.0/24
                                    contiguous. how many? 4 * 2^8 = 2^10
                                    200.1.000000,00.00000000
                                    If router table is as follows:
                                        NID     SM              Interface
                                    200.1.0.0   255.255.255.0   a
                                    200.1.1.0   255.255.255.0   a
                                    200.1.2.0   255.255.255.0   a
                                    200.1.3.0   255.255.255.0   a
                                    Supernet Mask- what's gonna be the variable part.
                                        200.1.00000000.00000000
                                        200.1.00000001.00000000
                                        200.1.00000010.00000000
                                        200.1.00000011.00000000
                                        ...fIXED..;..vARIABLE pART..
                                        255.255.111111,00.00000000
                                        Take anyone IP AND with Supernet mask to get supernet Id.
                                            even in fact, first Id is supernet Id.
                                            2^8 * 4 = 2^10 so 32-10 = network part = 22.
                                    The Router Table becomes
                                        NID     SM              Interface
                                    200.1.0.0   255.255.252.0   a
                                Eg- 200.1.32-47.0/24
                                    No of Hosts = 16 * 2^8 = 2^12
                                    Supernet- 200.1.32.0/20
                                    supernet/ subnet- eth is mask (no name confusion)
                                Eg- 100.1.2.0/25; 100.1.2.128/26; 100.1.2.192/26
                                    They are contiguous, powers of 2 and divisible by total size = 2^7+2^6+2^6 = 2^8
                                    100.1.2.0/24
                                    ?Must check that they are of equal size also for us to merge them
                                        Imagine it was 25%, 50%, 25% could we merge them

                        </Ravula>
                            This layer is written in OS.
                            A Network- System for connecting computers using a single transmission technology/protocol at physical/data link layer.
                                    eg- Wifi- 802.11 b/g/n std or 2G- GSM or 3G- CDMA/CD or 4G-
                                    Internetworking- It is a netork of "a network". It is study to know the principles of "a network" and interconnecting different "a networks"
                                            network of our connection to base station may be "a network" and if it uses lease lines to connect to Backbone router- that is different "a Network".
                                                    the wap of base station which acts as intermediate between the 2 technologies has physical and data link layers corresponding to both technologies
                                                            it accepts the packets in physical layer- pass it onto data link layer and then to data link layer of other technology and uses physical media.
                                                            The "a Network" covers the side of wap which uses the same technology.
                                                    wap acts as a translator in this case. @ 2 people of different languages trying to communicate.	
                            A Network- system of connecting computers using a single transmission technology.
                                    communication network has to be same for communication to be possible.
                                    Back side of our A Network might be using different technology- different A Network.
                                    A Network includes half of router which uses same technology and other half for other side of technology.
                            Computer Networking
                                    Study to know principoles of operations of A Network and interconnecting different a Networks- making it internetworking or internet.
                                    That's how 4G phone can have chat with a 2G guy.
                            Connections btw India and USA hosts- we go thru IIIT B router to local ISP Network( Provider networks may be different) to Regional N/W then National N/W and then to USA NAtional N/w and Regional N/w in New York and then Local and then to his system.- iS THIS PHYSICAL OR NETWORK LAYER?
                            <ARP>
                                ARP AND RARP
                                Address Resolution Protocol AND rEVERSE in NETWORK LAYER
                                IP Address (logical Address) ----ARP-----> MAC Address (physical Address)
                                        Eg- 132.28.36.5 mapped to A2:B5:38:21:00:FF
                                        RARP does opposite.
                                On LAN every device is identified by its MAC address (physical or station address)- imprinted on NIC on host node.
                                        Frame sending use MAC address.
                                Situation- System A wants to know MAC of IP 141.23.56.23- ARP Request- who is this IP? broadcasted.
                                        @If I want to know who John is- I broadcast to class- Who is John?
                                                John Raises his hands.
                                        ARP Response (unicast)- Others don't reply- but 1 with IP will reply with his MAC address.
                                ARP packet looks-
                                        Hardware Type; Protocol Type (ARP code here)1
                                        H/W Length, Protocol Length, Operation Req1,Reply2
                                        Sender H/W Address- 6 bytes for ethernet
                                        Sender Protocol Address- IP Address
                                        Target Hardware Address- ?
                                        Target Protocol Address- Broadcast
                                ARP Response sends back to sender's h/w address
                                Router asks which Router has this IP Address- Router responds with his mac address- you send packets to the router.
                                        router checks the destination address- queries who has dest IP address- host asserts- gets frames.
                                        if router knows it thru cache table already, then forwards it.
                                                Eg-
                                                State	Queue	Attempt		TimeOut		ProtocolAddress(IP)	HardwareAddress	
                                                R	5			900		18.2.4.1		ACAE3243542B
                                                ....
                                                State- R (Resolved), P(Pending- sent but yet to come), F (Failed)
                                                Queue (send to queue no 5 to send it)
                                        If not present in table, then ARP Request- IP in list.
                                                after a certain time- the time out is decremented.

                            </ARP>
                            <NAT>
                                NAT- Network Address Translation
                                    Got 4 IP addresses from ISP (sufficient for our office)-200.24.5.8, etc
                                            1 IP for all machines. Recruited 200 people.
                                    200 machines brought- ISP said all others are assigned. I am ready to pay but can't get contiguous IP address.
                                            eventually we will have IPv6- 128 bits
                                            for now, 200 ppl can have private addresses- Eg- 172.18.3.2 
                                            for inside no worries in communicating but outside world?
                                            for internet, destination address of google.com and source of 200.24.5.8
                                    NAT router makes a list of PC and requests
                                            Eg-
                                            172.1.2.3 asked for 205.1.2.3 
                                            Destination sent packets with sender's IP their own and destination as 200.24.5.8
                                            arrives our NAT router- which check its table of requests- which IP had requested for this IP
                                                    deliver the pkt
                                                    172.1.2.3	64.24.71.2
                                                    172.2.1.2	65.24.2.1
                                                    172.2.1.3	65.24.2.1
                                            But what if 2 PC ask for google.com together?
                                                    change the table- add the private port and external port also in the NAT table
                                                    The packet sent to google server will have port no of private PC's (so NAT table can tell)
                                                    Ports can be same but probability is extremely less.

                            </NAT>
                            <Exploration>
                                <WifiObservations>
                                wifi hotspot
                                        mobile can't have wifi and hotspot simultaneously- so not working
                                        pc using wifi- trying to create hotspot- network > properties > sharing > allow > type of connection you want > ok.
                                                turn on adapter- create a new ad hoc network. connect to that ad hoc network.
                                                using usb connection- official devices allows only 1 connection.
                                        command line
                                                netsh wlan show drivers- check hosted network support yes
                                                netsh wlan set hostednetwork mode=allow ssid=iTech key=password
                                                netsh wlan start hostednetwork- check in network and sharing center- a network connection shows up (take a note)
                                                open properties of internet connection and use sharing tab to allow to use the created connection as hotspot.
                                        todo- creating your own private LAN in office.
                                                3 PC easy star topology
                                        Mobiles need sim connection and wifi hotspot from pc when necessary- besides obvious situ.
                                                Lapy must have wifi connections (2nd best lan) and desktop lan (or wifi)
                                </WifiObservations>
                                Domain name- ssh 172.17.26.91 (you can use domain name but remember to add it in hosts file)
                            </Exploration>
                            Because IP provided basic packet delivery services without guarantees, it is called a best-effort delivery service. It does its best to deliver packets to the destination, but takes no steps to recover packets that are lost or misdirected.
                    </NetworkLayer>
                    <DataLinkLayer>
                            How to share the Transmission medium- many devices coordinate to transmission.
                                takes care of moving frames (message part) hop by hop from 1 node to another using 48 bit MAC address.
                                Devices
                                    cause delay but worth it.
                                    Switch, etc- have 2 layers- so don't know about IPs but do services for hopping and amplification of signal, etc.
                                        Typically connects individual computers (hosts not LANs)- similar to bridges.
                                        Advantage- allows concurrent communication- Eg- in star topology- A can talk to B and C to D simultaneously.
                                        <VLAN>
                                            Virtual LAN
                                                Change in workgroup- Make physical changes to network configuration
                                                virtual connection between 2 stations belonging to 2 different physical LANs? Virtual LAN.
                                                    if 1 person from group 1 wants to send messages to group 3- different floors.
                                                    connect these LANs by switch- configured through software not H/w- flexible.
                                                    several logical LANs- called VLAN (a workgroup in organization)
                                                    Eg- Computers connected to port 1,2,5 of switch are in same workgroup.
                                                        And port 3,4,6 are in workgroup VLAN2.
                                                        If machines on 6 want to join  VLAN3- just add it to VLAN3.
                                                        OR I can use IP addresses to connect machines on VLAN (or mac address)
                                                    Advantage- Cost and time reduction (migration is difficult)
                                                        Create virtual groups- any in number.
                                                        Security- other groups will not receive these messages.

                                        </VLAN>
                                    Bridges- Connect 2 or more LANs at DLL. Looks Destination MAC address and forwards accordingly to interface.
                                        will block the MAC of same network- thus saving collisiions.
                                        As and when a node sends a frame- Bridge records it in which interface the node (with given mac) belongs.
                                            Thus, given any frame, bridge knows where to forward- that frame.
                                            Helps in traffic isolation.
                                        if doesn't know- then forwards to all the links.
                                        Loop Problem- If there is a loop- then a Bridge may mistake a frame to be coming from another interface thus wrong interface.
                                            this keeps toggling.
                                            Solution is minimum spanning tree! Remove other connections.
                                                if a bridge fails then other link can take over.
                            On our system,This layer is managed by NIC (network interface card on our motherboard)
                            Packets are further divided into frames- so as to not jam the network.
                            1 router e1 in hostel tries to use- there must be clashes? who protects - Medium Access Control.
                            Flow control vs congestion control
                                flow control is betw end systems. rate of transmission and arrival/reception mismatch
                                congestion control is on network core/routers- network elements lose packets.
                            Access Control Methods
                            Links of 2 types
                                Point to Point Link- full duplex- send in both directions
                                Broadcast links (or channels) - A connected to many others
                                    many accessing same channel at same time then collisions.
                                    so some strategy to make sure no collision
                                    <Solutions>
                                        <DataTransferTechniques>
                                                <MessageSwitching>
                                                Message Switching- Transfer complete message from hub to hub until destination
                                                        it takes kn time- n for propagation and k for number of routers in middle.
                                                        Why Not all at once- and n time for propagation?
                                                                we can't keep 'communication medium' resource of world booked for us for a length of time- to avoid clash with another data.
                                                </MessageSwitching>
                                                <CircuitSwitching>
                                                    dedicated circuit per call- for continuous flow of data. 
                                                        used in telecom.
                                                        for a conversation a path is selected and no1 disturbs the session.
                                                        For real time systems where delay is not acceptable like Voice,video conferencing, aircraft- circuit switching is the answer.
                                                    Logically Dedicated path but not fulltime, channel is time multiplexed.
                                                        Call set up is reqd here.
                                                        The virtual connection is established which continues for the lifetime of transmission.
                                                        Dedicated band width with respect to the request from source to destination.
                                                        But the channel is not dedicated to 1 request but is time shared/multiplexed with many other requests.
                                                            cuz audio frequency may be lesser than channel frequency- may permit more data to be sent.
                                                            The Copper wiper at the "router" receives signal from 30 senders at a time and 2 units of time for sync between tel and switch and 16th for phone No, caller Id, call divert etc.
                                                                US like always antagonistic to UK keeps 24 channels.
                                                                after every 125 microsecond the signal comes- so, the wiper speed should be such that it will have other end of wiper at the same location after the time.
                                                                    so speed of the wiper =  125 microsecond / 32 = 3.98 microsecond/"pin".
                                                            multiplex them to a faster channel
                                                                after every 3.98 microsecond a new signal arrives for faster channel in the backbone.
                                                                speed of next channel = 32 * 64Kbps or 3.98 microsecond * 8 bits * 32 channels = 2.048 Mbps.
                                                                ???#Google people get addicted- try opening a website thru browser address vs thru google redirect- google is faster
                                                                    they keep a copy and use their own network on top.
                                                    Dividing Links into pieces
                                                        FDM- Frequency Division- different fequency ranges reserved for different users.
                                                        TDM- Time Division- all frequencies reserved for different user for a time slot.
                                                             Eg- 0.6Mb to send from host A to B. 24 slots/ sec. when BW = 1.536 Mbps
                                                             T = 0.64 * 24 / 1.536 = 10.5 s
                                                    Prob- if the channel is vacant- it leads to wastage of resource.
                                                        Soln- Statistical Multiplexing using Packet Switching.
                                                    ?cut-throat switching 
                                                </CircuitSwitching>
                                                <PacketSwitching>
                                                    data sent thru net in discrete "chunks"
                                                    also used at network layer besides Data Link Layer.
                                                    Datagram- different paths, delays maybe different => out of order and no guarrantee of packets to reach.
                                                    Resource wastage is avoided
                                                        Statistical Multiplexing-
                                                            As and when packets arrive, they are sent on the channel.
                                                            Seeing the trends and accordingly- and playing with numbers- filling the gap in transmission.
                                                            Time slot which is not fully filled- like 2410 bytes but 1500 used then remaining used for sth else-scheduler does this.
                                                                address of destination is there- so no worries to find address.
                                                                live commentary of uses this to avoid lag of video= visual + audio.
                                                            REL rail wagon which is half filled (by conveyer belt)! something else is added into it to save the diesel cost/truck.
                                                            @Cocktail Party- Speak when no1 is speaking.
                                                        Resource Pooling- One session can use multiple paths.
                                                            @Cocktail Party- moving from room to room and check vacancy.
                                                            Resourced used as needed.
                                                            Thus, allowing more users to use the network link.
                                                                Eg- 1Mbps link and each user need 100Kbps. every user active 10% time.
                                                                    Ckt switching = 1000/100 = 10 users
                                                                    Pkt switching- 35 users- probability of >= 10 users being active
                                                                        35C10 (0.1)^10.(0.9)^25 + ... = 0.4
                                                                        all get service.
                                                        Good for bursty data- cuz of resource sharing n no call setup.
                                                        Probs
                                                            Resource contention
                                                                resource demand can exceed amound available- queue maintained.
                                                                Congestion.- packet move one hop at a time.
                                                            store and forward switching- entire packet must arrive at router before being transmitted on next link.
                                                    For non-real time apps- like Email we use packet switching over circuit switching as a little delay is acceptable.
                                                        Poorer performance of VOIP or skype have reason in packet switching they operate on?!!(Confirm)
                                                    if 2 relays for message switching of 5 Mb data on 1Mbps channel and assuming that we can start sending a message only after receiving it all if 5 sec in channels
                                                        total time = 5+5+5= 15 sec for 3 hops.
                                                    VS let's break the message into 5000 packets-> 1000 bits/ packet. so speed of transmission of 1 packet = 1000 bits / 10^6 bps = 1 ms.
                                                        in next second, while second packet is send, the 1st packet can be forwarded to next relay. similar for 3 rd packet
                                                        thus, our total time taken will be 5002 ms because of pipelining called parallel transmission.
                                                    @ Carry big boudlers on conveyer belt vs powder to wagon- more space utilization for 1 with least voids- statistical multiplexing.
                                                    @ Jaggery in a container
                                                </PacketSwitching>
                                                <VirtualCircuitNetwork>
                                                    It is a cross between previous 2.
                                                    phases
                                                        call set up- Virtual Circuit Identifier (every link has)
                                                            Every switch/router sends 1st packet to appropriate next router which assigns a unique (for itself) VCI to the call.
                                                            On return journey Of ACK, all switches inform their predecessor of the VCI they chose which can be placed in their tables as given below.
                                                            @Red cap- Router knows where to forward it to.
                                                        data transfer phase- Data packet coming from port 1.
                                                            router has table as follows:-
                                                                Incoming                Outgoing
                                                                Port    VCI         Port    VCI
                                                                1       14          3       22
                                                                1       77          2       41
                                                                ....
                                                            Eg- Data with VCI = 14 arrives- looks up- outgoing link is port 3 and change its VCI to 22.
                                                                why different VCI? can't afford to maintain similar VCI universally. Can't stop another VCI set up from keeping the same VCI no
                                                                the same VCI is gonna be looked up

                                                        tear phase
                                                </VirtualCircuitNetwork>
                                        </DataTransferTechniques>
                                        <TDM>
                                        TDM- let time slot be dedicated to every station.
                                            slot for 1, slot for 2, ... in Round Robin.
                                            slot is sufficient for their Tt and Tp
                                            Efficiency = useful time / cylce time = Tt /(Tt+Tp) = 1/(1+a)
                                            Eg- Tt = 1ms, Tp = 1ms; Eff = 1/(1+1) = 1/2 = 50%
                                                If BW = 4 Mbps, Effective BW = 1/2 * 4Mbps = 2Mbps
                                            Eg- If N stations need 2Kbps then what's max N?
                                                N * 2Kbps = 2Mbps => N = 1000
                                            Disadvantage- Slot is wasted when stations does not have anything to send.
                                        </TDM>
                                        <Polling>
                                        Polling- instead of dedicating slots, we ask who wants time- requesting ones get it.
                                            Some time for polling- Tpoll
                                            Station A gets access- Tt + Tp
                                            Some time for polling-... Goes on.
                                            Adv- Link util is increased.
                                            Disadvantage- not fair stn A can get over and again.
                                            Eff = useful/ cycle = Tt / (Tpoll + Tt + Tp)
                                        </Polling>
                                        <CSMA_CD>
                                            It is improvement over ALOHA (with carrier sensing facility)
                                        CSMA/CD (ethernet) - Carrier Sensing Multiple Access and COllision Detection
                                            Multiple Access- Many stn trying to access a broadcast channel
                                            Any stn can send data but carrier should be free (sense it b4 sending)
                                                but stn can sense only it own view- not the full channel (problematic)
                                                @standing at 1 point on road- we can't say if road is free
                                            Collision Detection
                                                If both transmit at same time- then collision happens- both see collision. How to identify? No acknowledgements in DLL LAN.
                                                    if signal received, station can always wonder that it is 7 else's data.
                                                    But it can tell collision if it is still sending signal- packet size be long enough that while sending collision is detected.
                                                Imagine- 1 hr Tp- then at 1/2 hr- A and B is simultaneous sent on opp sides then collision
                                                    detected after 1/2 hr- at stn but still sending then collision
                                                    In worst case, 1st bit of stn A reaches almost 50 mins over of 1 hr- if B starts then colllision
                                                        After, 2 hrs- A will detect collision if still sending.
                                                        So, Tt >= 2Tp So L/B >= 2Tp so L >= 2.Tp.B and Tp = d/v
                                                        Eg- L >= 2*10^-3 * 10^6 = 2000 bits
                                            Efficiency
                                                Collision slots- many collisions may happen b4 channel is got.
                                                Then useful time is got Tt + Tp. this repeats.
                                                Eff = Tt / (c*2*Tp + Tt + Tp)
                                                If n stations connected, every stations wants to send with probability p.
                                                probability of success = only 1 station transmits the data
                                                    P = nC1 * p * (1-p)^(n-1)
                                                    dP/dp = 0 => p = 1/n for max P
                                                    P max = n* 1/n * (1-1/n)^(n-1) = (1-1/n)^(n-1) = 1/e when n -> INFINITY
                                                    No of times we should try before getting first success = 1/P(max) = e
                                                Eff = Tt / (e*2*Tp + Tt + Tp) = 1/(1+6.44a) = 1/(1+6.44(d/v).(B/L))
                                                    d inc, Eff dec - LAN (good), WAN (not good)
                                                    L inc, Eff inc - Large packets good.
                                                        @Tollgates- what to better wait for 4 cars or 1 truck? 1 truck- no overhead for e1 or fight.
                                                        can't let unlimited data- monopolization of channel (1500 B agreed)
                                            Back Off Algorithms
                                                @Engaged tone on phone- we try again after varying periods of time.
                                                How much to wait is the central focus here?
                                                so called- waiting time is back off time
                                                n=1, 2 stn send together- collision and come to know
                                                both stations choose between, (0,2^n - 1), possibilities- 00,01,10,11.
                                                    if 01, A waits for 0*Tslot and B for 1*Tslot- success
                                                        Conditional Probability (given that collision and n=2),
                                                            P(A wins) = 1/4 and P(B wins) = 1/4
                                                    if 00 or 11, clash again P(Clash) = 2/4
                                                    say A sends 1st frame (we will call packet)- then A's second packet and B's 1st packet compete
                                                        n=1 for A but n=2 for B.
                                                        (0,1) for A and (0-3 for B)
                                                        combinations- 00,01,02,03, 10, 11,12,13
                                                        P(Collision) = 2/8; P(A) = 5/8 and P(B) = 1/8
                                                        say A wins
                                                    A wants to send 3rd packet and B wants to send 1st packet (3rd time)
                                                        n=1 for A and n=3 for B
                                                        (0,1) for A and (0-7) for B
                                                        P(Collision)- 2/16; P(A) = 13/16 ; P(B) = 1/16
                                                    Analysis
                                                        Capture effect- 1 that wins once tends to win again
                                                        Collision chances go on decreasing if you see.
                                                        generally works for 2. aka Binary Exponential Back off algorithm.
                                        </CSMA_CD>
                                        <TokenPassing>
                                            Tp = 10 bits- by the time bit reaches the other- 10 bits are transmitted.
                                                divide by Band width to get into seconds.
                                                seconds multiplied by velcity gives you Tp in metres.
                                                Eg- 10 bits Tp- find in metres. if B = 4Mbps, v = 2*10^8 m/s
                                                    Time taken to throw 10 bits in channel = 10/4Mbps
                                                    This time 1 bit reaches destination- distance = Tp * v = 500 m
                                            can be in ring or bus
                                            special packet called token passed on- station that holds token is allowed to transmit
                                                data can go in only 1 direction- so no collisions- only 1 stn at a time.
                                                Ring Latency- 1 bit on link to take complete rotation
                                                    Ring Latency = Travel Time + Bit Delay at every station
                                                    Travel Time = d/v 
                                                    Total Bit Delay = N*b wher b is individual bit delay (in bits) on every station in buffer
                                                        = N*b/ B seconds
                                                    Ring Latency = d/v + N*b/B sec = dB/v + N*b bits
                                                Cycle Time = bit Coming back to same point.
                                                    Token holding time= Time for which token is held.
                                                    Cycle Time = d/v + N*THT = Tp + N*THT
                                                    only 1 packets is transmitted by every station on holding a token passing.
                                                    Eff =  UT/CT = N*Tt / (Tp + N*THT)
                                            2 strategies
                                                Delayed Token Reinsertion
                                                    THT = Tt + RL = Tt + Tp + N*b/B = Tt + Tp (for simplicity)
                                                    Efficiency = n*Tt / (Tp + N(Tt + Tp)) = 1/(1+(N+1)a/N)
                                                Early Token Reinsertion
                                                    Token is released immediately on sending data
                                                    node's own data is appended to the data
                                                    after a cycle its own data is removed from the ring.
                                                    in the cycle this goes on happening.
                                                        Broadcast channel- so all messages are seen by e1 (there may be broadcast messages)
                                                    1T, 12T, 123T, 1234T,2341T,3412T,...
                                                    Informal- Earlier was like Stop and wait type and latter is like sliding window.
                                                    Here, THT = Tt (no waiting time)
                                                    Efficiency = N*Tt / (Tp + N*Tt) = 1/(1 + a/N)
                                        </TokenPassing>
                                        <Aloha>
                                        Aloha- Once used in Japan- to communicate between islands (not in practice- no question in GATE or interviews but for completeness)
                                            Sender can send data anytime- no carrier sensing
                                            Collisions would be there- but ACK are there.
                                            Random Time (backoff time) to retransmit
                                            2 Types
                                                Pure Aloha- Tt time of collision. for this entire time- it's vulnerable time and before I start, 7 had started (about to end) is vulnerable
                                                    Vulnerable Time = 2Tt
                                                    Eff = G * e ^ -2G
                                                        G- No of Stations that want to transmit in Tt slot.
                                                        Max Eff = d Eff/ dG = 0 => G = 1/2
                                                        when 1/2 stations want to transmit in 1 time slot, it's best
                                                        means 1 station wants to send in 2 time slots.
                                                        Max Eff = 1/2 * e^-1 = 18.4%
                                                Slotted Aloha
                                                    Time divided into slots and every station can start to transmit at a slot.
                                                    Vulnerable Time = Tt
                                                    Eff = G * e^-G so G = 1 for max Eff = 36.8%
                                                    Effective bandwidth = Eff * BW
                                        </Aloha>
                                    </Solutions>
                                    Flow control vs access Control
                                        Flow Control- Receiver buffer should not over flow
                                        Access Control- Main concern is when 1 sends others don't disturb.
                                            AC to get access to channel and once you have access you take care of flow control.
                                    Efficiency Chart
                                    FC
                                        SNW = 1/(1+2a)
                                        SWP = N/(1+2a) (GBN,SR)
                                    AC
                                        TDM = 1/(1+a)
                                        Polling = Tt/(Tt+Tpoll)
                                        CSMA/CD = 1/(1+6.44a)
                                        Token Immediate = 1/(1+a/N)
                                        Token Delayed = 1/(1+a/N * (N+1))
                                        Aloha Pure = G * e^-2G
                                        Aloha Slotted = G * e^-G
                        Why Error?
                            Packets queue up in router- if processor not fast enough or whatever, buffer overflow and packets lost.
                            Corruption of bits- disturbance in external envt- thunderbolt or frequency changes- some part is changed.
                            This is error handling- bit losses.
                                Error Detection- we just know it got error. Retransmit.
                                    Send 2 copies of data- D + D (problem is data or traffic is doubled)
                                        REL Enter password. Re-enter password (cuz can't see it)- Probability reduces of wrong both times.
                                    Count Parity- No of 1's as odd/even.
                                        Not powerful but had been in practice for long.
                                    CRC- popularly used.
                                        Cyclic Redundancy Check.
                                        So called? Cyclic Codes are used; Redundant bits of data is added; Check- Receiver checks what you sent.
                                        Sender sends 1011011- CRC Generator generates 1101 (n bits)
                                            add n-1 bits to sender data to lsb side.
                                            XOR = sum mod 2 
                                            Eg- 1,1,1 = 1.
                                            Repeatedly apply XOR of 1101 with 1011011000 like we divide.
                                            last 3 bits of remainder are appended to Data.
                                            Data + CRC is sent- 1011011001 is sent
                                            Receiver does XOR with CRC number to number received- number should should be zero, after all- if it's not- then packet got corrupted.

                                    Checksum- popularly used.
                                Error Correction- know where is prob and change it.
                                    Hamming Code (1KB + 0.5 KB)- 50% more to check error. So never use.
                    </DataLinkLayer>
                    <PhysicalLayer>
                            Deals with the medium to transmit data- of individual bits.
                                To transmit bits over a medium; to provide mechanical and electrical specifications
                                Devices like Repeater and Hub
                                    Remove Distance limitation of LAN (electric signal gets weaker with distance); Repeater join LAN together.
                                    Amplifies the electric signal (else 0's had become 1 and vv)
                                Hub
                                    connects multiple input lines electrically (signal repeated on all the lines)
                                    These devices can't support all LAN technologies.
                                    1 large shared link.
                            This layer on our system is managed by NIC
                            Level of connection 
                                    Types based on size
                                            LAN- Limited to a building 
                                            MAN- Limited to a city
                                                Eg- Cable TV- Antenna, Head End, to n Junction box thru bus topo to houses
                                            WAN- pervading across nation or world.
                            future trend- access network and backbone network.
                            transmission technology like wifi, 2G,3G,4G phone (GSM,CDMA)
                            Bit Error Rate * Packet Length = Packet Error Rate
                                    10^-3 - meaning 1bit out of 1000 get an error.
                                    meaning reducing packet size reduces packet error rate
                                            but then lesser information and more overhead to carry of internet in %.
                            ADSL- Download is faster than upload. vs HFC- used for server when upload is greater than download.
                            Capacity of Optical FIber
                                    c'=c/n= 2*10^8 m/s in glass
                                    L =1500nm
                                    v = c/L = 10^14 Hertz = Channel Capacity or band width = 100 TeraBitsPerSec.
                                    That's why used as backbone of network core of nation or so.
                            <PhysicalMedium>
                            Physical Connection/Medium - developing a skeleton for the communication to happen.
                                    Defn- How our computer systems are physically connected to each other.
                                            Connection can be wired or wireless- wifi.
                                            wireless means invisible- well, grounded wires also are- so look for the node we are connected to to tell topology
                                    <BasicElements>
                                            <Node>
                                                    Node- can be any computer, laptop, mobile, router,printer.
                                                    Router- which route to take- there may be graph of routers.
                                            </Node>
                                            <TransmissionMedium>
                                                    Wired- also called guided because the channel guides the way of transmission of signal.
                                                    Wireless- also called unguided because signal is thrown in the air in all directions- broadcasted.
                                                            wireless can also be guided if sent in specific direction for specific device.
                                            </TransmissionMedium>
                                    </BasicElements>
                                    <PhysicalTopology>
                                    Topology - How devices are physically connected thru transmission medium- not the literal shape but idea.
                                            <Basic>
                                                    Notes
                                                            All of them exist means all have something better than that the other because of which it survives.
                                                            Why not 1 for whole world!
                                                            Before laying fibers down, a lot of paper work on design, geography/civil structures and topology is done.
                                                                    and you have to technically justify your decisions.
                                                            Man is laziest- optimally works! so There must have been some deficiencies felt with some so that new ones could be brought in.
                                                            Sometimes the lines may be invisible as in wireless or grounded wire- then we need to know and draw the lines on sheet to figure out.
                                                    <Bus>
                                                    Bus- Equal links or connections of intermediate nodes except end node.
                                                            so called?
                                                                    @School bus- bus from school sends all children and bus/data broadcasts to all the nodes/stations and children/data packets identify their home- mac/ip address get down others reject the data.
                                                            Adv-
                                                                    fewer cables reqd					
                                                            Disad
                                                                    if channel is busy- wait for your turn.
                                                                    1 node malfunctions then whole network gets isolated/partitioned and no access to the other.
                                                                    In optical network, it becomes diffl to design a power budget.
                                                                            when any 2 system communicate there is a power budget
                                                                                    Power budget understanding
                                                                                            Cable wire
                                                                                                    data to signal- a voltage is set such that it is identified at the the receiver- above threshold voltage is taken as 1 and 0 for below.
                                                                                                    the voltage has to increase if error is detected because of attenuation in the channel
                                                                                                            @water leakage in a pipe.
                                                                                                    which leads to voltage loss so much so that it becomes lesser than threshold voltage set to detected a presence.
                                                                                                    if voltage loss is a lot, and prob is identified- we need to increase the voltage of transmission.									
                                                                                            Optical fiber
                                                                                                    Every transmitter uses Prisms used to multiplex multiple wavelengths and traverse thru channel and demultiplexed or filter thru another prism at designated node. unique wavelength for all nodes.
                                                                                                            if no transmission they will keep the wavelength transmitter and receiver node shut off.
                                                                                                            All the wavelengths co-exist in the channel like in the air.
                                                                                                    say 50 Photons are sent for 1 and none for 0- like that- signal is sent. let's say Channel speed is 10^6 bits per sec- then every 1 microsec- a photon bundle can be sent.
                                                                                                    Based on total internal reflection but some leakage of course- backbone of network.
                                                                                                    if 10 photons are lost, 40 are received! converted into voltage- say 10 photons detected by photo-detector translates to 1V. then 4V>2.5 V- so bit is 1.
                                                                                                    for some reason if 40 are lost, 10 photons make less than threshold- this is detected so need to increase the no of photons for transmission.
                                                                                                    decided that let's send 70 photons instead so that signal is identified.
                                                                                            Why don't we use amplifiers- they are costly!
                                                                                    Let's say that it increases with distance or with every relay station- then we can identify the destination distance and accordingly vary our voltage or photons.
                                                                                    Can we add any node at whim- no! 
                                                                                            the plan of increasing the voltage is already set at the transmitter thru its circuitry and so once set up- it is expected that design doesn't change over 4-5 years.
                                                                                            We don't change circuit every now and then.--> NOT USED FOR LAN where we have to frequently add and remove the node.
                                                                                    Power budget required to send a signal over long run (attenuation)- keeps on increasing. So there is a limit to bus size.							
                                                                    It takes decision making to move left or right from the bus- so this has to be tackled.
                                                    </Bus>
                                                    <Ring>
                                                    Ring- Equal links by all.
                                                            so Called- looks like a ring and packets sent in the cyclic fashion.
                                                                    just addition of bus- the first and last nodes are connected.
                                                            If we decide to standardize the direction of throwing the packets 
                                                                    decision making not required 
                                                                    But risk of latency to increase- the receiver might be right next to you,sender in opposite direction.
                                                            If damage then change the route- more resilient!
                                                                    and use hairpin connections to keep the signal alive.
                                                            Used for MAN but not for LAN for same reasons as bus.
                                                    </Ring>
                                                    <Star>
                                                    Star- All nodes are connected to central node.
                                                            Eg- in hostels we have that- why?
                                                                    If central node is down- we know where to go and rectify. Not so in others.
                                                            More cables reqd
                                                            less reliable
                                                            Power budget is constant
                                                            Access points are hanging - other topologies never do that.
                                                            Most importantly, give you flexibility to join or disconnect with network anytime.
                                                    </Star>
                                                    <Hybrid>
                                                    Compounds of upper elements
                                                            @Topologies are like elements of chemistry where they combine and make compounds- so in real life- all of the three will be used.
                                                    </Hybrid>
                                            </Basic>
                                            <Derived>
                                                    Tree- Nesting of stars over stars.
                                                            Eg- In IIITB, Internet from natioinal backbone comes to router Edge/Boundary router then to IIITB- then to filters to check for spam etc then to core switch in room 103 then to different hostels and then to wap where from we access it.
                                                    Mesh- Compound of ring and bus- need to be connected to all.
                                                            National Backbone should be meshed together to make sure that data is not lost for problem in 1 system.
                                            </Derived>
                                            <Issues>
                                                Attenuation- energy is lost over distance
                                                Distortion- some changes
                                                Noise- unnececssary intervention
                                            </Issues>
                                    </PhysicalTopology>
                                    <LogicalTopology>
                                            How our packets get routed- 1 topology can act as the other.
                                            Types- Same as physical
                                                    the optical fibers we saw were logically star, physically bus.
                                                    The star can use ring topology logically by sending it through all.
                                    </LogicalTopology>
                            </PhysicalMedium>
                            How is Packet/datagram sent 
                                    Message is divided- 1500 bytes size of frame- suitable for sending as parts of message.
                                            Even frame is too big to jam the network so it is divided further into packets.
                                                    Each packet has the address of the destination.
                                                    Why?? error check, Multiplexing- allow all the signals to take advantage of the channel.
                                    Transmission time  
                                            is the time taken by transmitter to place a bit on the network/channel
                                            depends on transmiter's power.
                                            Transmitter transmits taking transmission time proportional to transmitter's capacity.
                                                    @loading the car before it can start moving- deficient analogy because in n/w the packets start to move as soon as kept on n/w.
                                                    @A person picking up a ball at a time from a basket and placing it on top of a slope. 
                                            Transmission/Departure time measured in Mbps or Mega Bits per second as bits placed on the channel per sec. reciprocal of Tt.
                                            Voice to analog signal- it represents loudness by its amplitude and pitch by its frequency- 
                                                    both of which change as the speech changes and reflect in analog signal thereby generated.
                                            sampling- sampling rate should be twice of maximum frequency- our speech has frequency from 3000 hz to 3300 hz and so twice of it
                                                    8000 samples/sec is taken. so that output will be quite similar.
                                                    1 sample is sent after every 1/8000 = 125 microsecond.
                                            quantization- amplitude is measure of loudness and several quantized levels are kept to measure the amplitude on the scale of 0 to 255- represented by 10V for 255
                                                    it means 1 unit gap of 10/255=0.04V
                                                    it means 8 bits are required to specify the quantized level (of amplitude).
                                                    Since we have 8000 samples per second and 8 bits per sample to be transmitted means must have bit rate of 8000*8=64000Kbps.
                                            Encoder- after every 125 microsecond- 8 bits are sent as per the encoding technique.
                                     Transmission
                                    Propagation delay/time - time taken for packets to reach the destination from the source
                                            depends on distance and speed of signal.
                                            It is generally constant for a transmission.
                                            Multiplexing -when the bandwidth of the medium is greater than needs of a device we can allow multiple transmissions to share the channel over short time burst-MUX is set of techniques to do that.
                                                    TDM-over digital.Time slots are given to users.
                                                    FDM-analog. Frequency slots run in parallel and every user gets a frequency at run time- so lesser B.W but for all the time slots.
                                                            It is costly so not generally used for ckt switching.
                                                            We can also have TDM over FDM to change the users who can transmit on a frequency for a given slot.
                                                    WDM-analog.
                                             Multiplexing
                                    Working of router
                                            Router maintains a queue for buffer of all the data packets. Fires packet in apt direction. Checks for errors/MUX and retransmits( does functions of switches and repeater also).
                                    I send about 50 packets in just "Hi" I say.
                                    Virtual Ckt Switching- Maintain a tag to direct a packet in a direction specified by 1 notified by 1st packet who determined best path.
                                            @See a cap and direct the person to director's office or Library, OR Barsana or Shreeji Bus.
                                     Propagation
                                    Arrival or Receiving rate - the rate at which the packets are processed at the receiving end.
                                            It has to be same. If not, then 1 has to slow down
                                                    @someone speaking too fast a lecture may become overwhelming.		
                                     Arrival/receiving
                                    4 Delays of Packets- 
                                            Transmission Delay (Tt)- Time taken by sender to put data packet onto channel
                                                if Bandwidth = 1bps- I put 1 bit on channel in a second. It 10 bits to send
                                                    then Tt = L/B = 10/1 = 10 sec.
                                                    Eg- L=1Kb (data in power of 2) and BW=1Kbps (freq in power of 10) then Tt = 1024/1000bps = 1.024 sec
                                                    So smaller packet desirable and High band width desirable.
                                            Propagation Delay (Tp)- Time taken by last bit to reach the destination.
                                                Depends on distance, velocity of signal.
                                                Tp = d/v; optical fiber has 70% of light = 2.1 * 10^8 m/s
                                                Eg- 2.1 Km and v = 2.1*10^8; Tp = 10^-5 s = dividing and multiplying by 10^-6 to get in Microsec.
                                            Queuing Delay- Most difficult to calculate (run time). Packets sits in queue before it gets processing time.
                                                depends on speed of processor.
                                            Processing Delay- depends on speed of processor.
                                            Total Time = Tt + Tp + Tq + Tproc = Tt + Tp (assume others to be zero)
                              Time Taken in different aspects
                        <uncat>
                            nEED TO represent digital in analog ways- transmit over wires channel.
                            Layer will expose its abstraction is all higher layers need to know about it and not all.
                            Rate comes in different names- bits per seconds onto the challenge
                            delay time it takes for sgnal to cross the channel.
                            wireless have higher error rate
                                    message intact at other end.
                                    fix that so that no bogus bits.
                                    UTP=unshielded twisted pair.
                                    twist reduces the interfering RF signals- radiations- and hence interference.
                                    voltage difference makes signal move
                            coaxial higher data rates.
                            Fiber is enormously higher rate- fiber physical properties allow wide range of frequencies and travel a long way b4 attenuation.
                            wireless- advantage to reach many users at same time but interference.
                                    superimposed as jumbled.
                                    how to solve it? frequency allocation chart. spectra decided.
                                    wifi in ism band. fcc allowed - no need to purchase.
                                            just garbage bands undesirable- cn used it- part of intension.
                                            many different ppl might be using these bands for wifi so need to coordinate.
                                            a lot of innovation over it.
                        </uncat>
                    </PhysicalLayer>
                </CNLayeredArchitecture>
                <Misc> Personal reflection
                Exercise to see how CN ability send messages on electric wire is extended to develop web applications
                        packet maps to a segment data 1:1 - not true with others.
                        Frames - from 1 router to another, frames are sent but router being on network layer - confirms the receipt of the packet and forwards it.
                                at this layer hop to hop success is guaranteed.
                        IP - just guarantees packet to reach one end to another thru necessary hops - all routers participate.
                                all it cares is that a given packet reaches the system. it's job is over. the IP covering can be shed after reaching the end system (except source IP)
                                it is best effort to make a packet reach the other system (so theoretically it guarantees reaching)
                        TCP - guarantees process to process communication. packet reaches system - look at the segment details and ask resending of packet as per go back n.
                                there can be 2 processes on 1 system (eg google chrome 2 tabs) - contacting same server - you need information of port to discern 1 packet to another
                                        so at the layer of TCP - packet and segment can be used interchangably.
                                collect all packets or segments - sequence the data and make data stream which can be used by application layer.
                        web server = http server (almost) but an http server can be not a web server (just using protocol). a web server can be ftp, etc.
                                does all the housekeeping of maintaining table entries of source address, port, destination address, port, http request, http response.
                                        if static page, it can refer to a file location on disk read and send back.
                                        if dynamic page, page call maps to class methods called servlets 
                                                spawns many threads of servlets for all the requests - must use callable threading to send and receive data back for every call.
                                                servlet receives input in form of MVC View request and expects a view response (think in terms of UI I/O) objects.
                                                from here the computation of transforming 1 object to another starts.
                                OSI proposes session layer for context setting - giving statefulness to web. I am the same person who finished in that context.
                                        currently this is managed through cookies - means application level - not even application layer - http is stateless protocol.
                                        other authentication, authorization things ?are all application details or are quite similar.
                                presentation layer is just metadata about application layer - format, encryption, etc.
                </Misc>
            </Foundation>
            <NetworkSecurity>
                <Subject3rdSem>
                    <Design>
                        Network design works for:
                            Performance
                            Cost
                            Security
                    </Design>
                    <Jargon>
                            Vulnerability- Weakness of a system (intrinsic)
                            Threat- A potential (extrinsic) to break ur system (taking advantage of vulnerabilities)
                                    Malwares- give unexpected system behavior
                                            Virus
                                            Worms
                                            Spyware
                                    Spam (unwanted email) => Phishing (legitimate info got using images/ replica, etc- gimme bank account details)
                                    Denail of service
                                    Botnet- Robots automated to control someone else's PC.
                                            can break an org by DDOS (targetting distributed Denail of service)
                                            Cross site scripting- discern human from machine.
                            Exploit- Tool to take advantage of vulnerability
                            Attack- Procedure adopted (implementation) to exploit
                                Active attacks- active participation (doing sth to flow of events)
                                    Eg- modification
                                    Easy detect more harmful.
                                Passive Attacks- on receiving end.
                                    Eg- Interception.
                            Risk- Effect on system (damage recovery) if vulnerability is targetted.
                    </Jargon>
                    <Roles>
                            White Hackers- ethical. hired to tell us (expose) vulnerabilities
                            Black Hat Hackers- intent to exploit vulnerabilities
                            Grey- st on either side.
                            Cracker- no advantage- just for fun.
                    </Roles>
                    <Defn>
                    Intersection of Computers, Communication and Security
                            Security not included in TCP/IP.
                                Channel is unsecure (not insecure)
                    </Defn>
                    <SecurityObjectives>
                    What- Policy- Security Objective (CIA)- Confidentiality, Integrity, Availability
                            <Remember>
                            Senders' Perspective
                                C-My credentials/message should not fall in wrong hands (ensure 1 to 1 talk)- (why we doing it in first place)
                                I-Message should be delivered as it is.
                                A-The response should be as expected- the services delivery in time.
                                A-He may want be sure that I sent it and no1 else- I stand fully stand of (responsibility)
                            Receivers' Perspecive
                                Authenticate- For me, I want to be sure that Mr. X has sent a message (message source is what it claims)
                                Integrity- this message is EXACTLY what he sent- what services he wants (or information to be delivered)
                                Availability- what services, I want to ensure he gets (or users in general get)
                                Confidentiality- no1 stole the message- no1 is eaves dropping on the confidential information.
                            </Remember>
                            <Confidentiality>
                            C- Confidentiality
                                    Privacy of data (from/to whom; keep sth private)
                                        no disclosure
                                        @Employee shouldn't know mgr's salary
                                        @Military- Target coordinates of missile are not disclosed.
                                    Attack by Interception- eaves dropping is listening (encrypted or not)
                                        Passive Attack- Passive means being on the receiving end.
                                        Solution- Cryptography!
                                            do security transformation of message on both ends (so that attacker doesn't understand)
                                            Traffic monitoring- how many packets
                                                Eg- yes at 5 we attack. vs Not Now. (size of data can tell sth to us)
                                            Traffic padding- adding extra data (redundant packets) to confuse the attacker.
                                                Eg- Yes- attack at 5. No- attack at 5.
                            </Confidentiality>
                            <Integrity>
                            I- Integrity
                                    aka message authentication.
                                    Maintaing correctness of message
                                        no modification- Interception is a pre-step for this.
                                            or eat up bit or flip some random bits or add some bits (assuming headers are are not messed)
                                        @Employee can't change his salary from DB.
                                        @Military- Target coordinates of missile are not changed.
                                    Attack by Modification-
                                        Active Attack- means activity (sth is done to intervene flow of events)
                                        Eg- changing address.
                                    Solution- Achieved thru hashing
                                        From Message, M, H(M) is computed s.t. difficult to find M or M' s.t H(M') = H(M)
                                        if encrypted, obviously M can't be tampered!!
                                            it can be! just eat up some bits! or randomly change some message bits from the middle.
                                            checksum just looks into end to end transmission is perfect- here A to C is perfect and C to B is perfect.
                                            if any modification with M (of course, its encrypted version is available)- H(M) is not going to be same as that for new M'
                                        Also used in
                                            Password matching in OS- exact passwords are not kept in any file (obviously!!)
                                                matching of the password is done with the hash.
                                            File Modification by Virus
                                                Hash of file and match with list of known virus.
                                                Here if file was modified, H(file) will now be different from old one.
                                                ?But whenever a change in file, a new hash is computed.
                            </Integrity>
                            <Availability>
                            A- Availability
                                    aka Authorization and Access Control
                                        vs authentication- verification of a person (to permit into system)
                                        next step to give him priviliges as per his role- authorization.
                                    Data (resources) always available to legitimate users
                                        No Denial of Service
                                            @Employee get paychecks printed at stipulated time.
                                            @Military- missile is launched when command is issued.
                                    Attack by Interruption/ Denail of Service
                                        Eg- Cutting the wires!
                                    Solution?
                            </Availability>
                            <Authenticate>
                                [Sender] Authenticate- for receiver Identify sender and he is the one who sent (for sure)
                                    REL this message came from Mr X's key.
                                Attack by Impersonation or Masquerade.
                                        Replay Attack- Sending same/dummy packets with same TCP/IP headers.
                                            Eg- Send to Amazon order again- CIA still there but that of system is lost.
                                                I may send later- when process/port not even active (but servers always are)
                                Solution- Session Identifiers maintained
                                    Notarization- @ what notary does- trusted third party (TTP), right?
                            Stricter Versions
                                    <NonRepudiation>
                                    Non-Repudiation- for anyone to claim (in court- to which sender can't deny) that it is this sender who sent.
                                            REL it was not Mr X's key but Mr X himself.
                                    </NonRepudiation>
                                    <Accountability>
                                    Accountability- action of entity can be traced to that entity uniquely
                                            Eg- If broker changed the stock rates- fluctuated the market- he can't mess it (system has recorded (logs))
                                            Eg- Bank Transfer- logs of all your actions.
                                    </Accountability>
                            </Authenticate>
                            Can do trade off- but not recommended we need all 3 together.
                    </SecurityObjectives>
                    <SecurityMeasures>
                    How- Mechanism- Security Measures
                            <Deter>
                            Deter- Discourage
                                    @Put a lock- number lock, lever lock, etc
                                    Strict govt laws.
                            </Deter>
                            <Prevent>
                            Prevent- Stop from happening
                                    Security is battle of wits
                                            Eg- firewall- shield (at boundary) to protect from outside world
                                            Now threats can come from internal to system and failing the firewall itself.
                                    @stop at gate
                                    <Cryptography>
                                    Uses Cryptography
                                            trades-off with ease of use (time consumption)- @security check for flights
                                            <Where>
                                                Operates at which layer of OSI (TCP/IP)
                                                <ApplicationLevel>
                                                    Encrypt the whole file itself before sending.
                                                </ApplicationLevel>
                                                <PresentationLayer>
                                                    host work happens in this layer (all sorts of translation)
                                                    uses Session Layer- for session establishment
                                                    From standpoint of TCP/IP model, it is application layer but strictly is in between.
                                                    <SSL>
                                                            Protocol- Secure connections achievement
                                                                when http used over SSL- called HTTPS (Secure HTTP)- port 443 at times but not limited to web browsers.
                                                                New layer interposed betw application layer and transport- accept request from browser, send to TCP for transmission.
                                                            History
                                                                Static pages -> eCom - 1995 Netscape intro SSL to meet demand.
                                                            Options- 
                                                                Supports options to choose from
                                                                    presence of compression
                                                                    cryptographic algo used
                                                                    export restrictions on cryptography- both ends in US (else keys limited to 40 bits- joke but had to get license from US govt)
                                                            includes
                                                                    Parameter negotiation betw client and server
                                                                    authentication of server by client
                                                                    secret communication
                                                                    Data integrity
                                                            Parts (v3)
                                                                    Establish a secure connection
                                                                            M1- Alice (Client) sends request for connection with specified SSL version, compression and cryptographic algo choices.
                                                                            M2- Bob (Server) chooses algo, sends his nonce (Rb)
                                                                            M3- Bob sends his public key with certificate. If certi not by well known authority then sends chain of certs followed back to 1.
                                                                                    Alice verifies Bob's public key. Bob can also send request for Alice's public key.
                                                                            M4- Bob tells Alice that it's her turn
                                                                            M5- Alice chooses a random pre-master key (384 bits) and sends using Bob's public key
                                                                                    Session key is derived from pre-master and nonce in complex way.
                                                                                    Both compute session key- stronger key- difficult to cryptanalyse.
                                                                            M6- Alice tells Bob to switch to new cipher
                                                                            M7- Alice tells bob she is finished with subprotocol.
                                                                            M8,9- Bob ACK her
                                                                            Alice knows Bob but not vv (public key unlikely for indiv)
                                                                                    Bob may ask to log in using prev established login credentials- outside scope of SSL.
                                                                    Use the secure connection
                                                                            Data transport can begin now- 
                                                                            Compression and encryption
                                                                                    Banking- triple DES with 3 keys + SHA-1 for integrity (highly secure but slow)
                                                                                    eCom- RC4 (128 bit) + MD5 (msg authentication)
                                                                                            RC4 expands 128 to more bits- XOR with keystream. now easier to break.
                                                                                            RC4 has weak keys so shaky ground
                                                                                            configure browsers to use triple DES with 168 keys and SHA1 all the time.
                                                                            Fragmentation- to 16KB chunks
                                                                            Compression- for each unit.
                                                                            MAC Added to each- secret key added to compressed text.
                                                                            Encryption using agreed upon algo
                                                                            Fragment header is added- transmitted over TCP Connection.
                                                            Problem- do not always verify that keys match. Principals may not have certs.
                                                                    SSL standardized to TLS (Transport Layer Security) by IETF.
                                                                    TLS built on SSL3. small changes but not interoperable.
                                                                    Most browsers implement both- TLS fails then to SSL during negotiation if necessary.
                                                                    referred to as SSL/TLS. SSL has remained but will be replaced probably.
                                                                    TLS in 1999 and v2- 2008.
                                                    </SSL>
                                                </PresentationLayer>
                                                <IPSec>
                                                    Ref: Tannenbaum book
                                                        IETF knew long that internet lacks security but where to put it war!
                                                        application specific security areas- end to end processes
                                                                any tampering can be detected by OS => all apps should be security aware!
                                                        transport- changing it or added b4- TLS/SSL.
                                                        Network Layer- secure networking for security ignorant apps also
                                                                Advantage
                                                                    users don't understand security and no1 needs to modify programs- won s.t standard is defined.
                                                                        aware apps can do it right and unaware also get benefit.
                                                                        permit the use of null algo (if forgo computational expensive)
                                                                    Options- IPSec is framework for 
                                                                        multiple services- not all want to pay price of service- so ala carte.
                                                                                eg- data integrity, secrecy, protection from replay.
                                                                        multiple algo- cuz algo may be broken- so flexible design, framework will survive.
                                                                        multiple granularities- protect 1 TCP Connection, all traffic betw 2 hosts, that betw routers.
                                                                It is connection oriented- connection is called SA (Security Association)
                                                                        SA has an identifier- simplex connection betw 2 end points.
                                                                                security in b/s => 2 SA.
                                                                                identifier carried with packets- used to lookup keys and stuff.
                                                                        2 parts added to packets
                                                                                2 new headers for securityID, integrity data, others
                                                                                ISAKMP- Internet Security Association and Key Management Protocol- protocol to establish keys.
                                                                                        IKEv2 is used
                                                                        2 modes
                                                                                Transport Mode- IPSec header after IP.
                                                                                        Protocol field in IP packet is changed to indicate that it follows (instead of TCP)
                                                                                        Header fields
                                                                                            nextHeader, AHLength, Reserved
                                                                                            SPI- Security Parameter Index
                                                                                            Sequence Number
                                                                                            Authentication Data (MD5/SHA1)
                                                                                            contains security info, SA identifier, seq no, integrity payload check
                                                                                Tunnel Mode- entire IP (header+payload) encapsulated in new IP packet with new header.
                                                                                        useful when tunnel ends at a location different to destination- like security gateway firewall.
                                                                                            used for VPN. gateway encapsulates and decapsulate as packet pass.
                                                                                                useful when many TCP connections aggregated and handled as 1 encrypted stream- hides #packets- traffic analysis.
                                                                                                eg- high traffic betw pentagon to military but low betw pentagon and whitehouse.
                                                                                            Only secure gateway needs to know about IPSec not the LAN.                                                                                            
                                                                                        grows packet size substantially.
                                                                        2 headers alternatives
                                                                                AH- Authentication Header- Integrity and anti-replay (no security)
                                                                                        betw TCP and IP Headers- payload is padded for authentication algo needs.
                                                                                        Next- to say that AH follows. (51/6 for TCP)
                                                                                        Payload Length- #words (of 32-bit size) - 2
                                                                                        Security Parameter Index- sender sends this connection Identifier to indicate record in receivers' DB containing shared key
                                                                                            (ITU would have called it Virtual ckt No)
                                                                                        Seq No- to number pkts on SA. unique even if same TCP seq no
                                                                                                no repetition- if 2^32 exhausted then use a new SA.
                                                                                        Authentication data- digital signature of payload negotiate on signature algo
                                                                                                symmetric is preffered to do rapidly- public are slow.
                                                                                                the same shared key is used which was used to set up an SA.
                                                                                                HMAC > SHA1 + RSA
                                                                                        Integrity check covers IP Header fields that don't change- TTL is left off (change router to router)
                                                                                                covers IP Source- so can't be falsified
                                                                                ESP- Encapsulating Security Payload
                                                                                        2 words (32bit) containing Security Parameters Index, Seq No, [IV]- IV not a part if null algo used.
                                                                                        HMAC put in the end cuz calculated along bits going out of network interface- no buffer- increased speed.
                                                                                                @CRC have trailers in DLL.
                                                                                        with integrity added to ESP (not b4), AH is obsolete- only arg left IP header sec and getting easy export license
                                                                                        Transport Mode- IP + ESP + TCP + Payload + HMAC
                                                                                                ESP to Payload is authenticated (using HMAC)
                                                                                                TCP to Payload is encrypted
                                                                                        Tunnel Mode- NewIP + ESP + OldIP + TCP + Payload + HMAC
                                                                                                ESP to Payload is authenticated
                                                                                                OldIP to Payload is encrypted
                                                        Stalling Book
                                                                IAB has included necessary security features in IPv6
                                                                Benefits
                                                                        Company can make VPN- reducing private network- cost and mgmt overhead.
                                                                        remote access to company network thru ISP- reduce travel charges
                                                                        secure commn with other orgs
                                                                        enhanced eCom securty.

                                                        capability added to IP thru headers
                                                        encompass 3 functional areas
                                                                authentication
                                                                        HMAC
                                                                        Tunnel Mode- applied to entire packet
                                                                        Transport Mode- applied to all but IP Header.
                                                                confidentiality
                                                                        Provided by encryption format for payload.
                                                                and key management
                                                </IPSec>
                                                    TCP/IP headers are unsecure- so IP Security protocols come to guard.
                                            </Where>
                                            <terms>
                                                <Cryptography>
                                                Cryptography- hidden writing- art and science of secret writing so that only intended user can understand.
                                                    Encryption- Uses key to encode/encrypt a plain text into cipher text (gibberish)
                                                    Decryption- Uses another key to convert it back (decode/decrypt)
                                                    Algos to convert on either side are open source (freely available) so key is the key.
                                                    algo, keys maybe same or not (be these steps form a cycle)
                                                    <Types>
                                                        <ByKeys>
                                                            Symmetric- 1 key used between a pair (both share a secret key)
                                                                No of keys for n = n^2
                                                                when a new system joins- n new keys reqd.
                                                                Key sharing problem- unsecure channel (reduction)? Trusted Third Party.
                                                            Asymmetric- 2 keys used- public and private.
                                                        </ByKeys>
                                                        <ByOperationTypes>
                                                            Substitution- changing a bit/ letter/ unit of data by substituting with another.
                                                                Eg- cat made dog.
                                                                can we replace larger text to smaller text thus compress it.
                                                                    No mapping rules- 1:1 correspondence will be lost and cycle won't complete- cipher to plain.
                                                                    maybe having extra set of letter may help. growing alphabet set.
                                                            Transposition- changing their relative positions (index)
                                                                Eg- cat made act.
                                                            In real life we use both
                                                        </ByOperationTypes>
                                                        <ByProcessing>
                                                            BlockCipher- k chars/ block at a time.
                                                                Whole message is divided into blocks and each block is ciphered.
                                                                Changing keys for every block.
                                                            StreamCipher- Bit by bit conversion- bit/byte is the block size.
                                                                P1 made C1, P2 made C2 and so on.
                                                                No storage for stream!
                                                                No padding required unlike block.
                                                                We want use unique key for every Pi to Ci- key wear and tear (want to change keys)
                                                        </ByProcessing>
                                                        <KeysNumber>
                                                            let n be #block and k be #keys
                                                                k > n - not need for keys than blocks
                                                                k = n - Ideal!
                                                                k < n - we will want to reuse them under some pattern or using text (sth)
                                                                for 1 key model,
                                                                    P1 != P2 => C1 != C2 and P1 = P2 => C1 = C2
                                                            we can analyse patterns in Ci and we can find 1:1 correspondence.
                                                                Eg- 1 letter word can be "I". so check its Cipher text. replace (in different color) thru the text.
                                                                Eg- frequent three letter word would be "the" and so on.
                                                        </KeysNumber>
                                                        Eg- RSA uses-Asymmetric, Combination of substitution and Transposition, Block Cipher.
                                                    </Types>
                                                    <Interception>
                                                        <SubstitutionTechniques>
                                                            <CaesarCipher>
                                                                1 key, stream based, symmetric (different algos), substitution based
                                                                Ci = E(Pi) = (Pi + 3) % 26;
                                                                Pi = D(Ci) = (Ci - 3) % 26;
                                                                E(Pi, k) to generalize it.
                                                                Cracking
                                                                    iteratively, give k-shifts to every letter in a sentence (or so) until 1 of them makes sense.
                                                                    Statistical Analysis of Cipher text- count no of every letter- 'e' is most frequent letter in english!
                                                                        we have cracked 1 letter (law of large numbers)
                                                                        Huffman's compression then every letter is not 8 bit long. Then a little more thought- universally may be known algo.
                                                                In real world we are not limited to 26 letter but unicode set in our bag.
                                                                    compression also.
                                                            </CaesarCipher>
                                                            <RandomLetters>
                                                                Brute Force attack-trying all keys!
                                                                    26! keys would be required.
                                                                        26 for A, 25 for B, etc.
                                                                    Statistical Analysis still hold true!
                                                                        'y' more means, y might denote 'e'
                                                                        digram- 2 letters that repeat- 'th'
                                                                        trigrams- 3 letters that are most frequent- 'the'
                                                                            hunt for 3 letter pattern repeating itself.
                                                                    Idea- we want our keys to change
                                                            </RandomLetters>
                                                            <PolyfairCipher>
                                                                Choose a key with no repeating letters
                                                                    Write the key in a 5 X 5 square matrix and fill remaining from A-Z leaving key letters.
                                                                Take plain text- add X on repetition
                                                                    Pick plain text in pairs and check in the 5 X 5 matrix.
                                                                    Find intersection of their row and column- pick the same row intersection entry in sequence.
                                                                    if same row, col- pick entries from the right/down shift.
                                                                Do the opposite for decryption.
                                                                History
                                                                    was used in WW1 for non-critical secrets.
                                                                Shortcomings- for a pair, digrams can be caught.
                                                            </PolyfairCipher>
                                                            <Vignere>
                                                                It is a polyalphabetic cipher- 1 letter maps to multiple letters in cipher 
                                                                    (cuz of different keys)
                                                                    still used.
                                                                    Unlike previous one, the replacement of letter with another is not unique- but time variant (changes with the index (lengthKey))
                                                                Choose a keyword- "CODEX"- longer, the better (difficult to crack)
                                                                Plain text- write the message without spaces (with spaces it gets easy to break)
                                                                    write the keyword repeatedly in streaks below the plain text 
                                                                        Idea- pad the text into the key after 1 'deceptive' is over.
                                                                            write keyword and then followed by message.
                                                                    use keyword as vertical and messageletter as horizontal replace with table entries.
                                                                Decryption
                                                                    Use KeyLetter as horizontal and Cipher text as table entry, find the column.
                                                                    write the streaks of column entries for all plain text.
                                                                Concerns
                                                                    If a little knowledge is gained
                                                                        here, in key 2nd letter = 4th letter- can be harnessed if known (so distinct)
                                                                        if length of repeating key is known?
                                                                        Then pattern of Cipher text repetition can be studied at apt indices.
                                                                    Still statistically vulnerable.
                                                                        how? for every letter like 'e' can be encripted by a,b,c,...- frequency plot.
                                                                Idea- 
                                                                    1. key should not be repetitive
                                                                    2. Random
                                                                    3. Length = size of message
                                                            </Vignere>
                                                            <Vernam>
                                                                XOR operation on Plain text and then Cipher text to recover.
                                                                    Why XOR is famous- cuz its results' XOR with key produces plain text and destroys statistical patterns.
                                                                the key is changed for every session
                                                                Unconditionally Secure- cuz random key (for every session) difficult to know.
                                                                    Proof by Shannon
                                                                        P(M=m;C=c) = P(C=c)*P(M=m|C=c) = P(M=m)*P(C=c|M=m)
                                                                        => P(M=m|C=c)=P(M=m)*P(C=c|M=m)/P(C=c)
                                                                        Ideally, if P(M=m|C=c)=P(M=m)- our system if most secure.
                                                                        P(C=c|M=m) = 1/N
                                                                        P(C=c) = SIGMA(P(C=c|M=mi).P(M=mi)) = (1/N).SIGMA(P(M=mi)) = 1/N
                                                                        => P(M=m|C=c) = P(M=m)
                                                                Problem is how to share the random key. Append on packet- then universally known!
                                                                    The same proof is useful for revealing that AES, DES, RSA, ECC, etc are breakable.
                                                            </Vernam>
                                                        </SubstitutionTechniques>
                                                        <TranspositionTechniques>
                                                            aka Permutation Techniques
                                                            Rail Fence Cipher- 
                                                                Plain text- meet me at tech
                                                                m e m a t c
                                                                e t e t e h
                                                                = mematceteteh is cipher text to send
                                                                Cracking- 
                                                                    divide cipher text in 2 parts.
                                                                    alternatively pick next letters in iteration from the 2 (can be extended to k)
                                                        </TranspositionTechniques>
                                                        <DES>
                                                            Data Encryption Standard
                                                            Cipher text ideally of same length as plain.
                                                                |C| > n => wastage of network resources; some ciphers won't have their pre-image
                                                                |C| = n => desirable
                                                                |C| < n => mapping (1:M)- some cipher text may have 2 or more pre-image.
                                                            DES
                                                                Block, symmetric, substitution + transposition
                                                            Initial Permutations (IP)
                                                                a table telling which bit should come where.
                                                                essentially swapping left and right sides.
                                                                if A[1][1] tells 48 means first bit of output comes from 48th bit input.
                                                                "Tables" are universally known- secret is in key.
                                                                    Table presentation is for ease of understanding- but nth called IP table!
                                                            Feistel Cipher Structure (16 rounds)
                                                                Diffusion- breaks statistical pattern from P to C.
                                                                    The statistical structure of the plaintext is dissipated into long-range statistics of the ciphertext
                                                                    This is achieved by having each plaintext digit affect the value of many ciphertext digits
                                                                Confusion
                                                                    Seeing a cipher text, you can't tell the key.
                                                                    Seeks to make the relationship between the statistics of the ciphertext and the value of the encryption key as complex as possible 
                                                                    Even if the attacker can get some handle on the statistics of the ciphertext, the way in which the key was used to produce that ciphertext is so complex as to make it difficult to deduce the key
                                                                Rounds
                                                                    L.R -> R.(F(R) XOR L)
                                                                    Feistel Function
                                                                        Expansion (E)- Right half 32 bits to 48 bits.
                                                                            1,2,3,...32 made into 32,1,2,3,4,5,4,5,...32,1
                                                                        Key Mixing- E(R) XOR Ki (ith round key) (48 XOR 48 to 48 bits)
                                                                            Ki generation from K(i-1)
                                                                                Left Circular shift of both halves (28 + 28)
                                                                                Compression/ Permutation (48 bits)
                                                                        Substitution in S-Boxes (48 bits to 32 bits)
                                                                            using some function.
                                                                            non-linear
                                                                                f(a+b) != f(a) + f(b)
                                                                                f(11) != f(10) + f(01)
                                                                            Substitution (1:1 mapping)
                                                                                ?I -ASCII-> 9 -Encoder-> 1001 -MappingFunction-> 0011 -Decoder-> 3 -ASCII-> C.
                                                                                S-Box tables- (48=8*6) 
                                                                                    110110- first and last bit 10 (2nd row) and 1011(11th column) of the table entry.
                                                                                    8 such boxes- 6 to 4 mapping by every 8 boxes.                                                                            
                                                                        Permutation
                                                                            tables are universally known- secret is in key.
                                                                Avalanche Effect- 32 bits change over 16 rounds of DES.
                                                                    change in 1 bit of plain text or key brings change in many bits of cipher.
                                                                Double DES = DES
                                                                    What's wrong
                                                                        C1 = K1(P) and then C2 = K2(C1) //both mappings are 1:1
                                                                        => C2 = K2(K1(P)) = K3(P)   //see venn diagram
                                                                        So it should not work.
                                                                        # of different blocks possible (plain and cipher) = 2^64
                                                                        from set 2^64 to 2^64- plain to cipher- how many mappings are possible?
                                                                            take for n to m (assume m > n). conceive of it as n slots for every element and 1 of m it to sit in them.
                                                                                1st of n can choose in m ways; 2nd in (m-1) ways; ...nth in m-n+1 ways.
                                                                                for n to n- n*(n-1)*(n-2)*..1 = n!
                                                                            (2^64)! ways- all those ways need a total of (2^64)! keys but available keys are 2^56 (56 bits)
                                                                                so probability that K3 exists in the domain of 2^56 possible keys is (2^56)/((2^64)!)
                                                                                It means there may be many mappings for which no key would exist (in our key space but hacker won't know that!)
                                                                    Why not used
                                                                        Known plain text attack
                                                                            we know Pi and Ci- can we guess K1 and K2?
                                                                            Meet in the middle attack (sub-strategy used)
                                                                                Brute force generate Xi from Pi using all keys K1i in E.
                                                                                Brute force generate Yi from Ci using all keys K2i in D.
                                                                                Match the Xi and Yi for equality- (#thus if single DES is cracked, double would be cake walk)
                                                                                Obtain a set- shortlist elements in there, using other pairs of Pi,Ci.
                                                                Triple DES
                                                                    C = Ek1(Dk2(Ek1(P)))
                                                                    P = Dk1(Ek2(Dk1(C)))
                                                                Skipjack
                                                                    unbalanced fiestel network
                                                                    means divided in unequal parts in every round.
                                                                    Looks like loss of data but there isn't.
                                                            IP ^-1 restores it
                                                                essentially swapping left and right sides.
                                                            Features
                                                                Block size- big => greater security but reduced speed of encryption cuz more memory to store and CPU requirements.
                                                                Large key- complex algo
                                                                    Larger key size means greater security but may decrease encryption/
                                                                Subkey generation- key to many keys.
                                                                    56 bit key + 8 bit parity.
                                                                Same algorithm works for decryption with key string reversed
                                                            Proof Of Correctness
                                                                Consider after 1st round of decryption as Ld1 and Rd1
                                                                Ld1 = Re15 (verify those tracing lines)
                                                                Rd1 = Ld0 XOR f(Ki,Rd0)
                                                                    = (Le15 XOR f(K16, Re15)) XOR f(Ki,Rd0)     //tracing lines
                                                                    = Le15 XOR (f(K16, Re15) XOR f(Ki,Rd0))     //XOR is associative
                                                                    = Le15 XOR (f(K16, Re15) XOR f(Ki,Re15))    //by tracing lines
                                                                    = Le15 XOR (00000...)       //if Ki = K16! which it is!
                                                                    = Le15
                                                                Similarly, Round 2 of Decryption reverses round 15 of encryption.
                                                                Round 3 .....Round 14 .....
                                                                Round 16.....Round 1....
                                                            #
                                                                weak key- key which is not good for providing security.
                                                                Confusion given by S-Boxes (substitution)
                                                                Diffusion given by Permutation- effect is distribution from occurence.
                                                                If all 0s in plain text and all 0s in keys- ?DES and AES will give non-zero cipher.
                                                                Online encrypt tool- https://www.tools4noobs.com/online_tools/encrypt/ 
                                                       </DES>
                                                        <AES>
                                                            Advanced Encryption Standard
                                                            Bigger block size (128 bits or 16 bytes) => greater mappings!
                                                            Rigndael is algorithm used for AES.
                                                            More efficient than DES.
                                                            Choice in key size = bytes 16/24/32 (bits 128/192/256)
                                                                more secure.
                                                            Iterative but no criss cross like DES.
                                                            Based on Finite Field arithmetic
                                                                Field- a set in which BODMAS operations result in members of same set.
                                                                    Eg- Real numbers, Natural numbers is not
                                                                    Finite field- over finite set.
                                                                        Eg- Zp = {0,1,...,p-1} where p is prime and operations are over mod P.
                                                                        #P has to be prime for it to be field or u tell me.
                                                                        need lg(P) to store these values so a little wastage of bit space.
                                                                why?
                                                                    a.b = c > 2^k so finite field has to be used.
                                                            All Encryption Rounds
                                                                Substitute Bytes
                                                                    S-Box from 16 bytes to 16 bytes - tables for reference (not used)
                                                                    same for all rounds.
                                                                Shift Rows
                                                                    Permute on bytes as follows- organize in 4 X 4 table.
                                                                    1st row shift by 1 byte to left.
                                                                    2nd row shift by 2 bytes to left.
                                                                    3rd row shift by 3 bytes to left (or 1 to right)
                                                                Mix Columns
                                                                    Linear Transformation of vectors (using matrix F common for all rounds)
                                                                    (Input)4X4 X (F)4X4 = (Result)4X4
                                                                Add Round key
                                                                    XOR with 16 byte keys (unique for all round)
                                                                    4 bytes word- 4 words for every round.
                                                                LAST Round
                                                                    Skips mix columns step.
                                                            All Decryption Rounds
                                                                Inverse Shift Rows
                                                                    using the inverse function of encryption (same with others)
                                                                Inverse Substitution
                                                                Add Round Key
                                                                Inverse Mix Columns
                                                            #Why non-linear
                                                                why f(a+b) != f(a) + f(b)
                                                                if they are equal, they reveal far more information that available.
                                                            http://aesencryption.net/
                                                                tool to encrypt online- all 0s in plain text and 0s in key- yield non-zero output.
                                                        </AES>
                                                        <RSAAlgo>
                                                            (a mod n + b mod n) mod n = (a + b) mod n
                                                            (a mod n * b mod n) mod n = (a * b) mod n
                                                            (a mod n)^d mod n = a^d mod n
                                                            message in bit pattern- pattern is integer- message is encrypting a number.
                                                            select p and q large prime numbers
                                                            n=pq and z=(p-1)(q-1)
                                                                    based on number theory that if a and n are coprime then a^z = 1 mod n.
                                                                    PHI(n)= number of numbers from 1 to n which are coprime to n.
                                                            choose e (with e < n) that has no common factors with z (e,z are relatively prime)
                                                            choose d such that ed-1 is exactly divisible by z.
                                                                    ed mod z = 1
                                                            public key is (n,e) and private key is (n,d)
                                                                    to encrypt, c = m^e. mod n
                                                                            I love you will look like (on packets reader)- x?_#$bu- can't understand.
                                                                    to decrypt, m = c^d. mod n
                                                                    cuz m = (m^e. mod n).(m^d mod n)
                                                            If Private key is compromised, then should we go for a new modulus- n, p, q, etc?
                                                                ?No necessary- finding f1 and f2 s.t f1+1 and f2+1 are prime.
                                                                http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/private-key-compromised.htm
                                                            Why It Works - https://www.youtube.com/watch?v=EOhLZRwxaVo
                                                            How - https://www.youtube.com/watch?v=wXB-V_Keiu8
                                                        </RSAAlgo>
                                                        <SymmetricVsAsymmetric>
                                                            Asymmetric is not more secure- depends on the length of the key and the computational work
                                                            Symmetric is computationally less involved
                                                            Key distribution vs protocol (not more efficient or simpler)
                                                        </SymmetricVsAsymmetric>
                                                        <SymmetricUsingAsymmetric>
                                                        Symmetric included- computationally less involving
                                                            Alice generates random symmetric private key- sends by Kb+(Ks) and Bob gets Ks.
                                                            For message, Ks(m) is sent and Ks(Ks)(m) gets you m.
                                                                    both can be sent in one message
                                                        </SymmetricUsingAsymmetric>
                                                    </Interception>
                                                    <SecrecyFullPicture>
                                                        Secure email- secrecy, message integrity and sender authentication
                                                                Alice sends Ks(Ka-(H(m))) and Kb+(Ks) to bob.
                                                    </SecrecyFullPicture>
                                                    <IntegrityIssue>
                                                        <MessageDigest>
                                                                message with encryption- becomes costly- 2m units of data- affects network
                                                                Send x = H(m) s.t m is difficult to find.
                                                                    Find Hash Function of message m, H(m)
                                                                    Send m, H(m) to the receiver.
                                                                        can't intruder make it m',H(m')- still perfect!?
                                                                            Only if he can intercept the message!
                                                                            If doing without interception- he would insert, delete or modify bits
                                                                            Soln- Do encrypt the hash message, Kb-(H(m)) and send to receiver
                                                                    Alice receives it and does Kb+(Kb-(H(m))) = H(m) matches it with H(m) already has to verify.
                                                                message sent from Alice to Bob would be m, Ka-(H(m))
                                                        </MessageDigest>
                                                    </IntegrityIssue>
                                                    <AuthenticationProblem>
                                                        <PKI>
                                                            Public Key Certification- Certification authority
                                                                Spoofing- Trudy orders in the name of Bob- send me home.
                                                                        But signs it with her private key. Asked for authentication- sends her public key (in name of bob)
                                                                        Pizza sends pizza to Bob- Bob is flabbergast at the bill and doesn't like pizza.
                                                                A need for certification authority (CA) that binds Public key to a particular person.
                                                                        E (person, router) register its public key with CA
                                                                        CA create a certificate binding E to its public key.
                                                                        Certificate contains E's public key signed by CA.
                                                                        Kca-(Kb+) is sent (by ?Bob) to pizza owner who applies Kca+ to it.
                                                        </PKI>
                                                        <More>
                                                        Authenticate- prove that you are what you claim
                                                                Trudy may declare I am alice and get info of bob 
                                                                    (!Authenticate has led to !Confidentiality- not always)
                                                                    Important in bank and offices- phone call- I want to confirm my ....
                                                                <UsingIP>
                                                                IP address of Alice- sent along with message
                                                                        IPs may change over time (NATing, ARP)
                                                                        IP Spoofing by Trudy
                                                                </UsingIP>
                                                                <UsingPasswords>
                                                                Alice writes password along with her message
                                                                        Replay attack (even with encryption) records her packet and plays it back to bob.
                                                                        Encrypt the password and sent- again record it!
                                                                </UsingPasswords>
                                                                <UsingSymmetricKey>
                                                                        Nonce (once a lifetime R)
                                                                        Alice says "I am Alice"
                                                                        Bob tells Nonce (R) to Alice
                                                                        Alice encrypts R with Key K, sends (R, K(R)) to Bob
                                                                        Same key is used by Bob to decrypt
                                                                            K(K(R)) = R
                                                                        Now on, every message m is sent as K(m)
                                                                        How to shared key in first place?
                                                                </UsingSymmetricKey>
                                                                <UsingAsymmetricKey>
                                                                        Method
                                                                                "I am Alice" message arrives
                                                                                Bob sends Nonce (R) to Alice to encrypt
                                                                                Alice returns Ka-(R) to Bob.
                                                                                Bob requests public key of Alice (Ka+).
                                                                                Alice sends it      //You see the problem?
                                                                                Bob does Ka+(Ka-)R and gets R back so it's Alice only
                                                                        Security Hole- Man in Middle Attack
                                                                                message integrity- a message can be changed- I love you to I hate you.
                                                                                Trudy would send it's public and private with bob
                                                                                And relaying the packets and get access as follows
                                                                                A: I am Alice->
                                                                                        T: I am Alice->
                                                                                                <-B: Encrypt R (to T)
                                                                                        <-T: encrypt R
                                                                                A: Ka-(R)->
                                                                                        T: Kt-(R)->
                                                                                                <-B:Send public key
                                                                                        <-T:send me public key
                                                                                A: Ka+ ->
                                                                                        T: Ka+(Ka-)m = m
                                                                                           Kt+ ->
                                                                                                B: Kt+(Kt-)m = m; yes I am talking to Alice
                                                                                                   <- Henceforth, Kt+(m2) which Kt- can be done by trudy (and no1 else- Kb-(Kb+)m)to hack
                                                                                        T: I am Alice for Bob and Bob for Alice
                                                                        Public encryption key known to all. Private to receiver.
                                                                                Kb+ can't give any guess for Kb-
                                                                                RSA algo
                                                                </UsingAsymmetricKey>
                                                                <DigitalSignature>
                                                                Features- 
                                                                    Non-repudiation (sender can't deny)
                                                                    Verifiability (anyone)
                                                                    Non-forgeable (no1 else can- happy recipient)
                                                                        @Sign a doc- Why?
                                                                            I can't deny and no1 else can do it
                                                                            Declaration proof for world (or India) from me (I held accountable)
                                                                            Eg- I am 1 asking for money
                                                                            Bob will show Alice's check to Bank.
                                                                        Signed message by Bob- sends Kb-(sign), sign
                                                                                Alice does Kb+(Kb-)sign to get sign
                                                                                compare this with sign (also sent) to verify.
                                                                                knowing for sure that Bob is 1 sending eth.
                                                                                Non-forgeable- Kb+(Kt-)m != m
                                                                        Steps
                                                                                Alice sends (sign, Ka-(sign))
                                                                                Bob verfies- Ka+(Ka-) sign = sign == sign
                                                                                        Yes, it's alice only
                                                                                Bob can take m and Ka-(m) to court and prove that Bob signed m.
                                                                </DigitalSignature>
                                                        </More>
                                                    </AuthenticationProblem>
                                                </Cryptography>
                                                <Cryptanalysis>
                                                Cryptanalysis- analysing hidden writing to understand the original text.
                                                    difficulty PROPORTIONAL (information available)^-1
                                                    Eg- every 3rd letter is changed.
                                                    vs Brute force
                                                        Exhaustive trials are rarely practical cuz huge sample space.
                                                            on average 1/2 #keys trials reqd
                                                            success if lock opens or sensible in context.
                                                            #Algo- computational procedure and Protocol- uses algo for a strategy, language agreement for bigger plan.
                                                    Statistical analysis of cipher.
                                                    Making Secure
                                                        Computationally Secure- In best case, O(Big Polynomial)- rendered useless or less valuable after the result.
                                                        Provably Secure- NP Hard Algorithm needed to break it.
                                                        Unconditionally secure- even if you know it all- can't do much cuz of lack of information!
                                                </Cryptanalysis>
                                                <Cryptology>
                                                Cryptology- science of cryptography and cryptoanalysis.
                                                </Cryptology>
                                                <Steganography>
                                                Steganography- hiding even the existence of message
                                                    eg- hiding a picture inside a picture- by changing every pixel by 1 bit!
                                                        or hiding a message inside a picture in similar ways.
                                                    Eg- a normal oxford application, contains in message by reading the last word of every line.
                                                </Steganography>
                                                <Compression>
                                                Compression- minimizing size of a file
                                                    first minimize the size of file and then encryption cuz it's costly.
                                                </Compression>
                                            </terms>
                                    </Cryptography>
                                    <Strategies>
                                            <SecurityByObscurity>
                                                    Don't let ppl know details
                                                            but for communication- both gotta know for compatibility
                                                            widespread awareness and expertise of ppl.
                                            </SecurityByObscurity>
                                            <SecurityByLegislation>
                                                    Tell ppl how to behave- changing passwords
                                                            over the shoulder attack (some overlooks)
                                                            Knowing interests- guess wisely (likely to recur and trivialize with repetitions)
                                                            Social engineering- hey! (gossip) what's ur password- facing some prob here!
                                                            Still for someone gained access, change password discontinues.
                                            </SecurityByLegislation>
                                    </Strategies>
                            </Prevent>
                            <Detect>
                            Detect- realize wrong happening
                                    Eg- auditing and Intrusion Detection.
                                            logs maintained- who changed the system from what to what.
                                            Intrusion is detecting misuse and raising an alarm.
                                    @realize that gate is failing sw (not enough, etc)
                            </Detect>
                            <Correct>
                            Correct- recover from happened.
                                    Eg- Tolerance of system- functions in spite of failure.
                            </Correct>
                    </SecurityMeasures>
                    <SecurityAssurance>
                        How much Security to give?
                    </SecurityAssurance>
                </Subject3rdSem>
                <SlideNotes>
                <PublicKeyCryptography>
                        <Characteristics>
                                Not more secure
                                        depends on the length of the key and the computational work involved in breaking a cipher
                                doesn't make symmetric obsolete
                                        there's high computational overhead of public key encryption
                                        Inventor puts it- the restriction of public-key cryptography to key management and signature applications is almost universally accepted.
                                KDC not cumbersome in comparison
                                        they also involve central agents (protocol, procedures not more efficient)
                        </Characteristics>
                        <Evolution>
                                Key Distribution Problem- gotta share keys with KDC! it's a compromise
                                Digital Signature Problem- authentication (rather non-repudiation)- if it has to become mainstream we need equivalent of signatures on web.
                                Diffie and Hellman achieved a breakthrough- unprecedented.
                        </Evolution>
                        <PublicKeyAlgorithm>
                                uses asymmetric (complementary keys)
                                PKI- set of policies, processes, servers for administering keys and certificates.
                                Given k+, Algo- you can't tell k-.
                                Decryption Algorithm is related but not same.
                                being complementary- k+/k- can be swapped.
                                can always switch to k2+/k2- (just need to communicate k2+)
                                <FOE>
                                        A to B- generate kb+/kb- and Ka+/Ka- (assuming feasible)
                                        Encrypt data using kb+/Ka- and send over to other end (assuming feasible)
                                        decrypt data using kb-/Ka+ by B (assuming feasible)
                                        Adversary- may get Kb+, Cipher text- can't compute Kb-, Original Text (assuming infeasible)
                                </FOE>
                                <Requirements>
                                        Need of 1 way function- All FOE possible only with such fn.
                                                calculation of the function is easy, whereas the calculation of the inverse is infeasible
                                                Y = fk(X) Easy, X = fk^-1(Y) Easy, X = fk^-1(Y) infeasible if k is unknown.
                                                Here we gotta focus on best case time complexity for adversary and worst case for users.
                                                Infeasible means NP (or exponential)
                                </Requirements>
                                <Secrecy>
                                        <Confidentiality>
                                                A generates Ka+/Ka- and sends Ka+ to B.
                                                B sends Y = E(Ka+, X) to A
                                                Eve gets Ka+ and Y- can she determine X?
                                                There's no way- confidentiality.
                                                But not authentication- anyone could have encrypted it (Ka+ being public)
                                        </Confidentiality>
                                        <Authentication>
                                                A generates Ka+/Ka- and sends Ka+ to B.
                                                A sends Y = E(Ka-, X) to B.
                                                Eve gets Ka+, Y- can she determine X?
                                                Yes, she can using Ka+ (publically known)- so doesn't assure confidentiality
                                                But good for authentication- none other than Ka+ could have deciphered it- so A must have sent for sure!!
                                        </Authentication>
                                        <Best>
                                        Best of both worlds
                                                A -> Ka-(Kb+(M)) = M'
                                                        Ka- is also known as digital signature.
                                                B -> Ka+(M')=M" -> Kb-(M")
                                        </Best>
                                </Secrecy>
                                <Uses>
                                        Encryption/Decryption (generally not used)
                                                RSA, Elliptic Curve
                                        Digital Signatures
                                                RSA, Elliptic Curve, DSS
                                        Key Exchanges
                                                RSA, Elliptic Curve, Diffie Hellman
                                </Uses>
                                <Characteristics>
                                        Very slow
                                                vulnerable to a brute-force attack so gotta use large keys but speed demand smaller keys.
                                                Reduce probable message attack by adding random bits.
                                        Mathematically not proven that Kb- is impossible to calculate!
                                                history shows that an insoluble problem gets solution if perspective changes (a different way of looking at it)
                                </Characteristics>
                                <RSA>
                                        Is a cipher in which the plaintext and ciphertext are integers between 0 and n – 1 for some n
                                                A typical size for n is 1024 bits, or 309 decimal digits
                                        RSA scheme solved the Diffie Hellman challenge
                                        encrypted in blocks using following functions
                                                C = M^e mod n
                                                M = C^d mod n = (M^e)^d mod n = M^(ed) mod n
                                        sender gotta know public key (e,n) and receiver private key (d,n)
                                        <Assumptions>
                                                1. It is possible to find values of e , d , n  such that Med  mod n = M  for all M < n .
                                                        e = 65537, 3, 17
                                                                3 becomes too easy to decrypt
                                                        small values of d are vulnerable to brute force attack (so e is kept smaller)
                                                        Use Chinese Remainder Theorem- speeds up by four times.
                                                                M =(VpXp+VqXq) mod n
                                                                Define Vp=C^d mod p=C^(d mod (p-1)) mod p, Vq=C^d mod q = C^(d mod (q-1))  mod q
                                                                Define Xp=q* (q^(-1) mod p) and Xq=p*(p^(-1) mod p)
                                                                d mod (p -  1) and d mod (q -  1) can be precalculated
                                                2. It is relatively easy to calculate M^e  mod n  and C^d  mod n  for all values of M < n .
                                                        dealing with large exponents so efficiency important- algorithm
                                                        use the property- (a % n) * (b % n) % n = (a * b) % n
                                                        Also, x^16- successively forming x^2, x^4,..
                                                        Code- for computing a^b % n (b given in binary bk.bk-1....b0)
                                                                c = 0; f = 1;
                                                                for (i=k;i>=0;i--){
                                                                        c = 2*c;
                                                                        f = f*f%n;
                                                                        if(bi = 1){
                                                                                c++;
                                                                                f = f*a%n;
                                                                        }
                                                                }
                                                3. It is infeasible to determine d  given e  and n .
                                        </Assumptions>
                                        <FOE>
                                                A -> Select p,q primes
                                                n = pq, PHI(n) = (p-1)(q-1)
                                                        method used for finding large primes must be reasonably efficient (else given n- p,q are easy to crack)
                                                        Probabilistic techniques for finding prime numbers (passing a test- means maybe prime; failing means its not- P(E) can be taken to 1.0)
                                                Select e range [1,PHI(n)], s.t gcd(PHI(n),e) = 1;
                                                Calculate d = (d * e) % PHI(n) = 1
                                        </FOE>
                                        <KhanAcademy>
                                                Earlier shared key- extra key exchange overhead on diffie hellman
                                                different keys with each person (manage all of them)- 1000s of messages to establish
                                                Jimmy Alice (British) did it
                                                Clever Idea
                                                        Lock and Unlock are inverse operation- Alice sends open lock to e1- they will lock it (sth like auto locks- that don't require key (or separate key)) and send back- which only she can open
                                                        Benefit she will keep track of 1 key
                                                        He had intuition but not mathematical formulation
                                                        @How could Alice send Bob a color
                                                                Mixing color- assumed to be one-way function (fast to mix, slow to undo)
                                                                Her red mixed with Blue to get cyan- sent to Bob.
                                                                Bob's message Yellow- mixed with Cyan to send Greenish back.
                                                                Alice gets Greenish and knows her red- mixing gives her yellow (the message)
                                                                        (red + blue + green = yellow)
                                                                Eve has only cyan (red+blue) and green (= yellow + cyan)
                                                Clifford Cox came up with trap door function- easy one way- hard other way (without trap door)
                                                        m^e mod n = c
                                                        given c and n, can't find m.
                                                        MANY such m, trial and error.
                                                        easy with trap door- need some d- s.t m^(ed) mod n = m
                                                        without d, no1 can find out!
                                                        Euclid- Prime factorization is fundamentally hard problem
                                                                say 589- some trial and error b4 you realize 19 * 31
                                                                Imagine 437231 (you need a computer!!)
                                                                Think even bigger, even PC can't do it for you
                                                                        time grows to hours, days, years, centuries (growth rate increases)
                                                                N = P1 * P2 ( 2 primes)- this multiplication is pretty fast
                                                        Euler's PHI function
                                                                PHI(n) = Numbers <= n that don't share common factor with n
                                                                Eg- PHI(8) = 1,3,5,7 = 4
                                                                This calculation of PHI is hard except one case when n is a prime number
                                                                PHI(p) = p - 1 (only p is left out)
                                                                Eg- PHI(7) = 6
                                                                PHI(21377) = 21376 (cuz it's prime)
                                                                It was found- PHI(A*B) = PHI(A)*PHI(B) (A and B being prime)
                                                                        means N = P1*P2 => PHI(N) = (P1-1)*(P2-1)
                                                                        Eg- PHI(77) = 6 * 10 = 60
                                                                How to turn this into 1-way function (Euler's theorem (read Oiler's theorem))
                                                                        Find m and n s.t they don't share common factor
                                                                        m^(PHI(n)) =~ 1 mod n OR m^(PHI(n)) mod n = 1
                                                                        1. 1^k = 1
                                                                                m^(k*PHI(n)) mod n = 1^k = 1
                                                                        2. 1*m = m
                                                                                m*m^(k*PHI(n)) mod n = m
                                                                                m^(k*PHI(n)+1) mod n = m
                                                                                compare this to m^(ed) mod n = m
                                                                                Therefore, ed = k.PHI(n) + 1
                                                                                        (Question- there may be many such d's which will satisfy the equation- intruder has to find any such d (no!?))
                                                                Eg- p1 = 53, p2 = 59 => n = 3121 => PHI(n) = 3016
                                                                        find e s.t no factor with PHI(n) see eqn (obviously)
                                                                        find d as (2.PHI(n) + 1)/3 (this is private)
                                                                        send e,n (public key) to anyone asking for sending a message
                                                                        m = "HI" = 89 => c = 89^3 % 3127 = 1394
                                                                        Eve gets n= 3127, c = 1394, e = 3 but without d can't do anything
                                                                                d can be computed only if PHI(n) is known only if prime factorization of n is known (difficult problem)
                                                                                100s of years even with networks of computers (as per current understanding)
                                                                                Distribution of prime numbers through number space has remained a question thru history
                                                                        But Alice, 1394^2011 mod 3127 = 89 = "HI" (original message)
                                                                        Most widely used public key algo and most copied software in history!
                                                                        Every internet user uses- RSA without knowing about it.
                                        </KhanAcademy>
                                        <Attacks>
                                                Brute Force Attack- Keep d big.
                                                        use a large key space
                                                        Larger key but then slower system.
                                                Mathematical Attacks
                                                        Factor n into its two prime factors. This enables calculation of ø(n) = (p – 1) x (q – 1), which in turn enables determination of d = e-1 (mod ø(n))
                                                        Determine ø(n) directly without first determining p and q. Again this enables determination of d = e-1 (mod ø(n))
                                                        Determine d directly without first determining ø(n)
                                                        Eg- using GNFS, was able to factor a larger number than RSA-129 at only 20% of the computing effort.
                                                        2 Threats- 
                                                                the continuing increase in computing power 
                                                                the continuing refinement of factoring algorithms
                                                Timing Attack
                                                        snooper can determine a private key by keeping track of how long a computer takes to decipher messages
                                                        applicable to other cryptographical algos also
                                                        why alarming
                                                                It comes from a completely unexpected direction
                                                                It is a ciphertext-only attack
                                                        @burglar guessing the combination of a safe by observing how long it takes for someone to turn the dial from number to number
                                                        Solution- 
                                                                Constant Exponential time- Ensure that all exponentiations take the same amount of time before returning a result; this is a simple fix but does degrade performance
                                                                Random Delay- adding a random delay to the exponentiation algorithm to confuse
                                                                Blinding- Multiply the ciphertext by a random number before performing exponentiation
                                                                        prevent attacker from knowing- from knowing what ciphertext bits are being processed inside the computer
                                                                        Generate a secret random number r < n-1.
                                                                        Compute C’=C(re)mod n
                                                                        Compute M’=(C’)d mod n
                                                                        Compute M=M’r-1 mod n
                                                Fault Based Attack
                                                        Induces faults in the signature computation by reducing the power to the processor
                                                        The faults cause the software to produce invalid signatures which can then be analyzed by the attacker to recover the private key
                                                        worth consideration but not serious- requires physical access to machine.
                                                Chosen Ciphertext Attack (CCA)
                                                        Adversary chooses cipher and has target's plain text (after decryption)
                                                        Encrypt with public key and get plain text by decryption.
                                                        selects blocks of data that, when processed using the target’s private key, yield information needed for cryptanalysis
                                                        Solution- modifying the plaintext using OAEP.
                                                        OAEP- optimal asymmetric encryption padding 
                                        </Attacks>
                                </RSA>
                        </PublicKeyAlgorithm>
                </PublicKeyCryptography>
                <KeyManagement>
                        Term that refers to the means of delivering a key to two parties who wish to exchange data without allowing others to see the key
                        For symmetric encryption to work, the two parties to an exchange must share the same key, and that key must be protected from access by others
                        Frequent key changes are desirable to limit the amount of data compromised if an attacker learns the key
                        <Techniques>
                                <Manual>
                                reasonable requirement for link encryption device 
                                        1. A can select a key and physically deliver it to B.
                                        2. A third party can select the key and physically deliver it to A and B.
                                </Manual>
                                <DistributedSystem>
                                Distributed system- dynamic cuz changes and with many other hosts.
                                        3. If A and B have previously and recently used a key, one party can transmit the new key to the other, encrypted using the old key.
                                                <FOE>
                                                        A -> ID(A) + N1
                                                                Nonce to avoid replay attack.
                                                        B -> E(Km, Ks + ID(A) + ID(B) + f(N1) + N2)
                                                                agreed upon master key
                                                        A -> E(Ks, f(N2))
                                                                confirmation
                                                </FOE>
                                                <Analysis>
                                                        No dependence on trust on KDC
                                                        Not practical for larger networks (useful local contexts)
                                                                there may be need of n(n-1)/2 master keys for n systems.
                                                                each node maintains n-1 master keys- short messages diffl to decrypt
                                                </Analysis>
                                                <KeyDistribution>
                                                Simple Secret Key destribution
                                                        A -> PU(A) + ID(A)
                                                        B -> E(PU(A), Ks) = M
                                                        A -> D(PR(A), M) = Ks
                                                        Used when only threat is from eavesdropping (secure from that)
                                                        Key doesn't exist anywhere in communication (no compromise)
                                                        But Man In Middle Attack
                                                                PU(A) + ID(A)
                                                                        PU(D) + ID(A)
                                                                                E(PU(D), Ks)
                                                                        E(PU(A), Ks)
                                                                All share Ks.
                                                                ?I will say it was masquerade attack.
                                                        Solution
                                                                A -> E(PU(B), N1 + ID(A))
                                                                B -> E(PU(A), N1 + N2)
                                                                A -> E(PU(B), N2)
                                                                A -> E(PU(B), E(PR(A), Ks))
                                                </KeyDistribution>
                                                <Mechanisms>
                                                Public Key Distribution
                                                        <PublicAnnouncement>
                                                                append your public key to message
                                                                easy to forge- authentication issue.
                                                        </PublicAnnouncement>
                                                        <PublicallyAvailableDirectory>
                                                                dynamic (updated)- responsibility of organization
                                                                Directory for each participant- (name, public key) entry
                                                                In person/ (authenticated comunication) registration
                                                                        replace any time- private key compromised or securing large data
                                                                Participants query- authenticated communication mandatory
                                                                Weakness- adversary hacks into (availability/ private key obtained) directory authority => counterfeit public keys passed out & Impersonate anyone.
                                                                        or tampering the records (DOS)
                                                        </PublicallyAvailableDirectory>
                                                        <PublicKeyAuthority>
                                                                A -> Request || T1
                                                                PKA -> E(PR(auth), PU(B) || Request || T1)
                                                                        Assuming PU(auth) known to all.
                                                                A -> E(PU(B), ID(A) || N1) to B
                                                                B -> Request || T2
                                                                PKA -> E(PR(auth), PU(A) || Request || T2)
                                                                Cache the PU(A) and PU(B) and refresh for fresh copies periodically.
                                                                B -> E(PU(A), N1 || N2) to A
                                                                A -> E(PU(B), N2)
                                                                Drawbacks- bottleneck in system for n^2 possible keys.
                                                        </PublicKeyAuthority>
                                                        <PublicKeyCertificates>
                                                                Digital Certificates- associates public key with individual/ company
                                                                Eg- X.509
                                                                Eg- SPKI
                                                                        The Simple PKI is a movement to replace the specification for X.509 with something simpler. 
                                                                        X.509 relied on several global structures that made it difficult to implement it efficiently.
                                                                        One structure that SPKI tries to remove is the global name space, a feature intrinsic to X.509 and PGP.

                                                                <FOE>
                                                                        A -> PU(A)
                                                                        CA -> Ca = E( PR(auth), T1 || ID(A) || PU(A)) = ca-(a+(A)) OR E(PR(auth),PU(A))
                                                                        A -> Ca to B and vv.
                                                                </FOE>
                                                                <Analysis>
                                                                        Only CA can create and update certificates.
                                                                        Origin of certificate can be attested by ca+.
                                                                        any participant can send it. determines the name and public key of owner.
                                                                        Certificate != Signature
                                                                                Certificates are implemented using Signatures
                                                                        Certificates != Authentication
                                                                                Authentication can be implemented using Certificates
                                                                                Same for Authorization, etc.
                                                                </Analysis>
                                                                <Alertness>
                                                                        Security breaches
                                                                        <WarningsIgnored>
                                                                        Certificate not valid alarms, warnings ignored
                                                                                Verify the currency of certificate
                                                                                Certs are static- reissue on change
                                                                                <StagesOfCertificates>
                                                                                        <Initialization>
                                                                                        Initialization (Generation)
                                                                                                via RA- Identity verification (CP Docs)
                                                                                                        If online, should be protected + authenticated
                                                                                                Secret shared by user and CA (new or pre-existing relp)
                                                                                                        Key pair generation and backup
                                                                                                                //Dual key pair model- for authentication, confidentiality.
                                                                                                                Performance
                                                                                                                        Generation is slow on lappy; many smart cards now generate random numbers fast
                                                                                                                        centralized generation => bottleneck.
                                                                                                                Assurance
                                                                                                                        is random number by smart card good enough?
                                                                                                                        Security requirements should be guaranteed.
                                                                                                                Legal
                                                                                                                        who to sue on failure.
                                                                                                        certification creation and delivery
                                                                                                                Creation- CA only
                                                                                                                Distribution- Cert [+private key] (direct to owner OR depository)
                                                                                                                        Public Repositories- LDAP like directories, for confidentiality
                                                                                                                        In band- eg- signed email (carrying cert)
                                                                                                                Back up
                                                                                                                        Escrow != Backup
                                                                                                                                Backup- only owner can retrieve the (lost) key
                                                                                                                                Key Escrow- A copy of your private key is kept in the agency
                                                                                                                                        optional (US necessitated once)	- org/govt can retrieve key against owner's wish.
                                                                                        </Initialization>
                                                                                        <Issuance>
                                                                                                Certificate Retrieval- to encrypt message or verify signature
                                                                                                Certificate validation
                                                                                                Key recovery- automate as much as possible.
                                                                                                Key update- new certs when keys expire.
                                                                                        [Usage (active)]
                                                                                        </Issuance>
                                                                                        <Cancellation>
                                                                                                Expiration- Natural "peaceful" end of life
                                                                                                        No action
                                                                                                        Renewal- same keys/certs (new dates) 
                                                                                                                (automatic)
                                                                                                                Attribs may change
                                                                                                        Certs update
                                                                                                                New Keys/certs
                                                                                                Revocation- untimely death (dangerous causes)
                                                                                                        Requested by- owner, employer, etc
                                                                                                        Request to- RA/CA
                                                                                                        Mechanisms for revocation checks
                                                                                                                CRL- Certificate Revocation Lists
                                                                                                                OCSP- Online Certificate Status Protocol
                                                                                                                Revocation delay- as per policy.
                                                                                                Key Archive- for public audit, disputes, old signatures
                                                                                                        Key history- for owner to read old encrypted messages
                                                                                        </Cancellation>
                                                                                </StagesOfCertificates>
                                                                        </WarningsIgnored>
                                                                        <Attested>
                                                                        Valid signature by trusted CA, consistent usage with policy
                                                                                <PublicationMechanisms>
                                                                                        Complete CRL
                                                                                                Self Contained, simple, complete
                                                                                                Probs
                                                                                                        Scalable- CRL may grow too big
                                                                                                        Timeliness- from CRL size
                                                                                                        => apt for some domains
                                                                                                Partitioned- partition CRL into smaller chunks
                                                                                                        Static (cert points to CRL Distribution point)
                                                                                                        Dynamic- Enhanced/Redirect CRL DP (Cert points to this and this directs to proper CRL partition)
                                                                                                Delta
                                                                                                        complete CRL issued once a week, and a new DeltaCRL (containing the previous DeltaCRLs) issued every day
                                                                                                Indirect
                                                                                                        combines CRL of many CAs
                                                                                                CRT- Certificate Revocation Trees
                                                                                                        Construct Hash trees with leaves as certs
                                                                                                        root being sign- path from the certificate to root
                                                                                        ARL- Authority Revocation List
                                                                                                = CRL for CAs 
                                                                                                (Rare- compromised, decommissioned)
                                                                                        White list/ black lists.
                                                                                </PublicationMechanisms>
                                                                        </Attested>
                                                                </Alertness>
                                                                <VizCA>
                                                                        Issuer of cert
                                                                        <EnterpriseCA>
                                                                                <Factors>
                                                                                        Functionality based on modular design- including reliability, performance, lifecycle mgmt, key mgmt, etc.
                                                                                        Integration- new and legacy apps to be compatible- minimize costs by leveraging investment.
                                                                                        Availability- round the clock to user community
                                                                                        Scalability- must scale to millions of users to keep with enterprise growth
                                                                                        Risk mgmt- preverse trust, minimize financial, legal liability by safeguarding private keys, infrastructure
                                                                                        Expertise- security professionals extensively trained in PKI to ensure proper deployment, maintenance, protection
                                                                                </Factors>
                                                                                <DeploymentModels>
                                                                                        In-house- deployment of standalone PKI software
                                                                                                100% responsibility for provisioning, deploying, and maintaining the PKI
                                                                                                also resp for all the surrounding technology, including systems, telecommunications, and databases
                                                                                                A secure facility must have physical site security, Internet-safe network configurations, redundant systems, disaster recovery, viable PKI legal practices, financially sound liability protection, and highly trained personnel
                                                                                                Any1 weak => maybe compromised
                                                                                        Outsourced- deployment to an integrated PKI platform
                                                                                                enterprise delegates PKI construction, deployment, and maintenance to a trusted third party 
                                                                                                whose services include certificate processing, root key protection, and security and risk management.
                                                                                                Eg- Verisign's managed PKI
                                                                                                        Enterprise does key mgmt services and Verisign center does key recovery service
                                                                                                        CA, RA Control Center in enterprise connect iwht certificate manager at Verisign.
                                                                                        Managed vs Standalone PKI
                                                                                                PKI functionality
                                                                                                Ease of integration
                                                                                                Availability and scalability
                                                                                                Security and risk management
                                                                                                Personnel
                                                                                                Scope of operation
                                                                                </DeploymentModels>
                                                                        </EnterpriseCA>
                                                                        <Individual>
                                                                        Individual as CA (PGP)
                                                                        </Individual>
                                                                        <Global>
                                                                        Gobal or Universal CA
                                                                                VeriSign, Equifax, Entrust, CyberTrust, Identrus
                                                                        </Global>
                                                                        <TrustModels>
                                                                                <WhoTrusted>
                                                                                Who to trust?- which cert can be trusted
                                                                                        A trusts B- A assumes B will behave exactly as A expects
                                                                                                vs expects
                                                                                        X trusts CA- CA will establish and maintain accurate binding (keys binding, security) of attribs (with PK)
                                                                                                X is convinced the PK corresponds to SK which legitimately and validly belongs only to a specific named entity
                                                                                </WhoTrusted>
                                                                                <Source>
                                                                                Source of trust- how it gets established
                                                                                </Source>
                                                                                <viz>
                                                                                        CAHierarchy
                                                                                                Single Root CA- parent CA certifies children CA (subordinate)
                                                                                                Leaves are non-CA entities
                                                                                                a node can certify CA or end-entities (not both)
                                                                                                PEM (privacy enhanced mail) adopted but failed, DoD could use fine
                                                                                        Distributed
                                                                                                PKI Networking- a set of independent hierarchies cross certifying
                                                                                                Fully-meshed- all CAs are cross certified
                                                                                        Web
                                                                                                A bunch of root CAs (modifiable) pre-installed in browsers
                                                                                                Browser manufacturer = implicit Root CA
                                                                                        UserCentric
                                                                                                PGP
                                                                                                User has her own root CA- webs of trust
                                                                                                        user fully responsible for trust
                                                                                        Tool
                                                                                        CrossCertification
                                                                                                Certificate for CAs- not end entities
                                                                                                CA1 certifies CA2 and/or vv.
                                                                                                Control- limits trust.
                                                                                </viz>
                                                                                <CertificatePath>
                                                                                        Alice trusts CA1- has its PK in browser
                                                                                        CA1 certifies CA2 certifies CA3 certifies Bob
                                                                                        => Alice trusts Bob- Associates PK in Bob's cert with Bob.
                                                                                        Processing
                                                                                                Path Construction- Aggregation of necessary certificates.
                                                                                                        Shortest Path graph algo- graph not known (edges are queried)
                                                                                                Path Validation- Checking certs and keys (steps of cert validation)
                                                                                </CertificatePath>
                                                                        </TrustModels>
                                                                </VizCA>
                                                                <OtherRoles>
                                                                        RA is secretary, administrative assistant to CA (takes some work off)
                                                                                Front end interaction- you provide them info (confirms identity doc for CA)
                                                                                User key generation/distribution.
                                                                        CRL- certificate revocation list- that no longer can be used
                                                                                expired, compromised private key, (HR/ company decisions)
                                                                                certificate owner/ admin can request cert be revoked (private key is lost!!)
                                                                        Recovery Agent- (KRI- Key Recovery Information)
                                                                                if key is lost (like your system crashed), ask them.
                                                                                it's an actual person there.
                                                                </OtherRoles>
                                                        </PublicKeyCertificates>
                                                </Mechanisms>
                                                <DiffieHellmanKeyExchange>
                                                        @Color- not exactly cuz we can subtract colors (but helps in understanding)
                                                                Secret color- trick that easy to mix 2 colors to make third but given a color can't tell its components
                                                                        one-way function- easy in 1 direction- difficult in other.
                                                                        they decide their public colors (known to eve) and mix them with their secret private colors
                                                                                their private colors are hidden in the mixture- both send this is each other (known to eve)
                                                                        add their private color and arrive at third secret color- same for both ( = public color + the 2 private colors)
                                                                        Knowledge with eve- public color + 2 mixture colors (challenge- find out the private components from mixture- given the public one)
                                                        Finalize agreed key betw 2 without Eve knowing it who is always listening
                                                        <MathsTrick>
                                                                46 mod 12- encircle rope of 46 length and check mins it runs ahead of 12.
                                                                find a prime number- 17
                                                                Find a primitive root of 17- 3
                                                                3^k mod 17- distributes uniformly over 1,16.
                                                                        generate all integers from 1 to p-1 in some permutation
                                                                3^x mod p = r all are equally likely
                                                                        reverse procedure is hard.
                                                                        if r = 12, find x? This is discrete logarithm problem.
                                                                        have to use trial and error- easy with small numbers but big prime numbers (1000 years)
                                                        </MathsTrick>
                                                        <FOE>
                                                                A and B decide 3 and 17 as public (common)
                                                                A has private 15- computes- 3^15 mod 17 = 6 publically sent to bob.
                                                                B has 13- 3^13 mod 17 = 12
                                                                A = 12^15 mod 17 = 3^13*15 mod 17
                                                                B = 6^13 mod 17 = 3^15*13 mod 17
                                                        </FOE>
                                                </DiffieHellmanKeyExchange>
                                </DistributedSystem>
                                <ThirdParty>
                                        4. If A and B each has an encrypted connection to a third party C, C can deliver a key on the encrypted links to A and B.
                                                <FOE>
                                                        A to KDC- ID(A)+ ID(B) + N
                                                                Nonce to avoid Replay attack.
                                                                ?Any C can say ID(A) + ID(B) + N
                                                        KDC to A- E(Ka, Ks + ID(A)+ ID(B) + N) + E(Kb, Ks + ID(A)) to A
                                                                Ka being master key of A (shared with KDC)
                                                                Kb being master key of B.
                                                                A gets Ks.
                                                                Why ID(B)- for KDC to know which 2 share Ks (Kb accoringly)- can be reused.
                                                        A to B- E(Kb, Ks + ID(A))
                                                                KDC declares to B that A giving you Ks
                                                                B has Ks
                                                        B- E(Ks, N)
                                                                Prove you have Ks
                                                        A- E(Ks, f(N))
                                                                Proven
                                                </FOE>
                                                <AutomaticKeyDistribution>
                                                        A -> SSM (Security Service Module (Protocol Layer)) -> Ka(Request) to KDC.
                                                        KDC Approves -> Ks sent to A and B
                                                        A -> Ks -> B.
                                                </AutomaticKeyDistribution>
                                                <SessionKeyLifetime>
                                                        Connection oriented- use same session key for the length of time (connection open to close)
                                                                change for each new session (PDU (Protocol Data Unit) sequence number cycles)
                                                        Connectionless- no initiation, termination- not obvious how often to change.
                                                                more frequent is secure- less cipher text for intruder.
                                                                but key exchange is burden on network capacity.						
                                                </SessionKeyLifetime>
                                                <Hierarchy>
                                                        local domain => Local KDC
                                                        different domains => Global KDC communicated by local KDCs.
                                                        minimizes the effort of master key distribution (?reusing)					
                                                </Hierarchy>
                                                <SessionKeyTypes>
                                                Diffn session key types
                                                        Data Encryption key for general commn
                                                                Km(Ks) is known. Ks(D) is known
                                                                ?If Km(D') then Ks can be known.
                                                        PIN- for funds transfer, POS
                                                        File encryption, for publicly accessible location.
                                                        Key Controls (tags)
                                                                DES Key(56+8tag)- tag encrypted along with key
                                                                tag len <= 8 bits; only decryption => limited use
                                                                1 bit whether key is session or master
                                                                1 bit for encryption; 1 for decryption
                                                                others for future use
                                                        vs Control Vector
                                                                every session key has associated control vector (fields to specify uses and restrictions)
                                                                coupled at the time of key generation at KDC.
                                                                decrypted by user using master key and control vector.
                                                                advantages- any size- enables complex controls imposed on key use.
                                                                        ?control of key use can be exercisec in many locations.
                                                </SessionKeyTypes>
                                                <HybridScheme>
                                                        Simple Secret Key Distribution + KDC
                                                        IBM Mainframes- KDC usage retained similarly.
                                                        public key scheme is being used to only update master key with KDC.
                                                                Performance- cuz of computation load of frequent session key changes.
                                                        Backward compatible- overlaid on an existing KDC scheme (no disruption/ s/w changes)
                                                </HybridScheme>
                                </ThirdParty>
                        </Techniques>
                </KeyManagement>
                <PKI>
                        Try solving with symmetric techniques (possible) but see problems
                        make assumptions and trusted parties explicit
                        Subscriber's cert policy
                                CA, RA, Relying party, Repo
                </PKI>
                <HashFunctions>
                        Objective is integrity
                                aka Message authentication (different from user authentication)- no CRUD on message or replay of message.
                        Message Digest- when hash function is used to provide message authentication
                                Variable length Message M to fixed length hash value h (evenly distributed and random (all equally probable))
                                H(M) = h
                                One way property- given h, can't find M (data object) mapping to h.
                                Collision Free Property- finding M' s.t H(M) = H(M') = h
                                Purpose if M is changed, there is high probability that H(M') will yield result different from H(M)
                                Adding length padding field to increase difficulty to produce an alternative message for same hash value.
                                Hash code provides redundancy for integrity.
                        Problem
                                Man in middle attack
                                        Darth gets M,H(M)- modifies to M', removes H(M) and adds his own H(M') and sends to Bob
                                        Bob gets M', H(M')- computes H(M') and finds its same as hash H(M')
                                        Bob thinks nothing changed in the message!
                                        We want it infeasible for adversary to alter hash value.
                        Strategies
                                Send E(K,(M || H(M)))
                                        Other side applies D, finds H(M) and compares with H(M)
                                        ?K being shared session key
                                Send M,E(K,H(M))
                                        Other side decrypts Hash and finds H(M) to compare
                                        can be used to unburden when apps don't need confidentiality.
                                                Encryption is costly in money (license), infrastructure (hardware) and time (to encrypt)
                                Send M,H(M||S)
                                        Other side concatenates S and applies Hash function to compare
                                        Secret Value S won't allow modification.
                                Send E(K,M||H(M||S))			
                                        Meant to add confidentiality to previous case.
                        MAC (Message Authentication Code)
                                aka keyed hash function
                                Input- Secret key, Data block
                                Output- Hash Value (MAC)
                                Trick- without Secret key, no1 can alter the input data block changing or keeping with hash value
                                Encrypt output with user's private key- anyone can confirm that it's A's message unchanged (using A's public key)
                                        Digital Signature Benefit- Encrypting smaller text for user authentication is much better than full message!
                                                Anyone who knows the user’s public key can verify the integrity of the message
                                        Strategy-
                                                A sends M || E(PR(A), H(M)) and B applies hash on M and decryption on hash.
                                                A sends E(K, M || E(PR(A),H(M)))
                                                        and B decryption and then hash on M and decryption of hash using PU(A)
                        Other uses of Hash functions
                                1 way password file
                                        our passwords are not saved as is but its hash (cuz files can be tampered, intercepted)
                                        when user enters password, it's compare with the hash
                                        most OS use this technique
                                        gotta be preimage resistant (can't find P s.t H(P) is in file)
                                Can be used for intrusion and virus detection
                                        Store H(F) for each file on a system
                                        Secure the hash values
                                        Determine file modification by recomputing H(F)
                                        An intruder would need to change F without changing H(F)
                                        gotta be second preimage resistant (changing file to another config to maintain H(F))
                                used to construct a pseudo Random (function/ Number generator)
                                        PRF/ PRNG
                        viz
                                Bitwise XOR
                                        take block (bi) of n-bit size
                                        Ci = bi1 XOR bi2 XOR ...bim
                                        produces parity known as longitudinal redundancy check
                                        reasonably effective
                                                probability that a data error will result in an unchanged hash value is 2^–n
                                                Actually lesser cuz high order bit for normal text is generally 0.
                                1 bit Circular shift on hash after each block
                                        randomizing the input
                                        practically useless cuz producing M' to give same hash is easy.
                        Properties
                                Preimage- a given hash (eg- mod) has many preimages (being many to 1 function)
                                Collision- if x != y but H(x) = H(y)
                                        weak collision resistance- for given x, we can't find y != x s.t H(y) = H(x)
                                                aka second preimage resistance
                                                given M, find H(m) and generate M' s.t result is H(m) which is encrypted.
                                        strong collision resistance- can't find any (x,y) s.t H(x) = H(y)
                                                Alice signs M and generates H(M), Bob find M' to keep H(M') 
                                variable input, fixed randomized output and efficient other operations
                                MAC and hash and digital signature all require all 3 properties
                                        hash + symmetric doesn't need any property.
                        Attacks
                                Brute force attach- depends on bit length- try all values at random until a collision occurs
                                        Preimage and second preimage attack- to find y s.t H(y) = h try all 2^(m-1) values of y for m-bit hash
                                        Collision Resistant attack- find (x,y) s.t H(x)= H(y)
                                                simple due to birthday paradox
                                                choosing same numbers exceeds 0.5 after sqrt(N) choices are made.
                                                so Probability > 0.5 after 2^(m/2) are tried out, there is a chance of getting a collision (this can be misused somewhere)
                                                x || E(Pr(A), H(x)) -> generate H(x') variants of x.
                                                y || E(Pr(A), H(y'))-> generate of H(y') s.t H(x') = H(y')- same encryption so Digital sign compromised
                                Cryptanalysis- exploit some weakness (property) of algo to perform attack
                                    there has been success in this so need for revision
                                    iterated hash function
                                        Input partitioned into L blocks of b bits (last padded)
                                        The length of the total input is also hashed (added difficulty in attack)
                                            gotta find 2 messages of same length for hash to be same.
                                        Compression function for all the L blocks
                                            inputs
                                                b bits of the block
                                                n bits of chaining variable (IV initial value)
                                            outputs
                                                n bits CV for next block.
                                                Use final block as the hash value
                                                64-bit hash is too small for birthday attack and meet in middle.
                                    MD2
                                        refer to slides
                                    MD4 Family
                                        MD5 is broken.
                                        SHA1- Secure Hash Algorithm
                                            revised in 1995.
                                            based on design of MD4
                                            hard to find collision but likely to change soon.
                                                100s of implementations on SHA1 on web.
                                            produces 160 bit hash (NIST revised in 2002- 256, 384, and 512 bits)
                                                new versions have the same underlying structure and use the same types of modular arithmetic and logical binary operations
                                            Shortly thereafter, a research team described an attack in which two separate messages could be found that deliver the
                                                same SHA-1 hash using 2^69  operations, far fewer than the 2^80  operations previously thought needed to find a collision with an SHA-1 hash
                                                This result should hasten the transition to SHA-2.
                                            Overview
                                                very high level view
                                                    x bits to 160 bit output
                                                high level view
                                                    x = (x1x2....xn)
                                                    Padding
                                                    Compression Func
                                                        repeated over all xi in a cycle.
                                                        (Xi + Hi-1 => Hi)- conceive of message as key and key as message for AES
                                                            Not subkey schedule but message schedule
                                                            generated 80 Wi (32 bit each) from Xi (512 bit)
                                                            There's a feedforward from (5*32 bit)Hi-1 to result after round 79- binary addition mod 2^32 (ignore last carry)
                                                            St 80 rounds are divided into 4 stages.
                                                        512 + 160 => 160 for next cycle
                                                        160 bits output.
                                                        Operations
                                                            Insides of the rounds
                                                                Recall fiestel Network
                                                                This is unbalanced Fiestel Network
                                                                    b,c,d into func (for stage t) and added to E, get E1
                                                                        f1,f2,f3, f4 (s-box, etc)
                                                                        f(B,C,D) = (B AND C) OR (B' AND D)
                                                                        f(B,C,D) = (B XOR C XOR D)
                                                                        f(B,C,D) = (B AND C) OR (B AND D) OR (C AND D)
                                                                        f(B,C,D) = (B XOR C XOR D)
                                                                    A cylic rotated by 5 positions and added to E1, get E2
                                                                    Add E2 to Wj (Message for the round), get E3
                                                                    Add E3 to round constant, Kt, get E4
                                                                        k1,k2,k3,k4- values specified in table
                                                                    E4 becomes A for next round
                                                                    A becomes next B
                                                                    B with 30 left shifts (or 2 right) becomes next C.
                                                                    C becomes next D
                                                                    D becomes next E
                                                            Insides of the message schedule
                                                                Message block Xi of size 512 to be split to W0,W1,...W79 (of size 32)
                                                                Wj = Wj-16 XOR Wj-14 XOR Wj-8 XOR Wj-3 for 16 <= j <= 74
                                                                    = Xij divide Xi into 16 equal parts for 0 <= j <= 15

                                        SHA2 is more secure. Similar to SHA1- just a slight generalization.
                                    SHA3- refer to slides
                                    MAC- Message Authentication Codes
                                        From Christof Paar (but not of Slides)
                                        aka Cryptographic Checksums
                                        Motivation- Recall for digital Signature- B.Sc (Coming from right source-sign)
                                            For symmetric- m = MAC(x) with k as key. and sent (x,m) to Alice which can recompute and compare.
                                        Properties- 
                                            arbitrary input lengths
                                            Fixed output lengths 
                                            Message Authentication- being sure that coming from a person???
                                            Integrity- Manipulations in transit will be detected by Alice.
                                            Non-repudiation- not given- message could have been generated by other member of key (alice)
                                        MAC from Hash functions
                                            Basic Idea m = MAC(K,x) = h(K,x) (how to mix K and x- some function!!- say concatenation first)
                                            Ideas
                                                m = H(K || x)- secret prefix
                                                    x = (x1 || x2 ||....||xn) of size like 512 bit
                                                    = H(K || x1 || ....||xn)
                                                    Man in the middle attack
                                                        Bob sends (x,H(k,x)) to Alice intercepted by Oscar.
                                                        Oscar adds xn+1 block to the message
                                                            computes Mo = H(Xn+1) using IV = m and sends Xo and Mo to Alice
                                                                why cuz result of all previous hashes = m and that goes into next loop.
                                                        Alice in her nice world does m = H(K||x1||...xn+1) == Mo
                                                        Remark: Attack doesn't work if padding with length information is being used.
                                                            cuz message becomes greater than expected.
                                                m = H(x || K)- secret suffix
                                                    Assume Oscar can find collisions, i.e- H(x) = H(y)- tranfer 10 $ to Oscar vs 10K $ to Oscar.
                                                        then H(x||K) = H(y || K)- attack is easier. He can blindly replace x by y.
                                                        But collision finding is not sth done on sunday afternoon over coffee.
                                                        Compare brute force effort with collision finding effort
                                                            SHA1, K = 128 bit; we expect attack complexity of 2^128- lifetime of universe. (start ur counting (with PC))
                                                            Birthday Paradox- collision takes sqrt(2^160) = 2^80 steps.
                                                    Not very effective.
                                                HMAC Construction
                                                    proposed in 96. widely Used in practice (eg- TLS/SSL)
                                                    Idea- Use 2 nested secret prefix MACs.
                                                        roughly- H(K,x) and then again- H(K||H(K||X))- inner hash and outer hash
                                                        in reality- HMAC(K,X) = H((K+ XOR OPAD || H(K+ XOR IPAD ||X)))
                                                            Outer Hash- H(K+ XOR OPAD)  //expand the key
                                                                K+ = 00...00 || K (hash input length eg- 512 from 128)
                                                            Inner Hash- H(K+ XOR IPAD)
                                                                InnerPad = 0011 0110, ..., 0011 0110
                                                                OuterPad- 0101 1100, ..., 0101 1100
                                        From Slides

                                    Many others
                </HashFunctions>
                </SlideNotes>
                <More>
                    <SnoopingTerms>
                            Sniffing = Snooping
                                    listening to a conversation. 
                                    w/o encryption- our credentials can be captured.
                                    Sniff your own packets thru wireshark.
                            Spoofing = Masquerade
                                REL Pretending to be someone else. 
                                    REL Movie Spoof, Phone call by Modi.
                                What
                                    introducing network traffic pretending to be 7 else.
                                    REL send command to PC A saying I am B (which I am not)
                                    malicious party impersonates another device or user on a network
                                    Eg- email spoofing, 
                                Why
                                    in order to launch attacks against network hosts, steal data, spread malware or bypass access controls
                                    DDOS- To block terrorists recruitments, watch world burn, gamers getting edge against opponents (Need updation)
                                        Early days- Ransom- pay amount or your network will go down. Microsoft machines improved => vulnerable PCs. Bandwidth of internet improved.
                                        AttackTypes
                                            Bandwidth Depletion
                                                Flood Attack- TCP, UDP, ICMP
                                                    UDP Flood Attack
                                                        Attacker sends large number of UDP packets to a victim system, due to which there is saturation of the network and the depletion of available bandwidth for legitimate service requests to the victim system.
                                                        The victim system on receiving a UDP packet will try to determine the waiting application on the destination port. When there is no application waiting on the port, it will generate an ICMP packet of destination unreachable to the forged source address. If UDP packets being delivered to ports of the victim are large the host resources will be sapped which will lead to inaccessibility.
                                                        In a UDP flood attack, the attacker can also spoof the IP address of the packets. As a result, the return ICMP packets will not reach their host, thereby anonymizing the attack. There are a number of commercially-available software packages that can be used to perform a UDP flood attack (e.g., UDP Unicorn).
                                                    HTTP Flood Attack
                                                        In incomplete HTTP Flood attack using the GET method, Client sends just a part of the HTTP header and never sends the complete header. Client continues to send subsequent headers at regular intervals to keep socket alive. By sending multiple incomplete requests the server’s resources get exhausted. These requests consume all the available resources on the server, thereby denying the legitimate users’ requests.
                                                        Incomplete HTTP Flood attack using the POST method is the same as the GET method except in this, the client sends incomplete HTTP requests with the help of POST method instead of GET method.
                                                Amplification Attack- Smurf, Fraggle
                                                    ICMP Smurf- In a smurf attack the victim is flooded with ICMP echo-reply packets. It uses IP broadcasting in which when a packet is sent to an IP broadcast address on the network that packet is delivered to all machines in the network.  The attacker broadcasts spoofed packets Each node responds back to the victim machine since the source IP address is spoofed as that of the victim’s address. 
                                                    However smurf attacks are not effective under IPv6 as when a node receives a packet in IPv6 with a link layer broadcast address it doesn’t generate a response.
                                            Resource Depletion
                                                Protocol Exploit Attack
                                                    TCP SYN Attack
                                                        When a client attempts to establish a TCP connection to a server, the client first sends a SYN message, the server then acknowledges by sending SYN-ACK message to the client. The connection will be completed when the client responds with an ACK message.
                                                        At half open state the memory will not be released until until the server receives final ACK message or half-open connection expires. In this attack the client never sends the ACK message instead floods with  TCP SYN packets faster than the expiration rate of half-open connections.
                                                    Push + ACK Attack
                                                Malformed Packet Attack
                                                    A Ping of Death attack is a type of attack on a computer that involves sending a malformed or malicious ping to a target computer.
                                                        A ping is normally 64 bytes in size, many computer systems cannot handle a ping larger than the maximum IP packet size, which is 65,535 bytes, which lead to crashing of the system.
                                        Amplification attack- poor computer's IP is used to request details of last 600 users who asked for time- done by bots- crazy result!!
                                        Slow down other system- constant pinging
                                            @Asking driver constantly- Are we there yet?
                                        Phases of Attack
                                            1. Selection of agents. The attacker chooses the agents that will perform the attack. These machines need to have some vulnerability that the attacker can use to gain access to them. They should also have abundant resources that will enable them to generate powerful attack streams. At the beginning this process was performed manually, but it was soon automated by scanning tools. 
                                            2. Compromise. The attacker exploits the security holes and vulnerabilities of the agent machines and plants the attack code. Furthermore he tries to protect the code from discovery and deactivation. Self-propagating tools such as the Ramen worm [11] and Code Red [12] soon automated this phase. The owners and users of the agent systems typically have no knowledge that their system has been compromised and that they will be taking part in a DDoS attack. When participating in a DDoS attack, each agent program uses only a small amount of resources (both in memory and bandwidth), so that the users of computers experience minimal change in performance.
                                            3. Communication. The attacker communicates with any number of handlers to identify which agents are up and running, when to schedule attacks, or when to upgrade agents. Depending on how the attacker configures the DDoS attack network, agents can be instructed to communicate with a single handler or multiple handlers. The communication between attacker and handler and between the handler and agents can be via TCP, UDP, or ICMP protocols.
                                            4. Attack. At this step the attacker commands the onset of the attack. The victim, the duration of the attack as well as special features of the attack such as the type, length, TTL, port numbers etc, can be adjusted. The variety of the properties of attack packets can be beneficial for the attacker, in order to avoid detection
                                        (MORE- Refer to slides of Network Security- they are good)
                                How
                                    Types (how it works)
                                        IP Spoofing
                                            What
                                                introduce a packet with source address of 7 else.
                                                most frequent- attacker sends IP packets from false (spoofed) source address to disguise himself.
                                                overload networks => DOS; 
                                                    Types- Amplification, Smurfs, nukes, teardrops
                                                    More serious problem as IOT strenghtens BOTNETs also.
                                            Why
                                                No suspicion- appeared from legitimate source IPs. new song there is gonna be high demand
                                                Used to bypass authentication- primarily used in trust based relp which use IP and not logins for identity.
                                            How- uses botnet- attacker (controller) creates a network of PCs (zombie machines- remote controlled thru some malware) to overwhelm victim with traffic. Handshake then spam dest causing ICMP error to be sent. 
                                                2 ways-
                                                flood the selected target with pkts from many spoofed IP- more than victim can handle.
                                                spoof target's IP address and send pkts from that to diffn recipients- who will respond back to original.
                                        DNS Spoofing- 
                                            What- Directing Packets to your IP from victim using DNS.
                                            Why- steal credentials. Infect victim (user) by viruses, malwares.
                                            How- 
                                                DNS- associates domain names with IP addresses, Replace mapping of Target's Domain name with Attacker's IP.
                                                => DNS look up returns attacker's IP which becomes destination IP for packets.
                                        ARP Spoofing- 
                                            What- Steal packets from neighbors by pretending to possess an IP
                                            Why- ARP spoofing to steal information, modify data in-transit or stop traffic on a LAN
                                                facilitates DOS, sessional hijacking, MITM.
                                            How
                                                ARP used to resolve IP addresses to MAC (Media Access Control) addresses for transmission.
                                                Malicious party sends spoofed ARP messages across a local area network in order to link the attacker’s MAC address with the IP address of a legitimate member of network.
                                                => data that is intended for the host’s IP address getting sent to the attacker instead
                                    Solution (how stop it)
                                        Packet filtering- pkts from outside showing inside address and vv filtered.
                                        Avoid trust relp- use logins.
                                        Spoofing Detection software- programs work by inspecting and certifying data before it is transmitted and blocking data that appears to be spoofed
                                        Cryptographic protocols- TLS, SSH, HTTPS- bolster prevention by encryption and authentication.
                                        Campaign against Relay amplification vectors who send spams (email from websites, etc)
                    </SnoopingTerms>
                    <WifiSecurity>
                        Web credentials are more valuable than any home valuable.
                            Data unsecure over wireless transit- interception can be costly.
                            Wifi which uses no password- any attacker can see your everything. No hacking reqd- simple prgms exist.
                        Hotspots must have passwords- Internet connection owner is liable for cyber crimes committed thru unsecure access point by law.
                        Earlier in 90s all routers had WEP (Wired Equivalency Privacy) standard. But fell apart with increase in computing power (in minutes)
                            WPA (Wifi protected access) came with longer encryption keys. TKIP- Temporal Key Integrity Protocol which keeps changing keys over time and protects against forged/altered packets.
                                came at a cost of firmware and WEP parts made it vulnerable and device interconnection sucked. 
                            WPA2 is currently used by WiFi- compulosry since 2006 if uses WiFi logo. 
                                WPA2 uses AES- 100s of years for 12 char to break.
                                Beware of public wifi networks. Even best of encryption can't protect if wifi router is malicious.
                                anyone who connects b4 you can view your handshake => encryption key => your data.
                                Vulnerable to MITM attack- pretending wifi connection.
                                Solution- Use https. Use VPN. Ask establishment about visiting place- what name of their wifi is- to avoid connecting to a fake wifi.
                            WPS- 1 button Wifi use- useful for home but bad for business. old employee can break in few hours.
                            What you are connecting to should be trustworthy individual or business.
                        Secure your Network, then secure your router by changing default password (known to attackers)- the machine that connects wifi to the network.
                    </WifiSecurity>
                    <CreditCardSecurity>
                            class notes
                            Merchants' back end DB- server has card details.
                            for recommendations and analysis
                                    keep a token- @amusement park- 1 time payment- no reopening wallet.
                                    let only token reside with the merchant's DB.
                            Credit card stolen
                            replay attacks
                            POS to Server- wifi attack done in past.
                    </CreditCardSecurity>
                    <SDN>
                    SDN- Eli Computer Guy
                            this is one of the coolest things to come along in quite a long time
                            sdn is just absolutely amazing and we are at the bleeding edge of it
                            how to configure equipment?
                                    most of this stuff really won't be deployed into most of your environments
                                    for 2-3 years but once deployed absolutely awesome
                            idea is pulling intelligence of your networking away from the hardware
                            virtualization
                                    REL store data earlier- we had a file server that had hard drives 
                                            one box was responsible for everything 
                                                one box contains the data 
                                                box containing the hard drives 
                                                one box containing the operating system
                                                one box can train contain the access control lists 
                                            the whole nine yards
                                            Probs
                                                    if anything happened to the hard drive, data would become unusable.
                                                    if the power supply died it was Gone
                                            SANs came
                                                    storage area networks
                                                    physical equipment that store the data was separated 
                                                    from the control mechanisms that control how the data was stored
                                                    dumb ish data storage devices
                                                    some kind of management system that controls where data goes to when we went to
                                    Network
                                            We have left networking equipment behind
                                            looking at the same stuff the way back in 1999 the routers and switches routing protocols
                                            devices have grown in faster, backplanes, throughput
                                            but the actual intelligence mechanisms are basically the same they've added
                                            some qualities of service but same equipments
                                            well with sdn or software-defined networking making in networking equipment dumber
                                            but we're creating management system making overall networking system much more intelligent
                                            nuanced control of our entire networking infrastructure at one control panel
                                            vs having to go in to individual little a router and switches and do changes.
                                            History
                                                    in 1999- all we really care about was the size of the pipe was in 1.5 megabits per second
                                                            for transfering files- pictures, vids, emails-
                                                            Only speed was what mattered
                                                            how fast can we transfer entire files from point A to point B 
                                                    2005- skype, youtube, VOIP, digital surveillance
                                                            we are now doing real-time communication
                                                            needs something different then simple trained by the transfer of files
                                                            so what real-time communication cares about is something called latency
                                                            so before it was how fast we move a chunk of data from point A to point B
                                                            with latency we now care how fast can we get individual packets from point A to
                                                            Jitter is usually because there is too much latency
                                                            20 ms or what- we were worried about in about two thousand five
                                                            RTC- Real time communication- QOS- prioritize packets- VOIP > FTP (which will move faster?)
                                                    2012
                                                            st FTP > SIP and vv- but can't do that dynamically.
                                                            st video > Voice and vv- with QOS you can't do it.
                                                            can't programmatically say at run time
                                            SDN- dynamically models what we need to do- networking to data and control plane
                                                    data plane- is what actually has all the switches and routers and bridges that allow packets to go from point A to point B so the data
                                                            how we move data from point A to point B so
                                                            contains all the hardware and the basic	mechanisms be for being able to forward data from point A to point B 
                                                    services plane- the services plane are services that network requires- things like the firewall
                                                            what services are there on the network and separate them from physical equipment
                                                            firewall software is sitting on a physical piece of firewall hardware
                                                            separate the service the actual firewall functionality off to a different server
                                                            so it can deal with it more efficiently
                                                            services plane now why this is important is because think about firewalls
                                                                    couldn't they work more efficiently if you can cluster them or if you can use
                                                                    the power of Zealon servers in order to do all the out of the firewall stuff 
                                                                    instead of having a firewall with cpu and processing power being on that firewall
                                                                    cloud and clusters of zealon servers be able to deal with the firewall service
                                                                    more powerful, packets processed more quickly
                                                    control plane- servers or cluster of servers- sets up configurations for eth on data plane and service plane.
                                                            control plane- is a set of management servers 
                                                                    that communicate with all of the different networking equipment on the data plane 
                                                                    and decide right at this second	how should data move through the data plane
                                                                    REL all SIP traffic should have priority over FTP traffic 
                                                                            and then two minutes from now you can say all smtp traffic should have more priority over sip
                                                                            from 1 control console you are able to control the entire network at
                                                                    we are separating out the different components of the networking
                                                                    infrastructure so that we can deal with them separately
                                                            that do all the management for the services and the data
                                                            management console- 1 interface to configure all of the networking equipment on the
                                                                    network so instead of having to go to all switches and routers
                                                                    to change QOS for a specific protocol
                                                                    simply say i want protocol 25 to have maximum priority now- click!
                                                                    it will be given.
                                                                    don't have to go to all of those different little pieces of equipment to make changes 
                                                                    @like servers control all of the a windows 2012 server can control windows 8 computers on the network so from one interface
                                                            allows you to control all of the networking devices very easily.
                                                                    instead of going into command of individual device- you can mgmt console and send commands to propagate and change traffic shaping in real time.
                                                                    they are creating a control system that has SDK and API
                                                                    much like we connect to facebook, youtube thru api- software in network contacts control plane thru api.
                                                                    that api will reconfigure the system for it to function more effectively and efficiently.
                                                                    You have unified, clustered but best of all- you can have iphones connect to control plane/servers and function differently.
                                                                            software takes little bits of your network and make it function the best.
                                                                    scary- farmville- hacking- networking devices- graphics calculators- decent configuration- not fearful of hacking till now- follow security advices.
                                                                            software on network takes control of components of your network.
                                                                                    hopefully for the benefit of ppl
                                                                                    hacker can connect to cisco API to gain priority over the network and VOIP traffic gets No on network.
                                                                                    Eg- earlier apps installed on device, now apps on demand. urgent meeting with boss.
                                                                                            contact api to get that app as fast as possible- it gets priority- we can have pay per use and not BW.
                                                                                    WAN- Pay per use (quality, time)
                                                                                            REL wall street- want quickest transactions on stocks and willing to pay but not in evenings.
                                                                                                    online backup okay if it takes 200ms!
                                                                                                    BW will become like electricity- pay per use- not having it.
                                                                                            Eb has biz- WAN and you have biz. ISPs have their costs to- BW they give you- costs them.
                                                                                            Latency- has costs- less expensive to give large BW chunk with poor latency vs small BW chunk with good latency.
                                                                                            decide when they should choose some applications use more latency.
                                                                            Child watches porn, gets a virus and compromises the device and network thru api
                                                                            services installed on x86 servers- open standards and not proprietory- any comp science grad can start programming for services.
                                                                                    what about services server getting virus.
                                                                                    open pk for cisco- can start programming java, python, etc- cool stuffs never b4.
                                                                                    you can do firewall talk to 90 data points- more ppl- more cool stuff.
                                                    management plane- make sure all the servers on the control plane function as they're supposed to
                                                            to make sure that all of the glue above stays together!
                                                            so the idea with a software-defined networking is we're separating all this
                                                            manages that control plane because with the control plane
                                                            you can now have servers that made that control all of the networking equipment 
                                                            and you can have clusters of servers much
                                                            like you would have a cluster of active directory service 
                                                    REL if you deal with a router you have the hardware and	the intelligence and the programming all on that one device
                                                            vs well what if we can separate the router hardware (data) from the router intelligence (service)
                                                            from the router programming (control) 
                                                            helps us manage systems much more easily
                                                    So, SDN for easily shaped traffic in real time
                                                            why would we be doing now vs buy really big powerful networking hardware
                                                            REL why you may want to shape traffic real time
                                                            Let us create VOIP and digital surveillance network and computer servers and networks
                                                            they will have only have so much bandwidth respectively.
                                                            limited by QOS, VLAN
                                                            now sometimes it uses all that bandwidth and sometimes it uses a very little port very small portion of it
                                                            REL sometimes the voice over IP network is using seventy percent of the allocated bandwidth 
                                                                    when 1%, Set this up with VLANs, you may not be able use BW not used by VOIP.	
                                                                    instead of section it off for all these different services
                                                                    depending on current needs different services will get different priority
                                                    REL In technology, we have to think about future- 3 years down the line
                                                            HD video takes huge BW- say school shooting event or violence workplace- 
                                                            some pissed off spouse enters to kill, best if employees leave
                                                            we want to send surveillance system data to every single device on network
                                                            on priority- over the HD video streaming.
                                                            vs it will- choke and won't be able to work right cuz of different priorities (heart attack under introduced additional traffic)
                                                                    with a press of a button all HD videos shut off.
                                                                    FTP, SMI to shut off
                                                            once the guy is captured, want to give priority to VOIP for employees to make calls.
                                                                    with a press of a button the priority will be changed.
                                                            So see the shape of traffic and decide accordingly.
                                                    Last section
                                                            open flow- control protocol for how you control all those networking devices
                                                            control plane to control the networking devices but you actually have to communicate with
                                                            those networking devices 
                                                            just like you have routing protocols just like you  have RIP or OSPF
                                                    if you are deploying networking equipment then aiming at future
                                                            SDN is at where VOIP was 2005
                                                            All companies- cisco, juniper, altaris, HP, Arista
                                                            all think sdn is the future but different view of future
                                                            if you go out and try with 1- maybe that view may become obsolete in face of others in competition.
                                                            like happened to VOIP- there are winners and there are losers.
                                                            around 3 years they will solidify so do some research 
                                                            for wrong decision may have to do a very quick refresh of their network
                                                    Infrastructures
                                                            different processes done on different plates
                        Misc
                            Net neutrality?- it is for internet not an org.
                            It will do more automation over past- reduce job opportunities?
                    </SDN>
                    <Firewall>
                            Determines whether to allow a packet thru a network based on some predefined rules.
                            S/w component- Protects a single computer
                                    less expensive- installed on system
                            H/w- protects N/w, expensive
                            Types
                                    Packet Filtering
                                    Ckt level gateway- also status of connection.
                                            is it an ongoing connection- thru SYN-FYN status.
                                    application gateway- proxy server.
                            Traditional can't protect email viruses, url filter, intrusion protection.
                            can't do with SSL but encrypted upper layers- not below!
                            Next generation in single pass.
                            Use
                                Security
                                Administrative- let VOIP, telnet, FTP- firewall mein in protocols ko block kar dete hain
                            Types
                                Software- for end users. Eg- windows based firewall.
                                Hardware- New h/w which will keep the software inside of it. For specific networks and OS- we use this.
                                    these days router has firewall built-in and vice versa.
                            Generations of firewall
                                Network Layer Firewall
                                    Packet Filters- in 80s- the inspector checks that packets are conforming to rules. Error report to sender on detecting erroneous packets.
                                        blocks ports, protocols- like we have blocked FTP, etc.
                                        doesn't keep track of your session- stateless firewall.
                                        Works at physical, DLL, NL and touch of TL.
                                    Stateful Filters- uses TL to see pkts establish new connection, using previous connection or no connection.
                                Application Layer- works at OSI 7th layer. Filtering on HTTP, FTP, DNS.
                                Proxies- Proxy shares 1 internet connection with many PC. useful for connection/resource sharing.
                                    hackers use IP Spoofing to use proxy server to transcend the firewall to reach your PC which may not have software firewall.
                                NAT- Network Address Translator Firewall. Private addresses are hidden from outside- thus act as firewall.
                            so called- saves us from internet fire.
                                                            Stopping firewall in centos
                                                                    systemctl disable firewalld
                                                                    systemctl stop firewalld
                                                                    systemctl status firewalld
                                                            Windows- firewall with advanced security- Inbound and outbound- create a rule.
                    </Firewall>
                    <MITM>
                        Man in the middle attack
                            Wifi connections- I am wifi- ARP spoofing- see eth passing.
                            Public key exchange- I want connection- take my public key- intercepted; I want connection- take my public key signed by CA you (browser/device) trust
                        Dutch company that signed Google certificate without permission got bankrupt. Iran ppl got MITM by someone to google.
                        Govt can get fake certificates; somehow get private key of CA.
                        Lenovo superfish attack- to sell more ads- superfish sitting on machine would act as MITM leading to massing MITM.
                    </MITM>
                    <Bitcoin>
                        <NonTechnical>
                           Bitcoin Non-technical
                                Bitcoin lets people exchange money electronically as easily as sending an email or text. 
                                        To send money, you use what’s called a “Wallet” app to type in an amount, enter or scan a recipient’s account number, and hit ”Send”.
                                        The recipient will then see the money pop up in their account.
                                So how does it work? 
                                        At a basic level Bitcoin is just a ledger with account numbers and balances.
                                        When Bob sends Carol 5 Bitcoins, his balance goes down by 5, and Carol’s goes up by 5. 
                                        There’s no gold or government-issued money backing these numbers, 
                                        just people’s belief that the numbers are worth something, and a system that prevents unfair changes.
                                        Part of this system makes sure that no one can spend money from someone else’s account.
                                        Every time you hit “Send”, your Wallet app sends a message to the Bitcoin network
                                                describing how the ledger should change, including the sender’s and recipient’s account numbers and the amount to transfer. 
                                        So what’s to prevent a thief from creating a message transferring money from someone else’s account?
                                                Bitcoin requires a kind of signature on each message to prove that it was created by the true account owner. 
                                                The signature serves the same purpose as a handwritten signature on a paper check, but it’s based on math rather than handwriting.
                                                The math comes from the world of cryptography, which is normally used to hide secret messages,
                                                but in Bitcoin, has been re-purposed to prove ownership. 
                                                Each Bitcoin account number has an associated key that only the true account owner knows, 
                                                and is used to create signatures by encrypting transaction messages. Others test the signature by trying to decrypt it.
                                                If successful, they know the signature was created by the true account owner.
                                                In addition to not relying on handwriting analysis, these math-based signatures also can’t be copied and reused on other transactions, since the signatures are unique to each transaction.
                                                So these signatures keep unauthorized transactions from changing the ledger, 
                                        but who exactly is checking the signatures, and overall, maintaining the ledger? Surprisingly, anyone who wants to!
                                                One of the main goals of Bitcoin is to provide a decentralized system, 
                                                        meaning no single company or government can control it. 
                                                Every time someone sends money, a transaction message is passed around to all the people who want to help maintain the ledger, who I’ll call “maintainers.”
                                                Each maintainer keeps a personal copy of the ledger and updates it whenever they receive a new transaction with a valid signature.
                                        So how does the world decide which version to use?
                                                Y? With ledgers spread all over the world, traffic delays--and occasionally fraud--can lead to differences in those ledgers.
                                                Like in other democratic systems, there’s a vote, but it’s a bit different than a typical ballot system. 
                                                Maintainers “vote” by trying to solve a special puzzle based on their version of the ledger. 
                                                        So why math problems instead of, say, emailing in votes to decide on a ledger? 
                                                                Without a central authority to register voters, it would be hard to enforce one vote per person
                                                                a single person could create multiple accounts to vote more than once, or even millions of times.
                                                                The math problems prevent this by making each vote have a cost in computers and electricity.
                                                                This means out-voting, or out-solving the majority to take over the ledger would effectively require out-spending the majority--an unlikely event.
                                                                So the math enables a fair vote in a decentralized system. 
                                                        How? The first person to solve a puzzle announces their solution and everyone updates to that version. 
                                                                So the vote turns out to be a kind of mathematical race, but it’s designed to favor the majority’s version.
                                                                This is because the more people there are working on a particular version, the faster it will be solved.
                                                                Because new transactions are constantly being generated, this voting process repeats over and over again 
                                                                so maintainers can continually agree about new transactions.
                                                Two more important details about how it does this:
                                                        To prevent someone from pre-solving a puzzle to win the race, each puzzle builds on previous answers, 
                                                                and the winner is not just the most recent solution, but the ledger version with the most total solutions.
                                                        The puzzles are also extraordinarily special in that there are no tricks to solving them faster
                                                                only by buying more computers and electricity. 
                                                                It’s this property that underlies the entire system, and gives people assurance that solutions are truly from the majority, and not a clever attacker.
                                                A final note about how money is created. Every time a puzzle is solved, a small award is added to the solver’s balance, effectively creating money “out of thin air.”
                                                        This award acts as an incentive for people to help maintain the ledger, and is an addition to small fees senders attach to transactions.
                                                        Because maintainers acquire newly created money through computation, they are typically called “miners,” 
                                                        but their main purpose is really to manage the ledger, not to create money. 
                                                        The voting system simply provides a convenient way to randomly distribute money into the world, 
                                                        and in fact, after 2140 no more money will be created.
                                        In summary, Bitcoin is an electronic currency that’s based on a collaboratively maintained ledger.
                                                People transfer money by sending messages to maintainers describing where and how much money should move.
                                                Maintainers make sure that the messages are from the true account owners by checking digital signatures.
                                                And finally, the maintainers reach consensus with each other through a math-based voting process.

                        </NonTechnical>
                        <Technical>
                           What? At a very basic level, Bitcoin is just a digital file or ledger that contains names and balances
                                    People exchange money by changing this file. 
                                    One goal of Bitcoin is to avoid any centralized control, so every participant maintains their own copy of the ledger.
                                    => everyone can see everyone else's balances, but the real system only uses account numbers and not names, so there's some level of anonymity.
                            Why?
                                    When Bob sells Carol a lawn mower for 5.2 Bitcoins, Bob's balance goes up by 5.2, and Carol's down by 5.2. 
                                    There's no gold or government issued money backing these numbers.
                                    Bob is only willing to trade his real-life lawn mower for a higher number in this digital file because he has faith that other people will also trust the system.
                            How?
                            So who maintains this ledger and makes sure no one cheats? 		
                                    Transaction process- If everyone maintains their own ledger, how are all the ledgers kept in sync as money is transferred? 
                                            At a basic level, when you want to send money, you simply tell everyone else by broadcasting a message with your account number, the receiver's, and the amount.
                                            Everyone across the entire world then updates their ledger.
                                            As a quick aside, I'm describing how Bitcoin works for power users--people who help maintain the system.
                                                    You can also just use the system to send or receive money, though, without maintaining a ledger.
                                            Prob-?Impersonation/ Spoof- If sending money is as simple as creating a message with some account numbers, what's to stop a thief, Alice, from spending Bob's money by using his account number? 
                                                    @Like a pen and paper check, Bitcoin requires a kind of signature to prove that the sender is the real owner of an account, 
                                                            Unlike the handwritten version, these signatures can't be copied and reused in the future, as they're unique to each transaction.
                                                    but it's based on math rather than handwriting.
                                                            When a new account number is created, it comes along with a private key mathematically linked to that account number. 
                                                                    Private key held and created by Bitcoin wallet
                                                            To create a signature, a private key and the text from a transaction are fed into a special cryptographic function. 
                                                    Verify- Another function allows other people to check the signature, making sure 
                                                            it was created by the account owner
                                                            and applies to that specific transaction
                                                            While the mathematical signatures prove who sent a transaction, they can't prove when it was sent, and this turns out to be problematic.
                                            Prob- Double Spending
                                                    @In our traditional banking system, if Alice wrote two checks, but only had enough money to cover one of them, 
                                                            the bank would pay the first person attempting to cash his check,
                                                            but refuse the 2nd, because Alice's account would be empty.
                                                    Unfortunately, order is much harder to determine in Bitcoin, where instead of single bank, there are individuals all over the world. 
                                                            Network delays might cause transactions to arrive in different orders at different places, and fraudsters could lie about timestamps.
                                                            So the order of these checks is critical, because it determines who should get paid. 
                                                    Two recipients might both think their transaction is first and ship a product, effectively allowing Alice to spend her money twice!
                                                    Bitcoin prevents this by providing a way for the entire world to decide on transaction order.
                                                            As new transactions are created, they go into a pool of pending transactions. 
                                                            And from here, they'll be sorted into a giant chain that locks in their order.
                                                            To select which transaction is next, a kind of mathematical lottery is held. 
                                                            Participants select a pending transaction of their choice, and begin trying to solve a special problem that will link it to the end of the chain.
                                                            The first person to find a solution wins, and gets to have their transaction selected as the next in the chain.
                                                    So what's this linking problem? 
                                                            It's based on a special function called a cryptographic hash. 
                                                            As scary as this sounds, it just mixes up its inputs and spits out a number, but it's special because it's irreversible. 
                                                            There's no easy way to start with an output and then find an input that generates it other than making lots of guesses. 
                                                            And this is literally what people are doing in Bitcoin--feeding this function random numbers until the output meets certain criteria.
                                                            Besides a random guess, you also input a transaction from the pending pool and chain, which is where the linking part comes in.
                                                            So the lottery provides a way for the entire world to decide which transaction is next, but the math behind it also helps ensure that everyone agrees about past transactions, too.
                                    Suppose you're joining the network for the first time, and request a copy of the transaction chain to get caught up, but receive several different versions. Which one should you trust?
                                            Ideally, you would trust the one that the majority of people are using, but determining this on the internet is difficult. 
                                            What would stop a single person from voting millions of times? 
                                                    Bitcoin prevents this by requiring people to solve math problems to vote. 
                                                    This causes each vote to have a cost in computing power, making it unlikely that a single person or group could ever afford to outvote or out-compute the majority of users.
                                                    The transaction ordering process described before actually provides the voting system.
                                            Part of the input to the linking problem is a transaction from the end of a chain, so each guess is effectively a vote for that chain. But how are all the votes tallied?
                                            Because the cryptographic hash function has well defined statistical properties, 
                                            you can look at any given answer and estimate how many guesses it took to find it, just like estimating how many coin flips it would take to get 100 heads in a row.
                                            So the links in a chain not only put transactions in order, but also act as an effective vote tally, making it easy to see which chain most people are using.
                                    Finally, how does the money get created? 
                                            Every time someone wins the lottery to pick the next transaction in the chain, new Bitcoins are created out of thin air and awarded to their account.
                                            Solving these problem is commonly called "mining," as this is how money enters the system, but the main purpose of the math is to make sure everyone's ledgers agree.
                                            The math simply provides a convenient way to randomly distribute money into the world. 
                                            In fact, sometime around 2140, no more money will be created, and participants will only be paid from fees added on to transactions.


                        </Technical>
                        Misc
                            By design, the blockchain is a decentralized technology. ... A global network of computers uses blockchain technology to jointly manage the database that records Bitcoin transactions. That is, Bitcoin is managed by its network, and not any one central authority.
                    </Bitcoin>
                    <RFID>
                        What?
                                every product has a bar code that contains basic information about the product
                                        owners can keep track of their inventory and shoppers can check out much faster than before
                                        but all codes must be read one at a time 
                                        the information they contain is fixed
                                what if the bar codes were replaced by chips that could not only be read more quickly 
                                        and could have their information updated as well
                                        chips could communicate with other devices 
                                        chips already exists and the technology they use is called RF ID short for radio frequency identification
                                the way we track things in the future
                                ~wireless bar codes able to carry much more information
                        How? while rfid tags contain a small micro chip and the transmitter
                                they can only be activated by an rfid reader to which the tag returns its signal
                                that's why rfid is called a passive technology
                        Eg- imagine that you buy a carton of milk in a supermarket the cartons rfid tag has toured the price and the milk expiry date 
                                when you pick up the carton the shop can immediately display the cartons expiry date
                                when you are finished your shopping a reader near the exit could read the tags of all your products as you pass by 
                                and immediately generated bill for your approval- no more standing in line
                        Eg- card swiping, car unlocking, credit card in short range.
                        Eg- at home a small refrigerator equipped with an rfid reader could keep track of the
                                expiry date of all your groceries and if you also have a smart rubbish bin
                                refrigerator to even make a new shopping list for you
                                sound futuristic but used exactly same way in transport and logistics
                                rfid tags are already being built into motorway to first class and former passes 
                                facilitate the handling and tracking of luggage 
                                great retailers also integrating rfid tags and readers into their stores
                                with the price of rfid chips and readers dropping steadily other sectors are discovering their uses
                        Apps- can be integrated into almost any everyday object from bridges to the bus passes
                                used to keep track of livestock/ agreeculture
                                        now that these tags can be reduced to the size of a rice palette
                                        they are already being implanted into pets to help track and recover them
                                new applications of rfid are in medicine 
                                Eg- an RFID built into an armband could contain a unique identifier for a patient
                                        doctors can immediately access the patient's medical history
                                        Link it to databases of diseases and medication side effects
                                        this could greatly speed up diagnosis and treatment
                                Eg- in fact several european research projects are working together with large companies from other sectors to find clever ways of cutting costs and boosting efficiency with RFID
                                Eg- Walmart is one of the big users of rfid tags 
                                        is currently tracking pallets by adding tags to each individual product on the pallets as well as the pallets themselves
                                        these little tags hold the information that tells the scanner exactly what is on the pallet
                                        the new tags work by using passive rfid chips with small antennas that emit a unique product identifier code when passed near an rfid reader
                                        that information is transmitted to an inventory control system 
                                        packages can be moved throughout a warehouse placed on a truck 
                                        and the rfid tags will tell the scanners in the warehouse
                                        which packages have left along with the time they left
                                        this helps keep tracking up to date and more efficient
                                        this is also the reason packages are scanned when they arrive at their destination
                                        the scanner is reading the tag and can then tell a host computer that the package was delivered
                                        walmart hopes that these new tags will eventually replace barcodes 
                                        by using these tags they have already improved the restocking capabilities by allowing them to restock items up to three times as fast
                                        this powerful emerging technology enables companies like Walmart to better track assets tools and inventory 
                                        here packages are being sorted using rfid tags and an automated sorter 
                                        as they pass by scanning it tells the automated sort of whether to let the package passed or to move it to a new line
                                Eg- another common use of rfid is toll tags
                                        these are rfid tags that are placed inside of your vehicle allowing u to drive through special lines on toll roads without stopping
                                        this is possible because the tags are read as you drive your car through the lane so no stopping is required 
                                        of course these tags keep track of how many times you pass through the toll and bill u as such
                                        you might have noticed a flat sensor above the toll lane when driving through a toll tag
                                        this is the sensor that reads the information on your tagged by sending
                                        out of electromagnetic waves and induce a current and tags antenna 
                                        and powers the microchip circuits which gives the scanner the information that is on the tag
                                Eg- mostly used for simple things like package tracking, Pet locators and toll booths
                                Eg- since 2006 passports have been created with rfid tags built in- making it even harder to alter passports 
                                Eg- this technology can be used in many ways and is constantly being improved for new uses
                        Security
                                the fact that these devices can be read updated and tracked has raised privacy concerns 
                                the European Union is there for developing for legislation to ensure that the use of rfid never compromises basic human rights 
                                and the individual's right to privacy 
                        more and more devices and applications are becoming interconnected and among them rfid is remarkably becoming a key technology
                        How?
                            consists of three components 
                                    antenna or coil 
                                    receiver with the decoder 
                                    a transponder (aka radio frequency tag)- electronically programmed with the tags' unique information
                            the reader or scanner emits radio waves (always) range 1 inch- 100 feet or more depending on its power and the radio frequency used
                                    when an RFID tag passes through the electromagnetic zone of the scanner it gets power (the tags' activation signal) and sends response back.
                                    when passed near the receiver the tag is activated- the antenna emit radio signals back allowing reader to read and write data on the device
                                    the scanner then decode the data encoded in the tags integrated circuit 
                                    which can then be passed in the host computer for processing or tracking
                        Security- https://www.youtube.com/watch?v=aO6zFpgtLj8
                    </RFID>
                    <VPN>
                        VPN Working
                                Knowledge is freedom and ignorance is slavery.
                                Govt censorship, spy on you
                                Being a solution of problem and not a victim
                                Most countries have ISP- provide Internet Gateways for Internet to access fb, twitter.
                                        Govt can control ISP to block a certain websites.
                                        Firewall stops it- 
                                        Free VPN- share resources with lots of ppl. 
                                        paid VPN- pay subscription (4,10$/month- service varies)
                                        page service- many ppl have access to it.
                                        own private VPN- 
                                VPN is not banned- just a service.
                                        Bypass the firewall and use the VPN Server to connect to stuffs.
                                VPN comes in here
                                        Access content that is geographically restricted (netflix/ hulu)
                                        Access content that is censored in a coutnry you are living in.
                                        Secure data transfer so no one can spy on you.
                        Like postal service, public transport services- govt wants to know where'e the stuff going
                                Router is given IP by ISP- all can peek your address.
                                web servers know where you are from- country, your state, your blocks- try whereismyip on google
                                Open coffee shops wifi, library, airports easy to hack your password- encryption doesn't happen.
                                Travelling- I can't use my video streaming service- that country blocks.
                                Price of flight is different as where you book from- geolocation changes things.
                                Our router creates a tunnel to VPN server- web server replies to VPN server. 
                                VPN being encrypted- our locals don't know site you are accessing- it's encrypted.
                                        they know only VPN Server IP.
                                Get yourself VPN service- Express VPN are good guys. Services all around world- you say which country you wanna use.
                                        it has android app, LINUX, windows, etc.
                        Downsides
                                Europe- I send data to VPN server in asia to connect to USA- it gets slower.
                                VPN has limited server, band width- busy day with clients, you may get slow response
                                Some countries keep it illegal- accessing web sites is not that problem.
                                Netflix has been blocking VPN servers connecting to them.
                        Many companies use VPN to connect to corpporate networks
                                Early days of computers- companies wanted to send data across geolocations- university A to B
                                        used to connected thru leased lines- for any type of connection- phone system.
                                        But this is very expensive- T1 line- 1.544 Mbps at 300$ per month, up to 8000$/month if 1 part of kashmir to kanyakumari.
                                        Physical connection  and its logical equivalent.
                                VPN- used broadband network at cheap cost (Internet)
                                        uses public network in between cheap and reliable. unlike leased line. So some standards for protection (security over public system)
                                        That's how remote access of companies work. with VPN Server connecting to Network server and authentication b4 access to resources (file, printers)
                                        Site to Site- Organization that's remote and it has its own section of this corporate network- which is serviced by extranet server- thru which you can access resources.
                                3 steps to VPN
                                        1. Authentication- Protocols/ ways/ methods to do connection.
                                        2. Tunnel
                                                various protocols to do that
                                                We encapsulate the packet- use public network to send to VPN server and deliver it to Fred.
                                                Can use PPTP (Point to Point Tunneling Protocol)- Microsoft- easy but less secure. So, professionals don't like to use it.
                                                        IPSec (allow A,T,E), Layer2 Tunneling Protocol (used in conjunction with IPSec)
                                                        All OS have VPN Clients built-in- they request VPN connection to VPN Server- UserId, Pwd, they give VPN address back- on VPN private corporate network.
                                                        The packet with VPN Address is wrapped up and sent to VPN Server who unwraps it and gives the feeling that it was an internal IP.
                                                        VPN Firewall can block your internet access/monitor it- accessing apple.com from there.
                                                                we can use split tunneling to avoid it- any non-"private" IP doesn't use VPN routing.
                                        3. Encryption
                                                AES (128/256), 3-DES, etc.
                        VPN by ELI
                                Allows Computers/Networks to connect over Internet secure- Bangalore office with Mumbai office.
                                As simple as clicking connect for users
                                Internet connected by US Army- protect against attack. What if 100 nuclear weapons go away. Suddenly cease to exist- so central hubs.
                                They wanted a way that was self healing. Packet switching- new communication paths would be used if 1 is blown away.
                                From data security, it was very insecurity- MITM attack- can see eth going on.
                                        Create a tunnel and then encrypt the tunnel- penetration of tunnel won't help.
                                        Tunnel detects penetration- tunnel shuts itself down and recreates with other set of routers.
                                Uses client server technology
                                        VPN server provides service- sits in office
                                        VPN client installed on your computer.
                                        You give it External IP address (10.1.10.1) and VPN Server is told that IP and your username and password
                                        VPN Server confirms your credentials and allows you to be on network.
                                        Many VPN Software- Microsoft, Cisco, OPENVPN.
                                        So you can give a print command from Dubai to printer in washington DC.
                                        Both think the other guy is in the building but your speed is limited by Internet connection and not LAN speed.
                                Verizon etc all talk about download speed but upload speed is important.
                                        Upload is as important as download in VPN.




                        What- VPN
                        Why- Advantages and problems
                        How- Practical (purchase, free/paid, extranet/remote, ...)
                                How internally it works- VPN Server, Logically Private Network, 
                                        Packets- IPSEC, Authentication, etc.
                        VPN- Network Technology which creates a secure network connection over a public network (or privately owned service provider)
                            Eg- Corporations, Govt agenecies use VPN
                            The perception of being in a private network is illusion created with the help of VPN Server and protocols.
                            Types
                                Site to site- communication betw organizations (same/different)
                                Host to site- Remote access VPN- software on user device to communicate with organization.
                                Host to Host- User to user encryption with no hardware reqd.
                            Why
                                No additional costs. Reuse public internet. Safety guaranteed.
                                Application
                                    Extranet- Remote access to company (work from home)
                                    Geo-restrictions/censorship- ticket booking, website access.
                                    Proxy servers to protect personal identity- whereami in google w/o GPS.
                                        companies and govt spy on you.
                            How
                                Contact VPN Provider- get IP Address of VPN Server; Username and password
                                    They accept all payment options- bitcoin to bank
                                        They choose Protocols and encryption standards for safety.
                                    How to choose?
                                        Free
                                            VPN client is MITM- so free VPN can (will) compromise (use) your data if govt, etc insist (sell)
                                            many claim they won't use but do use.
                                        Paid
                                            No Logging policy- highlighted => Lower cost.
                                                Warrant canaries- Govt can't force them.
                                            The promised speed/BW.
                                            Native Advertising- Beware of looking for VPN Reviews- they are paid. Recommendation sites are paid to review and recommend.
                                Make sure your connection supports both good upload and download speeds- it can be a bottleneck.         
                        VPNProtocols
                            PPP- Point to Point Protocol
                                Authentication, compression error detection, multilink
                                            - But no encryption
                                Used in many physical networking environments 
                                            - Telephone lines, mobile phone, serial cables
                                Layer 2 protocol
                                            - Very useful when it was only a modem connection
                            PPTP
                                Controls the tunnel
                                GRE(Generic Routing Encapsulation) is the tunnel.
                                PPP is used to send multi-protocol traffic through the GRE tunnel.
                                Authentication and encryption
                                    MS-CHAPv2 (Microsoft Challenge Handshake Authentication Protocol)
                                    EAP-TLS (Extensible Authentication Protocol – Transport Layer Security)
                                This Microsoft version is considered unsecure.
                            SSLVPN
                                Uses common SSL protocol (tcp/443)
                                    (Almost) No firewall issues! Like devices would support https.
                                No big VPN clients
                                    Usually client-to-site communication
                                    Can be run from a browser or from a (usually light) VPN client- remember https
                                    Across many operating systems
                                Authenticate users
                                    No requirement for digital certificates or shared passwords (like IPSec)
                            IPSec
                                Security for OSI Layer 3
                                    Authentication and encryption for every packet
                                        Two core IPSec protocols
                                            Authentication Header (AH)- Supports authentication on either side.
                                            Encapsulation Security Payload (ESP)- Supports Encryption
                                                Confidentiality and integrity/anti-replay
                                                Encryption and packet signing
                                Very Standardized
                                    Very secure.
                                    Common to use Multi-vendor implementations- cross compatibility.
                        SQL Injection
                                ewastrusinska.com/page.php?id=1
                                kali- 123 (use root for username)
                                ping google.com
                                http://whatismyipaddress.com/
                                software networx- tracks our download amount
                        Many people consider Virtual Private Networks and Remote Desktop Protocol to be the same thing however they are not.
                            While a VPN allows you to access resources on the network an RDP can provide a much larger range of processes as it allows you to access a computer terminal on the network.
                    </VPN>
                    <BluetoothLowEnergy>
                        Bluetooth working
                            wireless connection between 2 devices- low power radiowaves from 2.40 GHz to 2.485
                            Types- Class A (100 m- Industry), 2 (10m we use), 3 (rarely 1m)
                            Form a piconet of 7 ppl
                            Bluetooth uses ISM band- Industrial Scientific and Medical Band- uses Spread spectrum frequency hopping technique.
                                Parts of files are send thru small burst of radio waves whose frequency can change 1.6K times/sec to avoid interference and crowded envt.
                                Smart Tech uses 0.01W to 0.5W. So, Bluetooth doesn't drain our mobile phone.
                            Why so called- inventor had blue teeth? Nay, King name's meaning- used to solve quarreling (unconnected) ppl by connecting.
                            Why not- can be easily hacked into- cellphone can get viruses- short range
                                easy install/connect, cheap/free usage. device compatible.
                            Doesn't interfere with WLAN/RF Devices- differnt way of operation/Fast freq change.
                            Physical Layer
                                1Mbps, 2.4GHz ISM band
                                    Split into 40 channels (2MHz spacing)- 37 data + 3 advertisement
                                    BLE strategically keep advertising channels to ensure no interference with wifi.
                                Modulation Index is widened from 0.35 to 0.5- GMSK (median shift keying) if it was 0.5 but kept betw 0.45 to 0.55
                                    0.5 makes cost go up- in the range we can keep cost low- for selling in billions.
                            Link Layer is brand new- 1 packet format. 2 protocol types- adv, data channel.
                                advantages- adaptive freq hopping, low power ACK, fast connections.
                                ACK is delayed (not for every packet)- saves power.
                                Advertisement need- advertise presence in area, react to local event, send temperature like data- master responds with asking more details.
                                    Slave advertises all the 3 channels and goes to sleep and repeats. Master sends connect requeest.
                                Link layer has a state diagram- StandBy in center connects- Initializing, Scanning, Advertising, and Master/Central/Observer has Init -> Connection -> Standby and Slave/Peripheral/Broadcaster has Advertising -> Connection -> Standby.
                    </BluetoothLowEnergy>
                    <LTESecurity>
                        Old mobile networks had no support for security- no plans.
                        GSM- old security- protects user data, but no mutual authentication- Devices connect to anyone claiming to be base station.
                            3G had encryption and authentication so things got better.
                            Phone, tablets, home appliances, thermostats, security cameras, cars, ATM- connect thru mobile network.
                            RAN- radio access networks- have base station.
                            Packet core is a bunch of core.
                        Connection Procedure
                            Power-up/ flight mode off- Cell Search Procedure- Decode PSS and SSS (primary, secondary) to sync in time and freq. Decodes PBCH- channel code.
                            Obtain System configuration
                            Random Access
                            Connected
                            Idle- back to random access in cycle.
                        What- next generation mobile broadband over IP (packet switched)
                        Why LTE
                            Time- Low Latency, high network throughput, increased data transfer speed
                            Money- More cost effective
                            Improved over 3G.
                        LTEArchitecture
                            RAN- Radio Access Network
                                a set of eNodeBs communicate amongst each other in RF.
                                Forward signals to MME (EPC part) for authentication
                                Forward signals to S-Gateway for Internet.
                            EPC- Evolved Packet Core- framework for converged voice and data on 4G.
                                MME (EPC part) contact HSS DB
                                    for authentication.
                                    decides for Radio resource management strategy with RAN and HSS.
                                    MME is also responsible for Roaming mgmt
                                    activity related information
                                S-Gateway to P-Gateway for IP Network.
                        Threats
                            A bad base station can force user to downgrade to GSM (Use LTE only option)
                            Jamming LTE radio preventing successful transmission from phone by increasing SNR.
                            The secret key can be stolen from HSS/AuC DB (Network security from carrier) or obtained from UICC manufacturer (Physical security)
                            Making huge requests to eNB and core network to function- large simultaneous handshakes.
                        LTE Security
                            LTE mutual authentication- UE and network (UE -> MME -> HSS (auth) -> MME -> UE -> MME (auth))
                            NAS (Non Access Stratum)- Non-radio signalling betw UE and MME (MME --NASSecurityModeCommand--> UE --Complete--> MME)
                            AS- Integrity/ verification, ciphering between UE and eNB. (MME -> eNB --ASSecurityModeCommand--> UE --Complete--> eNB)
                                Encryption- make blocks of 128 bits- XORed with key to make Cipher.
                                Decryption- XOR with cipher text the key.
                                Use EEA matrix block- to protect against known plain-cipher text attack.
                    </LTESecurity>
                    <IntrusionDetection>
                        <NetworkBased>
                            IDPS- Intrusion Detection/ Prevention System
                                vs Firewall- uses Network header (SrcIP, DestIp, Port) to conform to security policy.
                                    Firewall works at Network layer and doesn't look at content.
                                    it's too granular at suspicion- while attacker can change his IP.
                                @Firewall is security guard- checks credentials, Mailroom clert for Thorough check by IDPS.
                            IDS- 1 switch (with spanning port) guides all traffic of packets to IDS which can at best raise an alert
                                switch/ hub substitutes
                                    may use network tap on the optic cable but could cause additional downtime.
                                    may use IDS Load Balancer also.
                            IPS- Data routes thru the IPS appliance which can block the malicious data.
                            Why
                                Problems- any attack done on the system directly can't be handled.
                            How- Many merge these features in separate device, router, or firewall (UTM- Unified Threat Mgmt = Firewall + services)
                                Detection Method
                                    Vendor specified signature detected- @ are you good witch or bad witch?
                                        pattern corresponds to known threat. Compare signatures/ attack fingerprint against observed events.
                                        Good for known but ineffective for unknown.
                                        Eg- Congrat you won 1 Lakhs.
                                    Anomaly Detection- Deviations from normal behavior- Traffic is 5 times the expected one- raise alarm.
                                        maintain profiles for normal behavior (over time) of users, hosts, network, connections, applications.
                                        Effective at detecting previously unknown threats but generate lotta False positives and diffl pinpoint the issue.
                                        Eg- Code Red worm of 2001.
                                    DOS- Observing traffic behavior with normal expected.
                                        Risk of False positive and False Negative.
                                Location and Distribution
                                    Centralized, Distributed, Hierarchical- who does analysis.
                                Format- Appliance based, software only.
                                Security Capabilities
                                    Info gathering- Identifying host, OS, Apps, Network characteristcs.
                                    Logging- Timestamp, IPs, Ports, byte transmitted, authenticated username.
                                    Detection
                                    Prevention
                        </NetworkBased>
                        <HostBased>
                            Why
                                Sees local activity but overhead as application on the machine.
                                License purchasing cost.
                                preferred because the agents have direct access to hosts’ characteristics often => comprehensive and accurate detection.
                        </HostBased>
                        <AlertTypes>
                            TruePositive
                            FalsePositive
                            FalseNegative
                            TrueNegative
                        </AlertTypes>
                    </IntrusionDetection>
                    <DNSSec>
                        DNS was not built with security in mind.
                        Recursive Query- Local Name Server (Stub Resolver on PC recurses thru DNS Resolver)
                        Iterative Query
                            Root
                            TLD
                            ANS- A bad guy can change an IP address and create havoc.
                        DNSSec Validates all these request- when you say you are 7- you better be.
                            DNS response is DNSSec validated/ DNSSec signed.
                            Works by chain of trust (ICANN has formalized it- this should happen perfectly)
                                In 2k10- Root Level Domain was signed and available for DNSSec Validation.
                                TLD- based on that signature I can now get a certificate and a signature that I can trust- I will pull down certificates from you.
                                water fall effect of trust goes to ANS also.
                            Put Big.IP in middle of ANS- takes load off ANSs (installation) and return DNSSec signed response.
                    </DNSSec>
                    <HTTPRequestSmuggling>
                        https://portswigger.net/web-security/request-smuggling
                        Exploiting the permission of CL and TE for HTTP and front and back end communication gap. CL.TE, TE.CL and TE.TE obfuscation.
                    </HTTPRequestSmuggling>
                    <SSRF>
                        Server Side Request Forgery.
                    </SSRF>
                    <Tools>
                            Kali Linux- best for hacking
                                    legal to learn.
                                    comes with all pre-installed tool kits.
                                    dictionary attack demonstrated- what about 3 times and fail.
                                THC Hydra
                            Maltego- for graph view of internet search.
                                Eg- Amitabh bacchan- get movies- get their directors- get movies by those directors and so forth.
                            NMap- to do a port scan- illegal so do thru hotspot network.
                                    attack ur system- scan which port is open.
                                    zenmap app
                                    https://gist.github.com/vik-y
                            OpenPuff- for steganography.
                                    lets to hide the file inside another file data in form of noise.
                                    too much big file => add in more files- numbering, ordering important to recover.
                                    can mark a file to check if it is original or changed.
                            TAILS- OS that leaves no trace.
                                    No trace of history cuz works in RAM- incognito browser- tor by default.
                                    work from disk, Pendrive, etc.
                                    vs other live CD- like ubuntu- we can create RAM dump and gain some info.
                                    TAILS wipes out data- files of that session.
                                    VPN- u can trace back to PC who requested.
                                            vs in onion- layers of encryption- can't tell previous PC.
                                    can clear file properties in there.
                                    we can use camouflage tool to make it look like windows, mac, etc.
                                    Tor doesn't encourage google- cuz of metadata collection they do
                                    google also rejects to avoid spamming.
                                    Maximize windows- forensic use to track you thru fingerprinting.
                                    whatismyipaddress.com- that of my ISP or TOR has different as seen by server.
                            ?Wireshark
                            Snort
                                Intrusion detection system- real time pkts analysis
                                Free, Open source, snort.org download
                                Modes of operation
                                    Pkt sniffer- display on console
                                    Pkt Logger- Logs
                                    Intrusion Detection System- List of rules checked against pkts
                                    switches/ options/ commandFlags
                                        -l (logging), -r (reading), -b (binary dump)
                                        v,d,e (TCP, AL, DLL)
                            Fiddler- Proxy server practically. Debugging and security.
                                has many add-ons to make it more powerful
                    </Tools>
                </More>
            </NetworkSecurity>
            <IOT>
                Framework of H/w and S/w- using LINUX in edison
                Uses
                        Sensor- Thing in Internet of Things.
                        Communication
                        Aggregate
                        Analyse
                        Act
                Use Cases
                        Car Health- sensors on car devices like temperature collect data on hub to show on dashboard ( or report server)
                        Health Care- Pressure sensors on soles of shoes- tell what's wrong with running; Cricketers' postures.
                                Phone is used as IOT gateway.
                        Connected home- Gas leakage, 3 whistles switch off; lights on at home, fridge
                Start
                        Set up host envt using bootable pendrive- boots Ubuntu and pops eclipse in C.
                        Eclipse runs gcc command in the background- check commands in project properties.
                        execution of project- close unrelated projects, clean project (remove binaries), build project (makes binary), execute using run button dropdown.
                        Debug mode- use ant button. uses gdb- use step into and step over buttons.
                                step over for printf- why? it's a system code- can't find libs and other probs.
                                stop execution b4 debug start- create a break point in debug perspective.
                                opens the debug perspective- change back to C perspective to get back to project.
                        Edison Device- which has linux boots on getting power and connection to a master device (like pendrive PC (slave-master))
                                it reboots or use sudo screen /dev/ttyUSB0 115200 - screen (installable on ubuntu) program (OpS) boots the device
                                Enter login/pwd- root/easyiotg
                                $reboot to reboot- you get to access/ control the Edison (computer) device from this terminal.
                                $# configure_edison --wifi - gives access of internet
                                        use ifconfig to check its ip address under wlan0- note it down.
                                        Now, you can unplus connection to PC thru USB (cuz connected thru Internet)
                                        $#ping (notedIP)
                                $sudo ssh (notedIP) - to control the PC using secured shell.
                                Eclipse has built in ssh facility (using target selection view)
                                        create connection- choose your the IP or computer name from the list (refer to terminal for name)
                                        eclipse produces binary and runs it (?revelant parts) on Edison using ssh.
                                        It asks for credentials to execute.
                                        we will use libraries to command sensors or read them.
                                Devices
                                        Temperature and humidity
                                        LCD- shows text/data on screen
                                        servo motor- sets angle to what's stated- it's relative.
                                        Moisture-
                                        Light intensity reader
                                        Buzzer
                                        Moving object detector
                                How to execute
                                        get its header file- write on top
                                        get its libraries- use properties-> C->Libs->add libs (path pointed to ?usrLib)
                                        get info of all functions for sensing or actuating- make class- use methods (use ctrl+space to see properties)
                        Dashboard
                                $#iotkit-admin device-id	// to get device id
                                Google IOT intel dashboard; register with Google+
                                Add/Edit a device (link or Triple bars-> Device->add new)
                                use device id in step 1.
                                        else use iotkit-admin set-device-id (full device id + 1)
                                bars->account->see activation (code)
                                $#iotkit-admin initialize
                                $#iotkit-admin activate (code)
                                $# iotkit-admin catalog (shows default tables)- catalog
                                        use catalogs on dashboard to add new components- say (Light)
                                        $#iotkit-admin register Light light.v1.0
                                        bars->charts - you can see light component
                                $# iotkit-admin observation Light 40; 50;..
                                        These values show up on chart.
                                        set $# iotkit-agent ; b4 running if doesn't work
                                Adding a rule
                                        bars->Rules->add a rule->Notification type->email->next...
                                        Cloud can send an email, actuate thru a device, or use HTTP endpoint.

            </IOT>
            <WebDevelopment>
                Refer to Application Development section.
            </WebDevelopment>
            <NSW>
                Philosophy of Web (Deals a lot with psychology)
                Tool is sth that extends my abilities or senses; extension of myself.
                        eg- mic for speak,car walk, telescope/micro- see,
                        earlier web was thought as extension of our thoughts.
                        But web can even diminish our traits- like Intolerant debate.
                Socio-cognitive space
                        in 3-D space I am not jsut user but participant- things also influence me.
                                Eg- India Intolerant.
                        Not only User have a dominance over used. Used also has.
                        Characteristics of physical space vs web space
                                3 centuries of study of matter,energy,etc
                                Object can't be in places.
                                If object is stolen it is not with me. Eg- Car.
                                Web space
                                        Mysore is no nearer than UK.
                                        Friend in UK may be nearer- so socio-cognitive space- related to mind.
                                                Cognitive proximity.
                                        I/F can be in 2 places.
                                        If object is stolen, it may still be with me. Eg- Email
                Web Science
                        Coined by Tim Berners' Lee- http,html,www.
                                set policies and standards for web- w3c
                        For separate discipline to understand the web- what it is doing.
                                Making web observatories- eg- In IIITB first in India.
                        Course taught in 6 clgs inworld.
                        Course
                                Extensively uses psychology, sociology, political science.

                                Eg- Voting results of 2015- single party with such majority not imagined.
                                        coalition was commonly accepted notion. E1 to agree to 1 notion!!
                                        Web also garner opinions, engineer opinions- manipulate.
                                                Not person's but population surely.
                                                Web is a country in itself- because it has its own laws what to permit and not
                                Information is transitive- I mind with you. Your mind with tomato. I mind with tomato.
                                Super-intelligence of web- The web is creating a brain for the world
                                        we are individual neurons- sth like wikipedia- made by people.
                                                neuron doesn't understand the brain but contribs.
                                                Web's using you.
                                        People are not always intelligent but Collective wise intelligence > individual.
                                        People coaggulate in web- as per similarity of tastes like in real world but i/f remembered unlike real.
                                        Herd-mentality/group- people safe in groups.
                                        Network may feel fragmented but it is not- 6 hops to reach any person on web.
                                                I- Director- Modi- Obama.
                                                FB connects you Do You know as a friend? How can you tell!
                                                        Joke- Dog- Google- "How does it know I am a dog".
                                Course is to learn not for exam.
                                        Cuz reality doesn't give problems from syllabus
                                                JOke- Bridge fell- "what happened"- It was outta syllabus".
                                        Logs of classroom- revised in the next class.
                                        Use others' work but cite- not just their work- else they get the grade- sth built on top.
                                        etiquettes to counter an idea- Appreciate, attack on idea not person- can you explain? Or I didn't quite follow!
                                        I am guide on a tour- point is not to follow his trail but explore as much thru the trail.
                                        I don't want studs be factory products but well-informed free thinking people.
                                        More freedom for productivity or less freedom- More seems better.

                        Web Scientist
                                Interface of some copnay- manages Tata Motors presence on web- who access, where from, what talk!!
                                Subversive campaigns like Intolerance on Bihar Elections.
                                Facebook experiment
                                        You do get influenced by web.
                                        It knows more about you than you.
                                                You share your intimate details. 
                                                All Behaviors are public.- doubleClick.net cookie on my machine knows desktop work.
                                                I forget not the web.
                                                All AI at its best.
                                Net Neutrality
                                        Free Basics- THey get monopoly on what we see.
                                        FB will know eth about our health, RTI and will use/misuse i/f.
                                        data.gov.in- data of poor people present- someone can use it to exploit them.
                                                put credentials access. NGO- purpose!?
                                        2 types of data
                                                Encyclopediac data- high level- serves to inform you. Rainfall in BLR.
                                                Utilitarian data- information for stakeholders.
                                                        it is a property of relation between stakeholders and data- can use + and -
                                                        ICSC results made open in 2012.
                                                        Eg- satellite images make maps- Publishing maps- is dangerous for the country;s security- gov says- they anyway have.
                                                                areas blackened out- became easy for terrorist to zero down their search for some previous attacks.
                                Even in real life we keep giving information through clothes, gestures but never were they recorded.
                                        7 denied a job cuz of comment put 4 years back.
                                        Google may have more difficulty misusing data than others cuz of brand.
                                                @ Bail easy to get for ordinary person than famous one.
                                                Life traffic data from GPS mobile phones- ads is ok! How many really click there.
                                                        How can such biggy survive on ads.
                                                Not just ads- they sell statistical information to companies.
                                                        We agree on terms and conditions.
                                In real life we know what badge stands for, badge is a representation of someone's identity.
                                        vs for Computer- Badge is identity.
                                        if badge doesn't work- call up the manager to authenticate 7.
                                        Web is a global village- with exception- strong rules missing (like tribes use), can't leave the village.
                                                eg- FBI started following 7- who stopped using google after knowing privacy breach.
                                                If you are using Tor you are more a target tht you are doing sth phishy.
                                In a web- thru hyperlinks, what flows:- like pipeline, our attention flows.
                                        for a web-page rating- N unit of attention by 1 vs 1 unit by N
                                        Cursory attention vs sustained attention.
                                        Friendship is strong acquaitance- weak is also important.
                                Emotional cognition on web
                                        We can induce someone to laugh or terrorize.
                                        I can handle emotions cuz i have it @ I can handle kids as I was once.
                                        Emotion
                                                We have a firmware at birth on which we install OS,system prgm, application programs
                                                emotion is a psychosomatic phenomena- thinking affects our physical thru hormones.
                                                        Eg- adrenaline induced by leaders' passion- + or -- hilter.
                                        Emotional contagion
                                                It is infectious even without awareness
                                                        we are affected to share same emotions as our surroundings- laugh,terror,etc.
                                                Online Disinhibition effect
                                                        Thru smile you know I am joking when I say You idiot. But not so when sms.
                                Sense of Self
                                        Joke made on your country or city and you angry. Why?
                                                Sense of self is attached to it.
                                                You own it.
                                                You protect/ defend it like yourself.
                                                Eg- Aamir Khan on Intolerance.
                                        2 sense of self
                                                actor- what we project to the world.
                                                agent- what drives you.
                                                minimize the distance/difference between 2 - you are happiest but disparity.
                                                On web, are you actor or agent- Sir-"You make a king avatar. You are acting but that's what drives you on web"
                                                        you are king on web.
                                Branding
                                        We put a judgment on brand and non-brand.
                                        eg- haldiram tasty. other Mmmm.
                                        7 from MIT. Good for him!
                                        80% value of brand is given by 20% of people and other 80% enjoy 20% of brand value.
                                        No1 knows transmit Networks but it is made by Linus Torwolds- Who is brand?
                                        IBM I know but not its founder- what's brand?
                        Build computational model outta psychology of web.
                                Eg- Identify a celebrity on web.
                                        Influencer- nope! st simple people do better job
                                Media- Powerful but complex phenomenon
                                        It is there to show what's abnormal not normal.
                                                eg- dog bites man is not news but vv.
                                        What is shown in News people tend to take it as trend but they are in news cuz they are not.
                        Govt can punish bad acts
                            ensuring blocking of legal content is wrong and anti competitive behavior is investigated.
                            policy makers- how stern with net neutrality regulations.
                            Scheduling of packets makes experience seamless- voice category, email, heart monitoring, voice, video, emergecy services, etc.

            </NSW>
            <Troubleshoorting>
                Your DNS IP and DHCP IP are obtainable from ipconfig /all.
                        configurable from change adapter settings for your active networks.
                        both can be set to automatic from there.
                        https://www.quora.com/How-does-the-computer-know-which-DNS-server-to-use
                        man 5 /etc/resolv.conf
                        https://whois.icann.org/en/domain-name-registration-process
                NSLOOKUP for checking that translation is happening.
                PING that IP is approachable.
                nmap that a port is active at the specified IP.
            </Troubleshoorting>
        </CN>
        <GraphicsProgramming></GraphicsProgramming>
        <DistributedComputing></DistributedComputing>
        <UtilitySoftwares></UtilitySoftwares>
    </SystemSoftwares>
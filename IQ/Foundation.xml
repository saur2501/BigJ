<?xml version="1.0" encoding="UTF-8"?>
<Foundation>
        <Maths>
            <DiscreteMaths>
                Discrete maths- study of discrete structures which are abstract maths models dealing with discrete objects and relp betw them.
                    objects like Sets,Permutations,Graphs,FSA.
                Why? In many fields in CS- maths concepts used and they assume that knowledge. 
                        Not depth as maths stud necessary but decent knowledge
                        Stud should learn ability to think mathematically.
                        Fields of use- in almost every.
                                eg- programming- proving that program is correct.
                                AI- uses logic thoroughly.
                                Graph theory, FSA used- useful again.
                Prerequisite- nothing just maths maturity of high school student.
                Books for topics- IITM Lec-1, Refer Notes
                <SetTheory>
                    <Relation>
                        Graphs (IITM- 14-17)
                        Recurrence Relations (IITM- 32-34)
                    </Relation>
                    <Functions>
                        <Logic>
                            Maps from a set of statements (in a domain) to a binomial set of {True,False}
                            Reference- Logic(1-9)
                            <Applications>
                                    Must for CS
                                    for relational algebra of DBMS
                                    proving programs right
                                    AI
                            </Applications>
                            <PropositionalLogic>
                                    Made by greek philosophers- Socrates, etc
                                            for parliament- make sure only logical statements are made.
                                    English has proposition, assertion- orders,questions
                                            proposition- assertion either true or false but not both
                                                    truth value associated with every sentence.
                                                            False represented by 0.
                                                            True by 1.
                                                            Eg- 4 is prime- 0
                                                            3+3 = 6 1
                                                            Moon made of cheese 0
                                                    !Eg-
                                                            X + y = 4 	//not a proposition
                                                            x = 3	//can be true or false depending on value of x.
                                                            are you leaving	// it is a question not assertion.
                                                            buy four books	// it is an order
                                                    St assertions are not propositioin
                                                            This statement is false- Liar Paradox							
                                    <Usage>
                                            Propositional variable denotes arbitrary proposition with unspecified truth value
                                                    eg- P,q FOR SOME statement.
                                            <LogicalOperators>
                                                    Compound statement- connecting propostional variables thru connective, operates on 2 var (seq imp sometimes)
                                                    All have their symbolic notation
                                                    NOT- after Symbolic notation ~P or P' or others.
                                                    AND- P ^ Q (Conjunction)
                                                            eg-
                                                                    P: John is 6' tall.
                                                                    Q: There are 4 cows in the barn.
                                                                    P AND Q: John is 6' tall and there are 4 cows in the barn. True if both are true.
                                                    OR- P V Q. if any of statements is true (both).
                                                    XOR- Symbolic rounded plus. let's use @.Exclusive OR- either of statements is true but not both. Refer to TT.
                                                    <Implications>
                                                            P implies Q written as P -> Q and other.
                                                            P called premise,hypothesis,antecendent
                                                            Q- Conclusion,Consequence.
                                                            TT-
                                                                    00 1
                                                                    01 1
                                                                    10 0
                                                                    11 1
                                                            Feel convinced on all cases and their truth value.
                                                                    If moon is made of cheese, then earth is round is a true statement.
                                                                            Because F => F is T.
                                                                            Aryabhatta didn't allow that.
                                                                                    Unrelated statements not allowed.
                                                            Read as- P implies Q.
                                                                    If P then Q
                                                                    Q if P
                                                                            If P is true, Q is definitely true.
                                                                            //?If Q is true, P may be true, THere may be other unknown variable to make Q true
                                                                    Q follows from P.
                                                                            If P comes as Truth. Q automatically follows it as that.
                                                                    Q provided P
                                                                    Q is logical consequence of P.
                                                                    Q whenever P
                                                                    P is sufficient condition for Q.
                                                                            No more statements are required to establish Q as truth if P is truth.
                                                                            P is not necessary- as Q can become true because of some other variable implication also
                                                                                    While P can remain False, the P=>Q can still be true for Q to be true.
                                                                    Q is necessary condition for P.
                                                                            Q naturally emerges for P. So, Q necessarily has to be true for a possibility of P to be true
                                                                            it can't be true also ( if Q has dependence on another variable for its truth- like P ^ R => Q.
                                                                    P only if Q
                                                                            P has a chance to be true only when Q is definitely true.
                                                                            Q has to be true definitely for the chance of P to be true.
                                                            Eg- If right angled triangle then Pythagorus formula.
                                                            Converse- Q => P. Pythagorus formula holds then right angled- It so happens in this case but not always true with P=>Q.
                                                                    God exists => we can perceive him. 
                                                                            Converse- If we perceive God, He exists.	//is not true statement but converse is true
                                                                                    Taking converse as equivalent to proposition is a common mistake.
                                                                            It's contrapositive says if we can't perceive God, he doesn't exist.
                                                                            Contrapositive of converse says- If God doesn't exist then we can't perceive him.												
                                                            Contrapositive- ~Q => ~P. always true if P => Q is true- they are equivalent. Both true and false together
                                                                    If pythagorus formula doesn't hold, it is not right angled triangle.
                                                                    Draw TT for check of Equivalence of 2 wff- 2 columns become identical- equivalent- they are T and F together for cases.									
                                                    </Implications>
                                                    <Equivalence>
                                                            Symbolic notation/ denoted as <=>.
                                                            Used as P<=>Q
                                                            When both of the variables have the same values for cases.
                                                            TT-
                                                                    00 1
                                                                    01 0
                                                                    10 0
                                                                    11 1
                                                            read as-
                                                                    P is equivalent to Q.
                                                                    P if and only if Q.
                                                                    P is necessary and sufficient condition for Q.
                                                    </Equivalence>
                                                    NOR and NAND not covered
                                            </LogicalOperators>
                                            <TruthTable>
                                                Different Possibilities for formulae from logical connectives exist- 00,01,10,11 (2^n).
                                                    Help see all cases and value the result takes
                                                    P ^ Q- AND Denoted by ^
                                                            FF F ( also thru 0 and 1)
                                                            FT F
                                                            TF F
                                                            TT T
                                                    P V Q- OR (Disjuction)
                                                            00 0
                                                            01 1
                                                            10 1
                                                            11 1
                                                    P'- NOT P.
                                                            0 1
                                                            1 0
                                                    XOR- Exclusive OR.
                                                            00 0
                                                            01 1
                                                            10 1
                                                            11 0
                                                            Eg- Sudha is wearing Saree XOR Sudha is wearing Suit-salwar.
                                                            This statement can be true only if one of the statements is true and not both.									
                                                    Check for equivalence of 2 wff
                                                            n variable means n columns for then 2^n possible assignments, 2^n rows- all permutations.
                                                            compute possibilities of both wff to be true for different cases- 
                                                                    if they match- they are equivalent- meaning they are true or false together.
                                                                            so that the equivalent logical connective is a tautology.
                                                    TT drawing is costly operation 2^k Rows and evaluation- better we prove that all rows are 1 or 0 or at least 1 is 0/1.
                                                            working on algebra.
                                            </TruthTable>
                                            <WellFormedFomula>
                                                    abbreviated as wff.
                                                    Proposition formed by connecting propositional variables by 1 or more Logical connectives
                                                    eg- [(p^q)V~R]<=>P	//concept of precendence if no brackets used? which expression/[simple]formula should be evaluated first
                                                    eg- (Q ^ P) => P 
                                                            importance of bracket- The results are affected by the sequence of evaluation of an expression.
                                                    <InterpretingWff>
                                                    Precedence
                                                            NOT,AND,OR
                                                            when no ambiguity go ahead
                                                            but in ambiguity- proper paranthesis is a must.
                                                                    Eg- P => Q => R is not a valid wff.
                                                                            check for TT of (P=>Q)=>R and P=>(Q=>R)
                                                                                    go for the case specific look for only cases for which p=>q is false and fill 1 otherwise.
                                                    </InterpretingWff>
                                                    <TtForWff>
                                                            Statements always true are tautology and always false are contradictions
                                                            k distinct variables means 2^k rows and k columns- values from 0 to 2 ^ k - 1
                                                            we write in sequence from 000,001,..
                                                                    so that they can represent sequential numbers in decimal and 
                                                                    none of the permutation is missed
                                                            EXERCISE
                                                            TT is costly so prove through logical means also.
                                                    </TtForWff>
                                                    <Terms>
                                                            Tautology- Propositional form[ula] whose truth value is true for all possible values of its propositional variables.
                                                                    eg- P V ~P
                                                                            always true- because 1 of them is true and OR connected so true always.											
                                                            Contradiction or absurdity- ...always false.
                                                                    eg- P ^ ~P
                                                                            always false- because 1 of them is always false and AND connected.
                                                            Contingency- ...neither of the 2 above.
                                                                    Don't have to draw whole TT (costly)
                                                                    better prove that 1 row gets result 0 and 1 gets 1.
                                                                    Eg- (P ^ Q) => P can be true if hypothesis of implication P ^ Q is true
                                                                            and P ^ Q can be true for only when P = 1 and Q = 1
                                                    </Terms>
                                                    <Properties>
                                                        Logical Identities
                                                        Some rules or Tautologies
                                                            Idempotent
                                                                    P <=> P ^ P, P V P- Idempotence of V,^
                                                                    P V Q <=> Q V P.
                                                            Commutative
                                                                    P ^ Q <=> Q ^ P === Q ^ P- Commutativity of ^ and V
                                                            Associative
                                                                    P ^ (Q ^ R) <=> (P ^ Q) ^ R	//associativeity of ^,V
                                                            CS
                                                                    Implication is not commutative, not associative.
                                                                            so placement of bracket is extremely important in such cases and in general to avoid confusion.
                                                            De-Morgan's law
                                                                    ~(P ^ Q) === ~P V ~Q	//De-morgan's laws
                                                            Distributive
                                                                    [P ^ (Q V R)] <=> [(P ^ Q) V (P ^ R)]	//same with other
                                                                    In reverse direction also- sometimes.
                                                                            if commutative then change and then apply dist
                                                            P V 1 <=> 1
                                                            P ^ 1 <=> P
                                                            P V 0 <=> P
                                                            P ^ 0 <=> 0
                                                            P V ~P <=> 1
                                                            P ^ (~P) <=> 0
                                                            P <=> ~(~P)	//Double Negation.
                                                    More
                                                            (P => Q) === (~P V Q)	//implication
                                                                    Use this for simplification.
                                                                    Either P is false,then we don't care for Q's value or Q is true, that's because if P was true, Q will have to be.
                                                            (P <=> Q) === (P=>Q) ^ (Q=>P)	//Equivalence
                                                            ((P ^ Q) => R) === (P => (Q => R))	//Exportation
                                                                    P and Q taken together Imply R. So, If P is true, then if Q is given to be true, R becomes true.
                                                            (P->Q) ^ (P->~Q) === ~P		//Absurdity
                                                                    Used in proofs by contradiction.
                                                            P -> Q === ~Q -> ~P	//contrapositive
                                                    </Properties>
                                                    <SimplificationOfWff>
                                                    Simplifying wff/logical expressions
                                                            We use Properties or logical identities of wff to simply them'
                                                                    eg- [(A => B) V (A => D)]=>(B V D)
                                                                            [(~A V B) v (~A V D)] => (B V D)
                                                                            [~A v (B V D)] => (B v D)
                                                                            ~[~A v (B V D)] v (B v D)
                                                                            [A ^ ~(B v D)] v (B v D)
                                                                            [A v B v D]^1
                                                                            A v B v D												
                                                    </SimplificationOfWff>
                                                    <LanguageToLogicalExpressions>
                                                    Conversion from language to logical expression and vv
                                                            eg- for english- It is snowing. I will go to town. I have time. P,Q,R
                                                                    (i)If it is not snowing and I have time, then I will go to town- (~P ^ R) => Q
                                                                    (ii) I will go to tmie only if I have time- 
                                                                            Q => R
                                                                    (iii) It is not snowing- ~p
                                                                    (iv) It is not snowing and I will not go to town
                                                                            P ^ ~Q.

                                                                    (i) Q <=> (R ^ ~P)
                                                                            I will not go to the town iff I have time and it is not snowing.
                                                                    (ii)R ^ Q
                                                                            I have time and I will go to town.
                                                                    (iii)(Q => R) ^ (R=>Q)
                                                                            I will go to town only if I have time and If I have time I will go to town.
                                                                            OR I will go to town iff ( if and only if ) I have time.
                                                                    (iv) ~(R v Q)
                                                                            It is not true that I have time or I will go to town.
                                                    </LanguageToLogicalExpressions>
                                                    <LogicalImplications>
                                                            Used 
                                                                    to properties above to simplify wff or 
                                                                    conclude from sthRules of inference
                                                            Some Basic Rules
                                                                    P => (P v Q)	//addition											
                                                                    (P^Q) => P	//simplication
                                                                    (P^(P=>Q))=>Q	//Modus Ponens
                                                                            (P,P=>Q)/Q- Written as this.
                                                                    ((P=>Q)^~Q)=>P	//Modus Tollens
                                                                    (~P^(PvQ))=>Q	//Disjunctive syllogism
                                                                    ((P=>Q)^(Q=>R))=>(P=>R)	//Hypothetical Syllogism
                                                                    ((P=>Q)=>(Q=>R))=>(P=>R)
                                                                    ((P=>Q)^(R=>S))=>((P=>R)^(Q=>S))
                                                                    ((P<=>Q)^(Q<=>R))=>(P<=>R)
                                                            <Problems>
                                                                    A Town every person is Truth Teller or liar- approaching person should ask 1 question to take left or right road based on Yes,No reply from town citizen- what should his question be?
                                                                            Consider 4 possibilities
                                                                                    Person_maybe Which_is_true_road
                                                                                    TT Left
                                                                                    Liar Left
                                                                                    TT Right
                                                                                    Liar Right
                                                                                    A- If I asked you which road to take what will you tell me?
                                                                                    A- What would other native suggest me to take?
                                                                                    SOln- Yes- Take left and No- Take right
                                                                                            Make a table.
                                                                                                    Left	Right
                                                                                            TT	Yes	NO
                                                                                            Liar	Yes	No

                                                                                            But since liar inverses the answer so Question's natural answer should be-	//we are backtracking for soln
                                                                                                            Left	Right
                                                                                                    TT	Yes	No
                                                                                                    Liar	No	Yes
                                                                                            We have to find a question for which answer- such configuration comes
                                                                                                    Ans- is it true that you are a truthteller and the left road lead to the capital or you are a liar and the right road leads to capital.
                                                                                                            check for all 4 possibilities
                                                                                                    Ans- If I ask you whether the left leads to capital you will say "yes", won't you?
                                                                                                            //more of using psychological lie to invert itself for truth to come up
                                                                                                    And- If I ask the other kind of person whether the right road leads to capital, he will say "yes" won't he?
                                                                                                            This is more of awareness of psychology of other- Truthteller- tells the wrong way and Liars inverts the true road to tell the wrong.
                                                                                                            Present me his psyche- Liar inverts the right path to us to make a decision clear.
                                                                    A,C men and B,D women; E murdered. All survivor make make 2 statements- out of 8 statements 4 are true- who did murder?
                                                                            A: I am innocent, B was talking to E when the train was passing through the tunnel.
                                                                            B: I am innocent; I was not talking to E when the train was passing through the tunnel.
                                                                            C: I am innocent; D committed the murder.
                                                                            D: I am innocent; one of the men committed the murder.
                                                                            Analysis- 
                                                                                    A- 1 2
                                                                                    B- 1 2
                                                                                    C- 1 2														
                                                                                    D- 1 2
                                                                                    //3 out of '1' are true and 1 is false- so 1 out of '2' is true and others false.
                                                                                    A and B's '2' is negation of the other- so one is true, other is not. sp. C and D's '2'	are false
                                                                                    C says D committed the murder- is false- so,D has not committed. D says it was 1 of the men- is false- so It was a woman who committed. D didn't commit it- so B did.
                                                                    X,Y,Z- TT,Liar,St true/false- Tourist has to identify them by asking 3 questions each in yes/no.
                                                                            //TODO
                                                                    X,Y,Z suspected of income tax evasion- tesify under oath- who are guilty/ innocent under case a,b.
                                                                            X: Y is guilty and Z is innocent.
                                                                            Y: If X is guilty, then so is Z.
                                                                            Z: I am innocent but at least one of the others is guilty.
                                                                            case a> all told truth.
                                                                                    Y is guilty and Z is not. Take contrapositive of Y's statement- X is not guilty.
                                                                            case b> Innocent told truth and guilty lied who is/ are innocent or guilty.
                                                                            Soln	
                                                                                    a>
                                                                                            x: X is innocent- ~X So with Y and Z.
                                                                                            X says- ~y ^ z
                                                                                            Y: ~x => ~z === z=>x
                                                                                            Z: z ^ (~x v ~y)
                                                                                            From Z, z is innocent. so x is innocent.from X, y is guilty.
                                                                                    b>
                                                                                            Possibilities-
                                                                                                    i. X is innocent- he tells truth
                                                                                                            so Y is guilty and Z is innocent.
                                                                                                                    Means Z will say truth and Y false.
                                                                                                                            Z's statement consitent but Y's inverse contradicts. Not Possible
                                                                                                    ii. X is guilty
                                                                                                            X	G	G	G	G
                                                                                                            Y	I	I	G	G
                                                                                                            Z	I	G	I	G
                                                                                                            X is telling a lie for sure being guilty.
                                                                                                            so, y v ~z- either Y is innocent or Z is guilty.
                                                                                                                    i> Y is innocent and Z is guilty
                                                                                                                            so Y being true, X is guilty then Z is guilty. So Z says wrong.
                                                                                                                            Z says he is innocent, and someone else is guilty.
                                                                                                                            It's inverse is Z is guilty OR X and Y are innocent. So, Z is guilty.
                                                                                                                            We have an ANSWER HERE.
                                                                                                                    ii> Y is innocent and Z is innocent.
                                                                                                                            Y concludes Z is guilty.
                                                                                                                            Z says he is innocent. Contradiction if both say truth.
                                                                                                                    iii> Y is guilty and Z is guilty
                                                                                                                            Inverse of Z- ~z v (x ^ y) says either z is guilty or x and y are innocent.
                                                                                                                                    so, z is guilty.
                                                                                                                            Inverse of Y- is true- 
                                                            </Problems>
                                                    </LogicalImplications>
                                            </WellFormedFomula>
                                    </Usage>
                            </PropositionalLogic>
                            <PredicateLogic>
                                    Assertions but not propositions because depend on the values we give to them
                                    Eg- 	
                                            x > 3
                                            x + y = 7
                                            She is tall and fair
                                            x was born in city y in the year z	// x from set of humans, y from set of places and so forth.						
                                            In C, if ( x > 3 ) then y = 5 else y = 7;					
                                    Denoted by P(x,y,z)						
                                            can have Predicate constants
                                            Predicate variables	// under a domain
                                            Eg- 
                                                    M(x,y) x is married to y.	//x and y from set of human being set.
                                                    Sum(x,y,z) defined as x + y = z
                                                    P(x,3,y)
                                    Types
                                            P(x) unary							
                                            Q(x,y)- binary
                                            n-ary or n-place predicate- P(x1,x2,..xn)
                                    Depending upon the values of ALL individual variable give proper truth value- become preposition
                                            Valid
                                                    If P(x1,x2,..xn) is true for all values c1,...cn from universe U then we say P(x1,..xn) is valid in U.
                                            Satisfiable
                                                    If for at least 1 it is true we say predicate is satisfiable in U.
                                            Not true for any values in domain of Universe it is said to be Unsatisfiable.
                                    Universe of Discourse
                                    <Binding>
                                            Giving values of predicate variables from the universe is called binding variable						
                                                    can be any data type chosen from particular domain of values- called domain of universe or Universe.								
                                                            real numbers, strings, element in set of human beings,etc.						
                                                            statement can be true for 1 universe and not for other- need to specify and st it is implicitly understood.
                                                    The variable not binded is called free.
                                                            Eg- There exists y s.t sum(x,y,z) as x+ y =z where U is non-negative integers 
                                                                    this means that x<=z is the predicate.
                                            <Quantifiers>
                                            Quantifiers{- Binding can be done with quantifiers.
                                                    Universal Quantifier
                                                            For All x, P(x), see symbol.
                                                            For all values in the universe domain
                                                            if U = {1,2,3}, for all x means P(1) ^ P(2) ^ P(3) is true.
                                                            Also called
                                                                    for every x
                                                                    for each x
                                                                    for any x
                                                                    for arbitrary x.
                                                            Eg-
                                                                    For all x in Integers, [x < x + 1]	this is always true
                                                                    FOr all x, x= 3, for universe of Integers, this becomes preposition becomes false.
                                                                    For All x, x = x+1 is false for this universe
                                                    Existential quantifier
                                                            There exists, check for symbols
                                                            For some x, this is true
                                                            if U = {1,2,3}, there exists x means P(1) v P(2) v P(3) is true.
                                                            Eg-
                                                                    For some x in Integers, [x < x + 1]	this is true for some
                                                                    There exists x, x= 3, for universe of Integers, this becomes preposition is true for someone.
                                                                    There exists x, x = x+1 is false for this universe
                                                    There Exists unique x for which P(x) is true-
                                                            there is 1 and only 1 x s.t P(x) is true.
                                                            Symbol- (There exists)!x								
                                                            if U = {1,2,3}, for all x means (P(1) ^ ~P(2) ^ ~P(3)) v (~P(1) ^ P(2) ^ ~P(3)) v (~P(1) ^ ~P(2) ^ P(3)) is true
                                                            OR U = {0,1...}, can say there exists y in P(x1,x2,...xn). since y not in predicate variable it doesn't matter.
                                                                    Eg-
                                                                            There exists unique x in Integers, [x < x + 1]	this is false because not unique.
                                                                            There exists unique x, x= 3, for universe of Integers, this becomes preposition is true for 1.
                                                                            There exists unique x, x = x+1 is false for this universe
                                                                    It is rarely used because can be expressed in terms of former
                                                                            There exists x s.t. (p(x) ^ for all y (P(y) => x = y))
                                                    There exists at  most 1 x
                                                            There exists x and for all y for which P(y) => x=y
                                                    Does sequence matter for all x there exists y vs there exists y for all x
                                                            both are same quantifier- no problem- it won't affect
                                                            different quantifiers- it affects.
                                                            Logical- For all x for all y P(x,y) means for all y P(0,y) ^ for all y P(1,y) ^ ...
                                                                    opening up y, makes it (P(0,0) ^ P(0,1) ^ .....) ^ (P(1,0) ^ P(1,0) ^ ....) ^....
                                                                    ~ for all y for all x means (P(0,0) ^ P(1,0) ^ ...)^ (P(0,1)^ P(1,1)^...)^...
                                                                    we can experience that they are essentially same as ^ is commutative and associative.									
                                                            Eg- 
                                                                    for all x there exist y s.t x is married to y means e1 is married to someone is true.
                                                                    VS there exists y for all of x s.t x is married to y. there exists y who married to e1 in universe including himself. False definitely.
                                                            Eg-	
                                                                    For all x there exists y s.t x+ y = 0, yes and that is y is -x
                                                                    there exist y for which all of x get x + y = 0 false statement
                                                            eg-
                                                                    for all x,y there exists unique z s.t x + y = z
                                                                    for all x, there exists z for which all y get x+ y = z
                                                            eg-
                                                                    there exists unique x s.t x.6=0 that is 1
                                                                    there exists unique x for which all y give the value 0 is true.
                                                                    for all y there exists unique x for which x.y=0 as for y=0 there are many x.

                                                                    for all y there exists unique x s.t x+ y < 0 false because many x can be chosen for any y.							
                                            </Quantifiers>
                                            For all x, and a given condition written as subscript after for all x, say x>3 will subscript and then predicate.
                                    </Binding>
                                    <LogicalImplications>
                                            For all x, p(x) means p(c) where c is arbitrary element of universe
                                            for all x,P(x) means there exists x, P(x)
                                            if ,p(c) then there exists x s.t. p(x)
                                            It doesn't follow distributive law over a formula.								
                                            Distributive for all over ^
                                                    for all x in P(x) ^ For all x in Q(x) is equivalent to for all x in P(x) ^ Q(x)
                                                    Proof- Set of non-negative integeres- expand both of them and club them together using commutativity and associativity.
                                            Distributive for all over v
                                                    For all objects of x it doesn't hold.
                                                    for all x P(x) v for all x Q(x) not same as for all x, P(x) v Q(x)
                                                            Eg- for all x, x is even v for all x, x is odd is false but for all x, x is odd or even is true.
                                            Distributive of there exists over v
                                                    group similar to the former case of for all over ^
                                                    but not over v.
                                                    Q- does there exist distributes over implies
                                                            there exists x P(x) => there exists x Q(x) Is It Equivalent to there exists x P(x) => Q(x)
                                                            there exists x, P(x) => Q(x) means same as there exists ~P(x) v there exists x, Q(x)
                                                            ~(For all x,P(x)) v (there exists x, Q(x))
                                                            means for all x P(x) => there exists x, Q(x)
                                                    So Not equivalent- draw TT to be sure(3 columns- for all x P(x), there exists x, P(x) and there exists x, Q(x)),
                                                            2 rows not applicable, there exists x P(x) can't be zero if for all x, P(x) is true.
                                                            2 cols don't match- but 2 implies the other- antecedent can be false for those entries- 
                                                                    there exists x P(x) => there exists x Q(x) implies for all x, P(x) => there exists x, Q(x)										
                                            Not for all x P(x) means same as There exists x for which ~(P(x) true)
                                            Not for some x P(x) means same as for all x, ~(P(x) is true)
                                                    eg-
                                                            Not for all x for all y there exists z P(x,y,z) bring not inside one by one
                                                            there exists x not for all y ... THEN there exists x there exists y Not ...
                                                            THen There exist x there exist y for all z ~(P(x,y,z)).
                                                    eg- 
                                                            For all x for all y there exists z x+z=y
                                                            for any value of x and y you can find y s.t. get that outcome.
                                                                    if defined over I and N then y >=x for it to be true.
                                                                    Negation of it will be- There exists x there exists y for all z x+z!=z
                                            (for all x, P(x))^Q === for all x, (P(x) ^ Q)	//same with v. and there exists.
                                            for all x, P(x) ^ for all x, Q(x) => for all x, (P(x) v Q(x))	//implies not equivalent so with ^
                                    </LogicalImplications>
                                    <LogicalNotations>
                                    Language to logical notations using quantifiers and predicate{
                                            Eg
                                                    N(x) x is non-negative integer
                                                    E(x) x is even
                                                    O(x) x is odd
                                                    P(x) x is prime.
                                                    a> there exists an even integer
                                                            there exists x E(x)
                                                    b> every integer is odd or even
                                                            there exists x (E(x) v O(x))
                                                    c> all prime integers are nonnegative
                                                            for all x, P(x) => N(x)
                                                    d> the only even prime is 2
                                                            for all x, P(x)^E(x)=> x=2
                                                    e> There is only one and only even prime
                                                            there exists unique x, E(x) ^ P(x)
                                                    f> not all integers are odd
                                                            not for all x O(x) or There exists x ~O(x)
                                                    g> not all primes are odd
                                                            not for all x, P(x) => O(x) OR there exists x P(x) => ~O(x)
                                                    h>if an integer isnot odd, then it is even
                                                            for all x, ~O(x) => E(x) means same as for all x, O(x) or E(x)
                                            Eg
                                                    for all N,xy =z P(x,y,z)
                                                            write for if xy =x for all y, then x=0
                                                                    for all x ( for all y, P(x,y,x) => x = 0)
                                                                    not putting bracket means for any x and y, take x=1 and y=1, and xy=x is satisfied, so false.
                                                            if xy != x for some y then x!=0
                                                                    for all x ( there exists y for which ~(p(x,y,x) => x!=0 ))
                                            Eg- 
                                                    limit rule in calculus
                                                            For all x change small near c, value of k doesn't change much.
                                                                    for all of eps>0, there exists delta 0, for all x ((x-c) < Delta => |f(x)-k| < eps);
                                                            for lim x->c f(x) != k
                                                                    Just take NOT Of above formula and use logical notations.
                                                    P(x)-prime,Q(x)-positive,E(x)-even,N(x)- x divisible by 9,S(x) x is a perfect square, G(x)- greater than 2.
                                                            i> P(x) v S(x)
                                                            ii>P(x) => G(x)
                                                            iii>...
                                                    Not all cars have carbonators
                                                            ~for all x(Car(x) => Carborator(x)).
                                                            there exists x car(x) ^ ~carborator(x)
                                                    No Dogs are intelligent
                                                            For all x(dog (x) => ~intel)
                                                            ~there exists x, (dog(x) ^ intel(x))
                                                    Some no are not real
                                                            there exists x, num(x) ^ ~real(x)
                                                            ~for all, ~(num(x) ^ ~real(x))...
                                    </LogicalNotations>
                                    <ValidityOfWFF>
                                            Wff of 1st order logic is called predicate
                                            wff of predicate logic  is valid if it is true for all universes and interpretations of predicate variables- Corresponds to tautology in Prepositional logic.
                                            eg- 
                                                    for all x in P(x) => there exists x in P(x) is true.
                                            wff is true for some universe and some interpretation then it is said to be satisfiable- contingency.
                                                            if wff is not true for any universe and any interpretations- it is called unsatisfiable- contradiction in prepositional logic
                                    </ValidityOfWFF>
                            </PredicateLogic>
                            <LogicalInference>
                                    Several theorem/system- arithmetic( universe or integers)- axioms- addition, subtraction and some rules of inference,axioms to deduce sth inference about the system.
                                            they are called theorems derived from axioms using rules of inference to reach theorem.
                                            apply rules of inference wrongly spoils conclusion.
                                     All discussed b4- more
                                            (P=>Q) ^ (R=>S) and given P v R gives Q v S	//constructive diellema
                                            (P=>Q) ^ (R=>S) and given ~Q v ~S gives ~P v ~R	//destructive diellema.
                            </LogicalInference>
                            Resolution Principle
                            Methods of Proof
                            Normal Forms
                            Proving Programs correct
                        </Logic>            
                    </Functions>
                    <Counting>
                        <PegionHolePrinciple></PegionHolePrinciple>
                        <PermutationAndCombination></PermutationAndCombination>
                        <BinomialTheorem>
                            (a+b)^n = SIGMA(nCr.a^n-r.b^r) over 0 thru n.
                                Proof- While expanding for any a^(n-k).b^k- any of k b's can participate- we can choose k b's in nCk ways and remaining cells reserved for a^(n-k)
                                    ?a and b are replaceable being symmetrical.
                                Pascal Triangles- Easy way to remember coefficient- incremental diamonds from previous case (refer pix)
                        </BinomialTheorem>
                    </Counting>
                    <GroupTheoryAlgebra>
                        <Magma>Closure under the binary operation- any element operation with another element gives an element within the set (never outside).</Magma>
                        <Semigroup>Magma with associativity (order of operation doesn't matter) of the operation amongst its elements.</Semigroup>
                        <Monoid>A semigroup with an Identity Element. Any element operation that identity element gives itself. Eg- Matrix</Monoid>
                        <Group>A Monoid with a unique inverse element for every element. Any element when operation with its inverse, gives identity as answer. Eg- Set of Invertible matrices.</Group>
                        <Others>Quasigroup (magma with divisibility), Loop (Quasigroup with identity), Group (Loop with associativity)</Others>
                    </GroupTheoryAlgebra>
                </SetTheory>

                <Probability>
                    Prob(H) = # of possibilites that meet by condition / # of equally likely possibilities.
                        #How much (degree of) favorable (%age) an outcome is from a set of possible outcomes.
                            think cardinality of set and its subset.

                        <Object>
                            <SampleSpace>
                                Possible Outcomes of an experiment with an object.
                                Eg- 
                                Coin
                                    Sample Space = {H,T}.
                                Dice
                                    Sample Space = {1,2,3,4,5,6};
                                Cards
                                    4 suits- Heart,Spade,
                                    13 cards for each suit- 1,2,3,4,..10,J,K,Q.
                            </SampleSpace>
                            <UnbiasedObject>
                                The set of all Events are equally likely to happen.
                                Involve counting on the elements of sets alone.
                                Coin
                                    P(H) = 1/2 ; Possible outcomes = 2 {H,T}, Favorable = 1 {H}
                                Die
                                    favorable outcomes = {1}
                                    P(1 in die) = 1/6
                                Cards
                                    P(Jack) = 4/52; P(Heart) = 13/52 = 1/4
                            </UnbiasedObject>
                            <BiasedObject>
                            Not Equally Likely Events
                                P(H) = 0.6 then P(T) = 1-0.6 = 0.4
                                P(H1H2) = P(H1).P(H2) = 0.6*0.6 = 0.36
                                P(T1H2T3) = P(T1).P(H2).P(T3) = 0.4*0.6*0.4 = 0.096 = 9.6%
                                Decision tree may be helpful in finding Probability along a path.
                            </BiasedObject>
                        </Object>
                        <Trial>
                            aka Experiment- is what completes the process and observing the outcome.
                            <SingleEvent>
                                On single event per trial- single task and observation is noted.
                                Combined by AND, OR, NOT
                                Countings on Set theory (set construction)
                                <MutuallyExclusive>
                                    Mutually Exclusive Outcomes- P(A AND B) = 0 then A and B are Mutually Exclusive events.
                                        Eg- P(3 ^ 4 in throw of die (singular of dice)) = 0
                                        P(1 or 6) = 2/6 = 1/3
                                        P(2 and 3) = 0/6 = 0; P(Even) = 3/6 = 1/2                            
                                        Eg- Probability that number selected amongst following is divisible by 5 = 7/12.
                                        Eg- P(Point selected at random falls in inner circle) = Area of inner circle/ Area of Outer Circle = 16 PI/ 324 PI = 4/81.
                                            Here both the sets are infinite but ratio (degree of favorable outta sample space) is measurable (think of area as a set of square points in unit^2)
                                    Not MEO
                                        But P(Heart ^ King) = 1/52 != 0
                                            The outcomes of an experiment are not mutually exclusive.
                                        P(Jack and Heart) = 1/52; P(J or H) = (C(J)+C(H)-C(JH))/C(Cards) = (4+13-1)/52 = 16/52 = 4/13
                                        Eg- Shape Selection
                                            Cubes- 8 Green, 5 Yellow, Spheres- 9 Green, 7 Yellow.
                                            P(Cube)=13/29; P(Yellow) = 12/29; P(Yellow or Cube) = (P(Y)+P(Cube)-P(Y AND Cube))/Total = (12 + 13 - 5)/29 = 20/29
                                </MutuallyExclusive>
                                <ExhaustiveOutcomes>
                                    Exhaustive set of outcomes- the scope of sample space
                                        Eg- for coins, P(H)+P(T)=1     //H and T are exhaustive set of outcomes.
                                        Eg- for die, 1 thru 6 are exhaustive set.
                                    P(A)+P(A')=1
                                        P(A) = 1 - P(SampleSpace-A)                                    
                                        Eg- 
                                            P(T) = 1- P(H)
                                            P(Even on die) = 1 - P(Odd on die)                                        
                                    More on this later.
                                </ExhaustiveOutcomes>
                            </SingleEvent>
                            <CombinationOfEvents>
                                A trial/ experiment consists of more than 1 events.
                                <Combinatorics>
                                    Count number of ways a favorable combination can be made outta possible ways.
                                    Eg- P(exactly 3 heads outta 5 flips) = 5C3/2^5 = 10/32 = 5/16.
                                        //picking 3 heads outta 5 in 5*4*3 ways but Ha,Hb,Hc are replaceable with each other s.t HaTTHbHc is same as HbTTHaHc and is same as HbTTHcHa 6 such (3*2*1)
                                    Eg-P(k heads in n flips of a fair coin) = nCk/2^n.
                                        //n.(n-1)...(n-(k-1)) permutations but redundant intermixing, number of times 1 term repeats = k(k-1)..1 (HaHbHc arranging), unique combinations = n!/k!(n-k)!
                                </Combinatorics>
                                <ExhaustiveOutcomes>
                                Exhaustive events (only possible candidates)
                                    Eg- RGB- 9,3,2
                                        P(Non Blue marble) = 12/14 =6/7;
                                        Or P(Blue) + P(Non Blue) = 1 => P(Non Blue) = 1 - 2/14 = 6/7
                                    P(at least 1 H in 3 flips) = outta {HHH,HHT,HTH,HTT,THH,THT,TTH,TTT} only {TTT} is unfavorable = 7/8
                                        = 1 - P( No Heads) = 1 - P(TTT) = 7/8   (cuz P(All Tails) + P(Not all tails) = 1)
                                    P(at least 1 head in 10 flips) = 1 - P(10 tails in a row) = 1023/1024
                                    Eg- P(At least 2 people out of 30 have same birthdays) = 1 - P(No have same birthdays)
                                        1st person can select his birthdays in 365 ways, 2nd person in 364 ways (to keep it different), 3rd in 363, so on 30th in 336 ways.
                                        Total Possible ways of birthdays- e1 can choose in 365 ways.
                                        P(None same day birthday) = 365.364..336/(365)^30 = (365)!/(335!.(365)^30)
                                </ExhaustiveOutcomes>
                                <IndependentEvents>
                                    Event carried out more than once with 1 not influencing the other.
                                    Involve Cartesian Product of 2 sample spaces.
                                Independent- 1 event doesn't affect or influence the other
                                    P(I1.I2)= P(I1).P(I2)       //means probability of I1 and I2 (happening after other)
                                        why? Prob(I1)=a1/b1 means b1k1 possibilities exist, outta which a1k1 are favorable.
                                        P(I2)=a2/b2 means b2k2 possibilites exist outta which a2k2 are favorable.
                                        Total Possibilities = Cartesian Product = b1k1*b2k2 (nth in common being independent)
                                        Favorable outcomes = Cartesian Product = a1k1*a2k2
                                        P(I1 AND I2) = P(I1 happening and I2 happening) = (a1k1*a2k2)/(b1k1*b2k2) = (a1/b1).(a2/b2) = P(I1).P(I2)
                                    Eg- P(HH) = 1/4 (1st toss can have 2 outcomes and 2nd toss also- cartesian product- 4 possibilities)
                                    Eg- P(7 on 2 dice)- Experiment is done twice and outcome of 1 does not affect the other.
                                        P(7 on 2 Dice)= |{(1,6),(6,1),(2,5),(5,2),(3,4),(4,3)}|/36 = 6/36 = 1/6.
                                    Eg- P(exactly 1 head in 4 toss) = P(HTTT)+P(THTT)+P(TTHT)+P(TTTH)
                                        = 1/16+1/16+1/16+1/16 = 1/4
                                        P(exactly 2 heads) = 4C2/16 = 6/16 = 3/8
                                            //I can choose 1 H in 4 ways (slots) and 2 H in 3 ways so 12 ways but being replaceable, every sequence will repeat twice for 1st H and 2nd H can be arranged in 2 ways, 6 ways for HH.
                                    Eg- P(THT) = P(T1H2T3) = 1/2.1/2.1/2 = 1/8
                                    <DecisionTree>
                                    Decision Tree- Make a tree of possibilites and multiply the edges to obtain net probability.
                                        P-H-H 1/2.1/2 = 1/4
                                        | |-T
                                        |-T-H
                                          |-T
                                    </DecisionTree>
                                </IndependentEvents>                            
                                <ConditionalProbability>
                                    Where result of 1 event depends on previous event.
                                Conditional Probabilities
                                    P(H/2sided Head) = 1, P(H/unbiased coin) = 1/2
                                    10 coins- 9 normal unbiased and 1 2-sided. Pick a coin and toss 5 times, probability of 5 heads?
                                    P(2s) = 1/10; P(n)=9/10.
                                    P(5H/2s) = 1; P(5H/n) = 1/32
                                    Make a decision tree for better understanding- 
                                    P(5H) = P(5H on 2s) + P(5H on n) - both of these are favorable for outcome.
                                        =(9/10).(1/32)+(1/10).(1) = 41/320
                                    Eg- 8 coins (3 unfair with 0.6 for Heads), random pick and 2 flips-  P(2H)?
                                        P(fair)=5/8,P(unfair)=3/8; P(HH/fair)=0.25, P(HH/unfair)=0.36
                                        P(HH) = P(fair AND HH) OR P(unfair AND HH) = P(fair).P(HH/fair)+P(unfair).P(HH/unfair) = (5/8)*0.25+(3/8)*0.36 = 0.29
                                    Bayes Theorem- Construct 2 subsets- Normal and 2Sided Coins getting selected.
                                        Normal has a subset of P(HH) given the normal coin- call this area as ar(phh)
                                        Similarly, 2-Sided coin has a subset of P(HH) given the 2S coin (others being 1-P(HH))- call area as ar(2hh)
                                        P(N/HH) means given that HH came as an outcome, what is the chance that you had chosen a normal coin.
                                            This is the ratio of ar(nhh)/(ar(nhh)+ar(2hh)).
                                            Also, think of it as P(N ^ HH)/P(HH) - This makes sense, now.
                                        P(A ^ B) = P(A/B).P(B) = P(B/A).P(A)
                                            Thus, P(B/A) = P(A/B).P(B)/P(A)
                                            In Some cases, P(A) = SIGMA(P(A/Ci).P(Ci))
                                </ConditionalProbability>
                            </CombinationOfEvents>
                        </Trial>
                        A person flipping switch randomly vs Probability (random switching)- Flipping by person will be uneven (bias), random switching will show all combinations of 3 equally likely almost.
                        <Study>
                            Random Variable- The outcome of an experiment- denoted by a variable name and every outcomes are candidate values (in numbers) for that variable.
                                Eg- X denotes outcome of toss- for heads outcome, X gets value 1, for tails it gets 0.
                                Associate values aptly for the purpose- eg- let X take values of time taken for the permutation for quick sort.
                                Discrete- A set of definite values that Random variable can take.
                                    Plot a graph- area under curve of SIGMA(P(X)) = 1.
                                    Eg- A die is thrown, Random variable X takes values from 1 thru 6 (vals on face)- face 6 is printed in place of 2.
                                        Biased case, P(6)=2/6.
                                        P(X=1) = 1/6; P(X >= 5) = P(5 on face) + P(6 on face) = 1/6 + 2/6 = 1/2.
                                    Eg- Let X denote no of heads out of 5 that show heads- 
                                        P(X=4) = 5C4/2^5 = 5/32.
                                        X   P(X)
                                        0   1/32
                                        1   5/32
                                        2   10/32
                                        3   10/32
                                        4   5/32
                                        5   1/32
                                        Plot it on graph- it makes a bell like curve.
                                            REL make an excel with P(make) and P(miss) defined, for all X=0 thru 5 (using formula)
                                        Defining Mean
                                            Mean = SIGMA(No of times*theNumber)/Total Numbers = SIGMA((No of times/TotalNumbers)*theNumber)=SIGMA (P(theNumber)*theNumber) = SIGMA(X.P(X))
                                        Binomial Probability- when there are only 2 possible outcomes (win or lose).   
                                            P(S) = p, P(F) = 1-p
                                            Let X denote No of success out of n trials (experiments)
                                            P(X=k) = nCk.p^k.(1-p)^k    (being independent events- we just need to choose k success slots out of n)
                                            E(X) = SIGMA(k.P(X)) = SIGMA (k.nCk.p^k.(1-p)^k) = np.SIGMA((n-1)C(k-1).p^(k-1).(1-p)^(n-k)) = np
                                Continuous- There are infinite values that Random variable can take.
                                    Eg- Rain (in height) fell on a day.
                                    Can be conceived as small infinite strips of discrete values.
                                    P(2cm) = P(area under a certain range) = P(|Y-2|<.1)
                                    Eg- Area under the curve = 1 (cuz SIGMA(ExhaustiveOutcomes)=1)
                                    Poisson's Probability- Special case of binomial Probability.
                                        Say, T cars were observed to pass thru a point in an hour.
                                        X = No of cars passing in an hour (thru a point)
                                        Average cars per minute = T/60 cars/min (Probability of seeing a car in a minute)
                                        Probability that k cars pass an hour
                                        P(X = k) = 60Ck.(T/60)^k.(1-T/60)^(60-k)    // Think of it as 60 trials (experiments) in which T times we got success
                                        Go more granular cuz 2 cars may pass thru a point in a minute and our experiment fails.
                                            Probability of 3600 experiments (1 per second)- Probability of finding a car in a second = T/3600.
                                            Let's make n experiments, being infinitely large.
                                        P(X = k) = LIMIT nCk.(T/n)^k.(1-T/n)^(n-k) with n -> INFINITY
                                            = LIMIT (n(n-1)(n-2)..(n-k+1)/n^k).(T^k/k!).(1-T/n)^n.(1-T/n)^-k      with n-> INFINITY
                                            = (T^k/k!).LIMIT((n^k+....)/n^k).LIMIT(1-T/n)^n.LIMIT(1-T/n)^-k         with n-> INFINITY
                                            = (T^k/k!).(1+0+...).e^-T.(1-0)^-k = (T^k/k!).e^-T      //why (1-T/n)^n = e^-T? reduces to why (1+1/n)^n = e by putting a/x = 1/n; maybe taking logs or sth
                                        Probability to find k cars in the a time frame in which T cars pass.
                                        Eg- In an hour 36 cars pass, Probability to have 2 cars passing 15 minutes. T = 8 cars/15 mins.
                                            P(X = 2) = (9^2/2!).e^-9
                                Law of Large Numbers, The mean of an experiment tends to approach the E(X) as the trials or n approaches INFINITY.
                                    say, number of heads out of 100- say Expectation = 50. If we carry our the experiment, st we may get 55,64, 72, 18,.. and so on.
                                    Eventually, over INFINITE number of trials the mean will be same as expectation (Graphically, cumulative mean may diverge but will eventually converge to meet mean)
                                    Expectation- has already taken into account the trends (mean is practical side of experimentation and will eventually agree with theoretical)
                                    Not that Probability of any trial starts to favor the opposite- Probability is always the same- but odds converge by numbers (bell curve)
                        </Study>
                        Real Life- Insurance companies use probability.
                            500$ Premium per year and Policy on 1 Million $ if 7 dies in 20 years.
                                over 20 years, total premium = 10K/1M = 1/100; i.e less than 1 outta 100 people should die in 20 years- generally they won't (study death ratio) so profitable job.
                        Casino- 56C5 balls and 1 of the 46 golden balls = 56C5 * 46 = 175,711,536 and 1 is your chance at winning!
                        Basketball- Study the trends and tell me- if I should take 1 3-pointer shot or 3 Free Throw shots.
                            check their track record. P(hit in Free Throw), P(hit in 3 pointer) and calculate accordingly.
                </Probability>
            </DiscreteMaths>
            <LA>
                Khan Notes- 710/999 done!!
                <Matrix>
                Matrix is just table of numbers to represent data.
                    whole set of phenomena interestingly- CG,tons of things.
                    it is way of represent maths concept.
                    intuition behind these concepts later to not confuse.
                        Original Motivation came for huge many linear equation may become very hairy to solve mechanically w/o linear algebra.
                        the way we defined operations are useful for real life cases- like Graphics, etc.
                    n X m means n rows, m columns. Any element Aij means (i)th row, (j)th column.
                <Vector>
                Vector is 1-D matrix- Column vector or row. Convention, small case to represent them.
                    <BasicOperations>
                    Addition- (a+b)= every ith term is ai+bi.
                        Equation of line- (r-r0)= kv
                    Scalar Multiplication- ca = every ith term is c.ai.
                    </BasicOperations>
                    <DotProduct>
                    Dot Product (defined in Rn)
                        a.b = SIGMA(ai.bi) from 1 to n
                            Product of lengths of vectors in same direction
                            a.a denotes square of length of the vector
                                Length of a vector, |a| = sqrt(a.a)
                                    a1.a1+a2.a2+..an.an = pythogorus theorem induction over a new vector.
                                Unit Vector- (only direction) a/|a|.
                        Yields 1 scalar term as output
                        Properties
                            Commutative- a.b=b.a
                                Proof- a.b= SIGMA(ai.bi) over 1 to n; b.a= SIGMA(bi.ai) over 1 to n. 
                                    Since, ai.bi=bi.ai (multiplication is commutative), the result.
                            Distributive- (v+w)x=v.x+w.x 
                                (proof- expansion and distribution of multiplication over addition)
                                (cV).W = c(V.W)
                            Applications
                                Equation of a plane- (r-r0).n0 = 0
                        Vector Properties Using DOT PRODUCT
                            Cauchy Swatz Inequality- |x.y|<=|x|.|y| and |x.y|=|x|.|y| <=> x=cy for c BELONGS R.
                                p(t)=|ty-x|^2>=0, (ty-x).(ty-x)>=0. (refer to notes for more).
                            Triangle Inequality- |x+y|<=|x|+|y|
                                Length of vector after addition will be lesser than sum of their individual lengths.
                                Proof- |x+y|^2=(x+y).(x+y)=...=|x|^2+2x.y+|y|^2 <= |x|^2+2|x|.|y|+|y|^2 (Using Cauchy Swatz Inequality)
                                    = (|x|+|y|)^2
                            Angle between vectors, cos THETA = ((a.b)/(|a|.|b|))
                                Proof (using triangle property)
                                    |a-b|^2 = |b|^2+|a|^2-2|a|.|b|.cos(THETA); (a-b).(a-b) = ...
                                    if THETA=90, cos(THETA) = 0 = a.b 
                                    if THETA= 0, cos(THETA) = 1 = a.b/|a|.|b|, so a.b = |a|.|b| => a=kb (cauchy inequality)
                                    if THETA=180, cos(THETA)=-1, a=-kb for k BELONGS R.
                                Equation of a plane, let any point A(x,y,z), 1 point be A0(x0,y0,z0), normal perpendicular be n, then
                                    n.(A-A0)=0 (being perpendicular)
                                    So, n1(x-x0)+n2(y-y0)+n3(z-z0)=0 => Ax+By+Cz = D.
                                        normal vector- (A,B,C) and for particular point- there may be many points solving for n1x0+n2y0+n3z0=D
                                        Distance of plane from a point P = n.f/|n| = (Ax0+By0+Cz0-D)/(Sqrt(A^2+B^2+C^2))
                                            there are many points on plane
                                            Minimum distance- go for shortest distance- perpendicular to it- any other point- will form hypotenuse > height.
                                            we will use some point xp for reference.
                                            height = f.cos(THETA) where f is distance between xp and P.
                                            how to find cos(THETA)- DOT PRODUCT between normal vector and f.
                                            For a point of plane- substitute some var =0
                                        Eg- Find d if distance between 2 planes is sqrt(6)
                                            Ax-2y+z=d 
                                            plane containing lines (x-1)/2=(y-2)/3=(z-3)/4 and (x-2)/3=(y-3)/4=(z-4)/5
                                            find intersection of 2 lines and use the 3 points to make a plane
                                                we need to find k1 and k2 for finding the intersection of the 2, assuming (h,k,l) is solution
                                            OR take cross product of directions to find normal vector and using points- make a plane.
                                                being parallel to plane- we can use ratio and proportions.
                                            Next, take a point on plane and find its distance from another.
                        A.x can be thought of as dot product of matrix's row vectors' transpose and x vector.
                            Or A=[v1 v2 v3 v4] then dot product of A with x = (x1 x2 x3 x4)t.
                            A.x = x1.V1+x2.V2+x3.V3+x4.V4 (linear combination of column vectors)
                        v.w = vt*w (dot product of 2 vectors = matrix multiplication of 1st's transpose with 2nd)
                        Ax.y = (Ax)t X y = xt X At X y
                    </DotProduct>
                    <CrossProduct>
                        defined only in R3
                        Formula- 
                            a X b = [a2b3-a3b2 a3b1-a1b3 a1b2-a2b1]
                            a X (b X c) = (a.c)b - (a.b)c
                                computationally simpler
                        Magnitude- |a X b| = |a|.|b|.sin(THETA)
                            Proof- |a X b|^2 = (a2b3-a3b2)^2+(a3b1-a1b3)^2+(a1b2-a2b1)^2 (cuz |x|^2=x1^2+x2^2+..)
                                expanding we get it. |a.b|^2=abcos(THETA) substituted and using 1-cos(THETA)^2
                            Corollary- 
                                (a X b).a = 0 (dot product with a perpendicular)
                                a X a = 0
                        Direction- Right hand rule- move index finger from a to b, thumb gives direction of resulting vector.
                        Application
                            finding a perpendicular to a plane-description.
                    </CrossProduct>
                </Vector>
                <ScalarMultiplication>
                Scalar Multiplication- multiplies the num to all elements.
                    -1.B = Take negatives of all matrix elements.
                    Bij = k(b)ij
                </ScalarMultiplication>
                <Addition>
                    just human conventions how they add. 
                        corresponding elements are added.
                        Cij = Aij + Bij for all i,j defined over.
                            if the degree is same.
                    addition is commutative.
                    Eg- India has 2 cities for producing airparts. for each city, the matrix of the part and quality the number of produce is given
                        we want to know the production in India matrix by parts and quality.
                    A-B = A - (-1(B)) = scalar multiplication involved.
                </Addition>
                <Transpose>
                    Eg- Matrix of Quality by parts.
                    C = A + B then Ct = At + Bt
                    A.A^-1 = In and A^-1.A=In
                        Taking Transpose on both sides, (A.A^-1)t = (In)t
                        A^-1t.At = In => (A^-1)t is inverse of At OR (A^-1)t = At^-1
                    Att = A
                    Det(A) = Det(At)
                        Proof by induction- 
                            for n=2, ad-bc
                            Assume det(B) = det(Bt) for B being n X n, prove for n+1 X n+1
                                for n+1 X n+1 matrix, find determinant using 1st row for A and 1st col for At.
                                inside parts are assumed to be same- so they are same.
                    (AB)t=Bt.At
                        Cij = ith row of A X jth col in B
                        Dji = jth row of B X ith col of A
                    (A+B)t = At + Bt
                        C'ij = Cji = aji + bji = a'ij + b'ij
                    ((A)^-1)t = (At)^-1
                        A.A^-1 = A^-1.A = In
                        (A.A^-1)t=In and (A^-1.A)t = In
                        (A^-1)t.At = In and At.(A^-1)t = In
                        A = (A^-1)t and A = At^-1
                </Transpose>
                <Multiplication>
                Multiplication of Matrices
                    Vector Multiplication- row vector multiplies with column vector and results in a value.
                        x X y = kth term of x * kth term of y.
                    Cij = A X B = The term of multiplication is (i)th row vector of A * (j)th column vector of B
                        row vector and column vectors should match in their size so as to multiply their corresponding terms.
                        Hint: for every rightwards, every downward.
                    Eg- Every city has n types of apartments and every apartment has specied configuration of equipments (electrical,etc)
                        Matrix of city and apartments in numbers and Matrix of apartments and equipments in numbers (contains relation, numeric)
                        Find, equipments in a city is a matrix multiplication.
                    A.I=A is true only for square matrix. can't apply our usual commutative rules- different set, diff operations.
                        Identity Matrix- {Ik = (I)ii = 1 and 0, otherwise}
                    (A.B)t = Bt.At
                        Proof- 
                            Let's say C=A.B and D=Bt.At
                            Cij = ai1.b1j+ai2.b2j+..+ain.bnj
                            Dji = ai1.b1j+ai2.b2j+..+ain.bnj
                        Corollary- (XYZ)t=ZtYtXt
                            (X.(YZ))t = (YZ)t.Xt = Zt.Yt.Xt (just be conscious of your capabilities and harness them- where can they take you)
                </Multiplication>
                <Inverse>
                    The inverse of Matrix when multiples with the Matrix gives Identity Matrices.
                        Not every Matrix is invertible.
                        if A.A^-1 = A^-1.A =I means both are inverse of each other.
                        Inverse (of set theory)- works similar to reciprocal in multiplication.
                    Only thing less pleasant about inverse of 3X3 is 4X4 matrix.
                        it saves my brain from degrading.                    
                    How?
                    Approach 1: rituals standardized from the underlying real reasons.
                        For Matrix A.
                        Find Minor Matrix (M)- Minor for every element of the matrix- Mij = Determinant(Matrix obtained by removing ith row and jth column from A.)
                        Find Cofactor Matrix (C)- multiple every element Mij of matrix with (-1)^(i+j)
                        Adjoint Matrix (Adj)- Take Transpose of Cofactor Matrix, (AdjA)ij = Cji.
                        Inverse Matrix, A^-1 = Adj(A)/Determinant(Matrix A) = Scalar Muliplication of Adj(A) with (1/Determinant(A))

                        A^-1 is undefined if determinant of A = 0. Defines Rank!
                    Approach 2:
                        Augmented Matrix- Append Matrix A with Identity Matrix (of same dimensions) to its right.
                        Apply row operations (switching, add/subtract rows), to this bigger matrix.
                            until Original Matrix A becomes Identity
                        The appended part of matrix will be A^(-1).
                            A^-1 undefined if we can't make Identity matrix from A thru row operations.
                            Defines Rank!! (number of linearly independent rows)
                        Why It works?
                            Every Row operation translates to multiplying the matrix with a ?IdentityVariant matrix, we multiple identity along with it!
                            we keep multiplying A with these until left matrix becomes identity- meaning A^-1.A has made it I. 
                            So, A^-1 = multiplication of all those ?IdentityVariantMatrices- which is captured by their multiplication with right side identity matrix.
                </Inverse>
                </Matrix>
                <LinearEquations>
                    Isomorphism in maths
                        reduce 1 problem into a type of another- whose standard solutions are available.
                    <Equation>
                    Equation, E(x,y): px+qy=r 
                        a set with element (or free variables) (x,y) s.t 
                        this assertion is true we gotta find them
                        IOW, Equation denotes a set of values (x,y) BELONGS R2, which satisfy the equation- which are many.
                        Improper (x,y) don't satisfy the equation means the equation doesn't hold true for that point.
                        Eg- x+4y+z=8- to find out where this plane intersects our axes, substitute, 2 variables values = 0 and find the other.
                    </Equation>
                    <SolutionForEquations>
                        the x and y variables (value or a set of values) that satisfy both equations at the same time
                            as such taking equations separately, means any x of eq1 is not same as that of eq2.
                            But since the set of points (x,y) satisfy both equations at the same time, both x and y mean the same thing.
                            Think intersection on the n-D coordinate plane.
                        Eg- 3x+2y=7;-6x+6y=6
                        Solving 2 equations means finding set of (x,y) which hold for eq1 and eq2 (intersection of those set of points)
                        <Ways>
                            <GraphPlotting>
                            Graph Method- plot these lines and check where they intersect.
                                every curve gives a set of point (x,y) BELONGS R2 (complete Graph Paper) which hold for that equation.
                                Plot all curves and check their intersections (these are intersection of sets of points- of our interest)
                            </GraphPlotting>
                            <SubstitutionMethod>
                            Substitution Method- y=6-x carries the essence of the equation 
                                let (x1,y1) be a solution, where x1 is a value from domain of x.
                                y1 must take value 6-x1 to make the eqn true
                                being the solution, these values should also hold for eqn1, so putting them spits out the answer.
                            </SubstitutionMethod>
                            <AdditionMethod>
                            Addition Method- scaling equations aptly and then adding/subtracting to get a value.
                                If eq1 and eq2 both hold for those 'solution set' points, then adding the equations (all linear combinations) also hold for those set of points.
                            </AdditionMethod>
                            <LinearAlgebraMethods>
                                <InverseMatrixMethod>
                                    Can be written as Ax=b where (A)2,2=[3,2,-6,-6]; x = [x y]t (column vector); b= [7 6]t (column vector)
                                    Solving it can be as simple as multiplying both sides by A^-1 from left, x = A^-1.b
                                        If A^-1 undefined, there is no solution to these equations.
                                            means Determinant(A) = 0; for 2-D, means ad-bc = 0, so a/c=b/d. meaning these lines are parallel.
                                            Think about it, this will happen when the lines do not intersect on n-D plane.                                    
                                </InverseMatrixMethod>
                                <RowOperationMethod>
                                    Row Reduced echelon form- 
                                        Same concept as inverse matrix method, augment matrix A to b.
                                        Apply row operations until A becomes Identity. Augmented matrix would hold values of (x,y,..).
                                        Proof is same as addition- the linear combinations of linear equations also hold true.
                                    OR reduce it to row Echelon Form, and then multiply as A'.x=b'.
                                        Pivot variables- columns for which a row has first 1 appearing.
                                        Free Variables- Become the terms in which the pivot variables will be expressed.
                                            Bcz they will (can) repeat in equations but pivot will definitely not.
                                        Express, the query vector in terms of free variables 
                                            set of solution (infinite maybe)this forms a subspace- the vectors are basis
                                            No Solution, if during the attempt, we get contradictory equation like 0 = -4.
                                            If Rank=n (all LI eqn), unique solution,  if rank is any lesser, can be infinite or no solution
                                    <HomogenousEquation>
                                    Solve Homogenous Equation- for Ax=b, solve Ax=0, and add to.
                                        Figuring if linear combination can give b has a bearing on if they can give 0.
                                        Null Space (Vector)- finds values for linear combinations s.t the linear dependence is exposed. 
                                            Solutions of x for Ax=0 = {x BELONGS Rn | Ax = 0}
                                                x1v1+x2v2+...+xnvn = 0 Vector
                                            Claim- all set of values will also add to the solution set of equations
                                                Proof- AX = b and AX0 = 0 => AX+k.AX0 = b + k.0 = b => A(X+k.X0)=b; Thus (X+k.X0) will also be solutions.
                                            It is a subspace? (Refer vectors)
                                                if v1 in set, A.v1=0, then for cv1, A.cv1=c(A.v1)=c.0=0 vector.
                                                If for v1 and v2, Av1 = 0 and Av2 = 0 then A.(v1+v2)=A.v1+A.v2 = 0+0=0 VECTOR; So, v1+v2 is in set.
                                            Finding N(A)
                                                Ax = 0 => rref(A).x=0 (row operations on Augmented matrix A and 0)
                                                    rref- row reduced echelon form.
                                                    So, N(A) = N(rref(A))
                                                    rref also reveals that cols corresponding to pivot variable rows represent corresponding Linearly Independent vectors.
                                                        cuz free variables are used to express pivot elements.(WRONG?)
                                                        cuz they are the ones with leading 1- which taken together can generate all other column vectors (without exception), isn't it?
                                                        dim(C(A))=rank(A).
                                                            cuz number of pivot cols (indepd cols) in the column matrix (vectors) = number of independent rows (with leading 0s)
                                                Non-pivot col exists in rref(A) => N(A) != 0, then linearly dependent, no unique solution (Infinite Solutions if b in C(A))
                                                    Standardize it as m=n < dimension of A, then infinite solutions.
                                            x1v1+x2v2+...+xnvn = 0 Vector 
                                                linearly independent => xi=0 is only solution, then N(A)={0 vector} => unique solution
                                                i.e  N(A)={0} so N(rref(A))=0 then rref(A).x=0 => if rank = n, x=0 vector. And unique solution exists.
                                            dimension(N(A)) (refer subspaces) = Nullity(A)- No of non-pivot columns of rref(A).
                                    </HomogenousEquation>
                                    <Solvable>
                                        Column Space- all candidates for value b.
                                            If A = [v1 v2...vn] then C(A) = Span(v1,v2,..vn)
                                            Find C(A) = span of basis (LI vectors)
                                                Find it out from linear equations.
                                                    find rref(A)- pivot columns can produce any element b BELONGS Rm (they are the basis)
                                                        assume b = [b1; b2; ...bm]- we can figure out vector x (coefficients for column - for which b can be obtained)
                                                        and all non-pivot columns can be expressed in terms of pivot columns (they are linearly dependent)
                                                If we want to find out plane of span as an equation? 
                                                    we know 2 points on it- subspace has (0,0) so 
                                                    find its perpendicular using cross product of 2 vectors (forming subspace)
                                                    use 1 vectors and n.(x-v1)=0.
                                                    Check if b exists in C(A).
                                                For Ax=b if b !BELONGS C(A) then no solution, else at least 1 solution.
                                                    Standardize the Solution
                                                        if m < n, dimension of A vs augmented A, then no solution exists
                                            Is it a subspace?
                                                a BELONGS C(A) so a = c1v1+c2v2+....
                                                then ka = k(c1v1+c2v2+..) = kc1v1+ kc2v2+...= linear combination of v1,v2,..= BELONGS C(A).
                                                b BELONGS C(A) (say)
                                                    b=b1v1+b2v2+....
                                                    a+b= (c1+b1)v1+(c2+b2)v2+...=linear combination of v1,v2,..=belongs to C(A).
                                            dim(C(A))=rank(A)
                                                cuz they are the ones with leading 1- which taken together can generate all other column vectors (without exception), isn't it?
                                    </Solvable>
                                        Convert [A|b] to [rref(A)|b'], the solution of x will be-
                                            x = b' + N(A)
                                            Solve [rref|0] for N(A).
                                            A(xp+xn) = Axp + Axh = b + 0 = b.
                                            Also, A(x) = A(xp+xh) = A(x-xp) = A.xh = 0 so (x-xp) BELONGS N(A).
                                </RowOperationMethod>
                            </LinearAlgebraMethods>
                        </Ways>
                    </SolutionForEquations>
                </LinearEquations>
                <Vectors>
                    These equations can also be written as ax+by=c where a,b,c are column vectors.
                    a=[3 -6]t; b=[2 6]t and c=[7 6]t;
                    Think of these column vectors as vectors on 2-dimensional plane where adding scaled vector a with scaled vector b, makes vector c.
                        Standard Position- Let's make origin as center of reference for ease- as such vector is independent of starting point 
                            cuz it's not a point but a direction (with a magnitude).
                            to change tail from (0,0) to (i,j), change head from (a,b) to (a+i,b+j)
                        Our job is to find what to scale these vectors to.
                            A unique Linear combination of our vectors gives solution
                    Scalar Multiplication- with some Z+, changes it magnitude, same direction (plot on graph)
                        with some Z-, Reverse the direction(*-1), magnitude scaled accordingly(*k)
                    Eg- given vector a and b, find 4a-3b.
                    Colinear Vectors- S = {cV|c BELONGS R} where V is a vector. Gives many set of points as head (origin as tail).
                    Q- What's x + kV, where x and V are vectors.
                        for line parallel to b separated by a vector (from origin)- a + k(b-a) or b+k(b-a) (scaling of (b-a) (gives the line), added to vector a to give all heads from origin for the vectors.)
                        Finding every element in generic terms- x=0-2k, y=2+2k.
                    <LinearCombination>
                        of vectors v1,v2,..vn in R^n (n-tuple of Real numbers) is c1v1+c2v2+...cnvn; where ci BELONGS R.
                        Eg- a=[1 2]t b=[0 3]t; it's linear combinations cover R2.
                        Span(a,b) = R2 (all vectors emanated (reachable) from linear combinations of a and b).
                            Remember in physics we used i cap, j cap; those were unit vectors and their linear combination spanned 2-dimensional space.
                            Easy to work with, Force in direction of 4 in x and 3 in y-axis = 4i+3j.
                        Eg- a=[1 2]t,b=[2 4]t; Span(a,b) = k*[1 2]t
                        Does it produce Rn? find c1 and c2 s.t c1.a+c2.b= X (where X is [x1 x2]t (any point in R2 space))
                            ci (unique) in terms of x1 and x2 if it is Rn.
                        <LinearDependence>
                        Linear Dependence- A set of vectors are LD, iff c1v1+c2v2+..+cnvn=0 
                            Here 0 means zero vector [0 0 ..]t
                            for some ci (not all should be 0, then there's no point).
                            In other words if any vector can be expressed as linear combination of a few others.
                            Given 2 vectors, find all ci to make eqn = 0 vector, if any ci != 0, then LD.
                                In other words if non-zero solution exists for ci, then LD.
                        </LinearDependence>
                        <Subspace>
                        Subspace (V)- Subset of Rn (includes 0 vector), a set of vectors.
                            Closure under scalar multiplication
                                x in V => c.x in V.
                            Closure under addition, 
                                a,b in V => a+b in V.
                            Summary, vector produced by any linear combination of some of vectors, gives a vector within the subspace.
                                obviously, it is infinite set.
                            <Basis>
                            Basis- A set of Linearly independent vectors, whose linear combinations make a subspace.
                                Span(Basis) = V.
                                There can be many basis for a subspace (eg- R2 can have {[1 0],[0 1]} or {[1 0],[1 2]}- check basis of R2- LI and R2 (see b4))
                                <UniqueCombinationOfABasis>
                                There is a unique combination for a basis to produce a vector, 
                                    proof by contradiction- SIGMA(ci.vi) gives a, also does SIGMA(divi) over 1 to n.
                                        subtracting the 2 eqn, we get- SIGMA((ci-di)vi) = 0 so, all ci = di.
                                        because being basis, vi's are all Linearly independent and no Linear combination can make their outcome zero except all constants=0.                                        
                                </UniqueCombinationOfABasis>
                                <Dimension>
                                Basis has unique number of elements in it (can't be lesser or more)
                                    Proof by contradiction
                                        Let a1,a2,..an be basis of V.
                                        Assume b1,b2,...,bm (m< n) spans V.
                                            Let's add a1 to the set, a1 BELONGS V.
                                            Then, d1b1+d2b2+...+dmbm = a1 => b1 = (-1/d1)(-a1+d2b2+...+dmbm)
                                            We can replace b1 by a1 cuz b1 can be expressed in terms of a1,b2,..bm (any vector expressible in b1..bn, will remain expressible)
                                        So, now a1,b2,b3,...bm spans V.
                                            Let's add a2 to the set, a2 BELONGS V.
                                            Then, d1a1+d2b2+...+dmbm=a2 => b2 = (-1/d2)(-a2+d1a1+d3b3+...+dmbm)
                                            We can replace b2 by a2 cuz b2 is expressible in terms of a1,a2,b3,..bm (any vector, just replace linear combination by this expression)
                                        We can go on replacing all bi by ai, until we have a1,a2,...am (m< n) spans V 
                                            but we have a1,a2,..an (n>m),this means these are linearly dependent 
                                            but basis of subspace can't be
                                        Contradiction.
                                        For a subspace, we can't have a basis with fewer elements.
                                            This proves for more elements implicitly. 
                                            If one basis happens to have more elements than the other, the other will have fewer elements.
                                            This is not possible (contradiction)
                                    Dimension- No of elements of any basis of a subspace,V.
                                </Dimension>
                                e1,e2,e3 columns of identity matrix, In are used as standard basis for Rn.
                                    In.x = x; e1.x = x1, e2.x = x2, ..; a = [a1 a2 ..an]t = a1e1+a2e2+..+anen=a1[100..]t + a2[0100..]t+..+an[00..1]
                            </Basis>
                        </Subspace>
                    </LinearCombination>
                    <LinearTransformation>
                        <Brief>
                            Function- Recall defined over Domain-Codomain (over R->R so far), domain maps to range (subset of codomain) as specified.
                            Here maps R2->R2,Rn->Rm in general.
                            written as g(x1,x2)=2 for g:R2->R (domain:R2,codomain:R,Range-2)
                            Eg- h(x1,x2)=(x1+x2,x2-x1,x2.x1); for h(2,3) -> (5,1,6) BELONGS Range but (5,1,0) !BELONGS Range.
                            Eg- f(x1,x2,x3)=(x1+2x2,3x3) for f:R3->R2- written as f([1 1 1]t) = [3 3]t
                            Transformations- a function on Rn plane can be transformed to its corresponding Rm map.
                                Highly utilized in graphics processors.
                                Taking projections from n-D to k-D in Engineering drawing or computers.
                        </Brief>
                        <Defn>
                            Linear Transformation- by definition, a function T s.t it follows following properties (linear combinations of vectors)
                                For a,b BELONGS Rn then
                                T(a+b) = T(a)+T(b)
                                T(ca) = cT(a)
                                Eg- T([x1 x2]) = [x1+x2 3x1]
                                    T(a+b) = T([a1+b1 a2+b2]) = [a1+b1+a2+b2 3(a1+b1)] = T(a)+T(b)
                                    T(ka) = T([ka1 ka2]) = [ka1+ka2 3ka1] = k[a1+a2 3a1]
                                !Eg- T(a) = T([a1 a2]) = [a1^2 0]
                                    T(ca) = [(ca1)^2 0] = [c^2.a1^2 0] = c^2.[a1^2 0] = c^2.T(a)
                        </Defn>
                        <LTThruMatrix>
                            <MatrixRepresentsLT>
                                T:Rn -> Rm, being linear, can be expressed as a matrix A (m X n)-
                                T(x) = A.x (take a few examples to feel convinced)
                                    think of it as a1x1+a2x2+..anxn OR as DOT PRODUCT 
                                    cuz multiplication not yet defined for vectors in coordinate system
                                Eg- T(x1,x2)=(2x1-x2,3x1+4x2), we can take A = [2 -1:3 4]
                                Is it a valid linear transformation?
                                    T(cx) = A.cx = [v1 v2 .. vn].cx = v1cx1+v2cx2+...+vn.c.xn = c(v1x1+...+vnxn) = c.Ax = c.T(x)
                                    T(a+b) = A.a+A.b = [v1 v2..vn].[a1+b1 a2+b2 ..an+bn] = (a1+b1)v1+(a2+b2)v2+..(an+bn)vn = (a1v1+a2v2+..anvn)+(b1v1+..bnvn) = A.a+A.b = T(a)+T(b)
                            </MatrixRepresentsLT>
                            <PracticalTransformationWays>
                                <UsingFunction>
                                    Eg- T([x1 x2]) = [x1+3x2 5x2-x1 4x1+x2], T([0 1])=[1 -1 4]t, T([1 0])=[3 5 1]t
                                        T([x1 x2]) = [1 3; -1 5; 4 1].[x1 x2]
                                    Eg- Transforming a triangle s.t 
                                        1. Reflects around y,
                                            every x gets opposite sign, T([x y])=[-x y]
                                        2. Stretch in y-direction, twice of original
                                            every y gets doubled, T([x y]) = T[x 2y]
                                        Since it is 1 followed by the other (composition of Transformation Functions(later)),
                                            T([x y])=[-x 2y]=[-1 0; 0 2].[x y]t
                                    <TransformATriangle>
                                        Transforming a Triangle (x0,x1,x2 vectors as vertices)
                                        A set of all vectors for a line from is given by,
                                            L0 = {x0+t(x1-x0) | 0<=t<=1}
                                            L1 = {x1+t(x2-x1) | 0<=t<=1}
                                            L2 = {x2+t(x0-x2) | 0<=t<=1}
                                        Its transformation is as follows:-
                                            T(L0) = {T(x0+t(x1-x0)) | 0<=t<=1}
                                            = {T(x0) + T(t(x1-x0)) | 0<=t<=1}
                                            = {T(x0) + t.T(x1)-t.T(x0) | 0<=t<=1}
                                    </TransformATriangle>
                                </UsingFunction>
                                <UsingUnitVectorTransformation>
                                    T(x) = T(x1e1+x2.e2+..xn.en) = T(x1e1)+T(x2.e1)+..T(xn.en) = x1.T(e1)+x2.T(e2)+..+xn.T(en)
                                        = [T(e1) T(e2) .. T(en)].[x1 x2 .. xn]t
                                        What does this mean? It means to take transformation of any vector, take transformation of individual ei and multiply the matrix obtained with vector x to get transformation.

                                    Eg- Alternate way of solving transformation of triange (that refelcts around y and stretches double in y), [0 1],[1 0]- tell what happens to the unit vectors.
                                        T[1 0] = [-1 0] and T[0 1] = [0 2]; A = [T([1 0]) T([0 1])] = [-1 0; 0 2] (diagonal matrix)
                                    <RotationLT>
                                    Eg- Clockwise Rotation of axes by angle THETA.
                                        Is it Linear Transformation?
                                            Rot(x+y)=Rot(x)+Rot(y)
                                            Rot(cx) = c.Rot(x)
                                            Proof (to Relate)- make x,y on graphs and rotate them.
                                        Being LT, following holds
                                            Rot(x) = A.x = [T(e1) T(e2) .. T(en)]
                                            If A is 2 X 2, A = [Rot([1 0]t) Rot([0 1]t)]
                                                Rot(e1) by THETA, it is unit length THETA from x-axis,
                                                it's projection on x-axis is cos(THETA) and that on y-axis is sin(THETA)
                                                    Rot(e1) = [cos(THETA) sin(THETA)]t.
                                                Rot(e2) by THETA, it is unit length driven to 2nd quadrant.
                                                    it's projection on x-axis, -sin(THETA) and that on y-axis, cos(THETA)
                                                    Rot(e2) = [cos(THETA) -sin(THETA); sin(THETA) cos(THETA)]
                                            If A is 3 X 3,
                                                Rot(e1) about x-axis by THETA clockwise (or all vectors anticlockwise), [1 0 0]t, eth remains intact (their projections)
                                                Rot(e2), [0 cos(THETA) sin(THETA)]t
                                                Rot(e3), [0 -sin(THETA) cos(THETA)]t
                                    </RotationLT>
                                    <VectorProjectionLT>
                                    Eg- Projection of a Vector on a Line L ("Shadow" from orthogonal light source)
                                        Line L be given by span(v), scaling of vector v = {cv|c BELONGS R}
                                        x be a vector
                                        We know that projection is orthogonal, (x-proj(x)).(proj(x)) = 0.
                                        let x project on L s.t it is cv,
                                            (x-cv).v=0 => x.v = c(v.v) => c = x.v/v.v
                                            Once we have c, we can substitute in L, Proj(x) = c.v
                                            so Proj(x)on v = ((x.v)/(v.v))v = (x.vCAP).vCAP = (x.u)u (where u is unit vector of line of projection)
                                        Is it Linear Transformation?
                                            Proj(a+b) = ((a+b).u).u = (a.u + b.u).u= (a.u)u+(b.u)u = Proj(a)+Proj(b)
                                            Proj(ca) = (ca.u)u= c(a.u)u = c.Proj(a)
                                            Yes, it is.
                                            Thus, for any vector x's projection on L with unit vector u=[u1 u2]
                                                A = [T(e1) T(e2)] 
                                                T(e1) = T([1 0]) = ([1 0]t.[u1 u2]t)(u1 u2) (formula) = [u1^2 u1u2]
                                                T(e2) = T([0 1]) = ([0 1]t.[u1 u2]t)(u1 u2) (formula) = [u1u2 u2^2]
                                                So, A = [u1^2 u1u2; u1u2 u2^2]
                                    </VectorProjectionLT>
                                </UsingUnitVectorTransformation>
                            </PracticalTransformationWays>
                        </LTThruMatrix>
                        <LinearTransformationSubspace>
                        Does Linear Transformation of all vectors over a subspace produce a subspace?
                            Is image of V under T, T(V) a subspace?
                                Image of Rn = T(Rn) = image of Rn under T ={T(x)|x BELONGS Rn}
                                    a subset of codomain (range); written as im(T)- image of T.
                                    If T(x)=A.x, im(T) = {Ax|x BELONGS Rn} = C(A)= Column space of A (span).
                                say a and b belongs to V, then T(a),T(b) BELONGS T(V), T(a)+T(b) = T(a+b); since a,b BELONGS V, a+b BELONGS V, so, T(a+b) BELONGS T(V). Thus, if if x,y BELONGS T(V), so do x+y
                                if a BELONGS V, T(a) BELONGS T(V). Now, c.T(a) = T(ca) ; since a BELONGS V, ca BELONGS V; then T(ca) BELONGS T(V), thus, if x BELONGS T(V), so does c.x
                        </LinearTransformationSubspace>
                        <PreImageOfSubspace>
                        Pre image of a subspace S under T (= T^-1(S))
                            like inverse function.
                            {x BELONGS X | T(x) BELONGS S}
                            T(T^-1(S)) SUBSEToF S.
                            Eg- T(x)=[1 3; 2 6] [x1 x2]t; Find preimage of [0 0]t, [1 2]t.
                                We have A, find x s.t Ax = [0 0]t and Ax = [1 2]t. Simple Linear equation Problem.
                                x1 = -2x2 (x2 being free variable) and for other, x1 = 1-3k (replacing x2 free variable by t BELONGS R).
                                [x1 x2]t = [1 0]t + k[-3 0]t, plot it and all these map to [1 2]t on T.
                            Kernel of T- Preimage of [0 0]t for a T.
                                ker(T) = {x BELONGS Rn | T(x) = 0 VECTOR} = N(A).
                        </PreImageOfSubspace>
                        <PropertiesLinearTransformation>
                            <Addition>
                            (S+T)(x) = S(x)+T(x); where S+T: Rn -> Rm.
                                S(x)=A.x; T(x)=B.x (where A and B are m X n)
                                (S+T)(x)=S(x)+T(x)=A.x+B.x= [a1 a2 .. an].[x1 x2 .. xn] + [b1 b2 .. bn].[x1 x2 .. xn]
                                = a1.x1+a2.x2+a3.x3+..+an.xn + b1x1+..+bn.xn (where ai and bi are column vectors of A and B resp)
                                = (a1+b1)x1+(a2+b2)x2+...+(an+bn)xn = [a1+b1 a2+b2 .. an+bn].[x1 x2 .. xn]t = (A+B).x
                                Gives us definition of Matrix Addition
                            </Addition>
                            <ScalarMultiplication>
                            (cS)(x) = c(S(x)); where cS: Rn -> Rm.
                                (cS)(x) = c.S(x) = c.(A.x) = c.[a1 a2 .. an].[x1 x2 .. xn]t
                                =c(a1x1+a2x2+..+anxn) = c.a1.x1+c.a2.x2+..+c.an.xn = [ca1 ca2 .. can].[x1 x2 .. xn]t
                                =(cA).x
                                Gives us defination of scalar multiplication.
                            </ScalarMultiplication>
                            <CompositionMultiplication>
                            Composition- Apply a LT1 and then LT2 on the obtained result.
                                ToS: X->Z (S:X->Y and T:Y->Z)
                                    Is it a LT?
                                        ToS(x+y) = T(S(x+y))=T(S(x)+S(x))=T(S(x))+T(S(x))=ToS(x)+ToS(y)
                                        ToS(cx) = T(S(cx))=T(cS(x))=cT(S(x))=cToS(x)
                                        Yes it is.
                                    Matrix Multiplication Foundation
                                        Being LT, it can be expressed as a matrix C.
                                        ToS(x) = Cx.
                                        Also, ToS(x)=T(S(x))=T(Ax)=B.A.x
                                        How does S transform x using transformation matrix A of dim (m X n)= [S(e1) S(e2) .. S(en)]x = [A.e1 A.e2 A.e3 .. A.en]x = [a1 a2 .. an]x - m X n to tranform vector of Rn to Rm.
                                        How does T transform S(x), T(x) = T(a1x1+a2x2+..anxn) (where ai is m dimensional) = T(a1x1)+T(a2x2)+..+T(anxn) = x1.T(a1)+x2.T(a2)+..+xn.T(an) = [T(a1) T(a2) .. T(an)].[x1 x2 .. xn]
                                            T for any vector can be achieved thru matrix B, thus, T(S(x)) = [B.a1 B.a2 .. B.an].[x1 x2 .. xn] =Cx 
                                        Extra, [T(e1) T(e2) .. T(em)]S(x) = [B.e1 B.e2 B.e3 .. B.em].S(x) = [b1 b2 .. bm][a1x1+a2x2+..+anxn] = b1.(first term of stuff)+b2.(second term)+..+bm.(mth term)
                                        Thus, we can define C as a matrix obtained as [B.a1 .. B.an]
                                            Use dot product to find matrix multiplication
                                            Must have feasible composition, S:R3->R2,T:R4->R3, here, SoT is possible but ToS is not (AB =BA not true, not commutative)
                                            Associative property, HoGoF(x) = Ho(GoF)x= A(BC)x OR (HoG)oF x= (AB)Cx; (AB)C=A(BC)
                                            Distributive property, A(B+C)=A[b1+c1 b2+c2 .. bn+cn] = [A.(b1+c1) A.(b2+c2) .. A.(bn+cn)] = [Ab1+Ac1 Ab2+Ac2 .. Abn+Acn]= [Ab1 Ab2 .. Abn]+[Ac1 Ac2 .. Acn] = AB+AC
                                                from right also, (B+C).A=B.A+C.A
                            </CompositionMultiplication>
                            Inverse Transform
                                Covered Later.
                        </PropertiesLinearTransformation>
                        <InvertibleFunction>
                            Identity Function
                                Ix:X->X s.t Ix(a) = a for a BELONGS X.
                            f: X->Y, f is invertible iff there exists a function f^-1:Y->X s.t f^-1of = Ix and fof^-1 = Iy
                            let f^-1 be denoted by g, gof(a) = Ix(a) = a.
                            <InverseFunctionIsUnique>
                            Inverse of a function is Unique
                                Proof by contradiction, 
                                    gof = Ix and fog = Iy
                                let's say there's h:Y->x also inverse of f.
                                    hof = Ix and foh = Iy
                                g = g(y) = Ix o g(y) = (hof) o g(y) = ho(fog)(y)=h o Iy (y) = h(y) = h
                            </InverseFunctionIsUnique>
                            <PreImageIsUnique>
                            For every y BELONGS Y, is there a unique solution x BELONGS X, s.t f(x) = y.
                                Given a y BELONGS Y, proof by contradiction
                                    maybe y has no inverse (then fn is not invertible), 
                                    maybe y has more than 1 solution, g(y) has 2 solutions, say x1 and x2, then
                                        f(x1)=f(x2)=y; 
                                        apply g on all, gof(x1) = gof(x2) = g(y).
                                        g being inverse function of f, means x1 = x2 = g(y)
                                So unique solution.
                                Corollary- If f(x) = f(a) then x=a; 
                            </PreImageIsUnique>
                            <OntoTransformation>
                            Onto/ Surjective- image(f on X) = Y and Range(f on X)=Y
                                for every y BELONGS Y there exists at least one x BELONGS X, s.t f(x)=y.
                                For LT, T:Rn->Rm to be Onto, T(x)=A.x = a1x1+a2x2+..+anxn = C(A) = Rm.
                                    Find rref(A) for A augmented with b, to obtain [R|c]
                                        T is onto iff dim(C(A)) = No of basis vectors for C(A)= Rank(A) = Rank(rref(A)) = m
                                        No Solution, Rank (A) < Rank (Augmented Matrix), don't have a solution for some cases of b (not spanning Rm)
                                        Infinite Solution, Rank(A) = Rank (Augmented Matrix) < n (unknown var)
                                        Unique Solution, Rank(A) = Rank (Augmented Matrix) = n
                                        Eg-S:R2->R3; Is S(x)= [1 2; 3 4; 5 6]x Onto? we see that 3rd row is expressible in terms of prev 2- rank (A)=2 < 3, so not onto.
                                    If not Onto, what are solvable set of vectors b which map from Rn- 
                                        reduce Augmented matrix (A|b) to rref- make sure it doesn't have "no solution".
                                        You will have a set of bi's relp.
                                        Eg- T(x)=[1 -3; -1 3]x, here b1 = -b2.
                                        x1-3x2 = b1 (only equation); x2 is free variable and x1 is pivot, so [x1 x2]t = [b1 0]t + x2[3 1]t
                                            Here [b1 0]t is a particular solution and x2.[3 1]t is nullspace solution.
                            </OntoTransformation>
                            <OneToOneTransformation>
                            One-to-One/ Injective- for every y BELONGS Y, there is at most 1 x BELONGS X s.t f(x)=y
                                for any y BELONGS Y, at most 1 solution or x exists, if N(A) != 0, then x gets many solutions (contradicts)
                                So, N(A) has to just have the zero vector.
                                Also, Ax = 0 has x=0 as only solution, means [a1 a2 ..an].[x1 x2 .. xn]t = 0 has all xi = 0
                                Or, a1x1+a2x2+..+anxn=0 is possible only when xi = 0 for all i.
                                This means that all ai are Linearly independent vectors- then all ai form the basis of C(A) and dim(C(A))=Rank(A)=n
                            </OneToOneTransformation>
                            <InvertibleMatrixIsSquareMatrix>
                            f:X->Y is invertible iff there exists a UNIQUE x BELONGS X s.t f(x)=y (unique means injective and surjective)
                                Consider A as m X n,
                                Rank(A) = m iff Onto. (refer to previous sections)
                                Rank(A) = n iff one-to-one. (refer to previous sections)
                                Since, Invertible means both onto and one- Rank(A) = m = n.
                                    Possible when rref(A) makes a n X n matrix where every column is LI pivot column.
                            </InvertibleMatrixIsSquareMatrix>
                            <InverseTransformation>
                                for a Transformation function, there may exist some transformation T^-1, which makes ToT^-1 = IRn and T^-1 o T = IRn
                                <InverseTransformIsLinearTransform>
                                    ToT^-1(a+b) = a+b = ToT^-1(a)+ToT^-1(b)
                                        So, T(T^-1)(a+b) = T(T^-1(a)+T^-1(b))
                                        Apply T^-1 on botht the directions, we get T^-1(a+b) = T^-1(a)+T^-1(b)
                                    ToT^-1(ca)=ca= c.ToT^-1(a)=T(cT^-1(a)) (cuz T is LT)
                                        apply T^-1 on both sides, we get T^-1(ca)=c.T^-1(a)
                                </InverseTransformIsLinearTransform>
                                Corollary- So there exists a matrix (call it A^-1) which gives this transform of vector, T^-1(x)=A^-1.x
                                Property- ToT^-1=IRn => A.A^-1x = In.x, so A.A^-1 = In
                                <FindingInverse>
                                    Finding Inverse of a Matrix (A^-1)
                                    <AugmentedMatrixMethod>
                                    Any row operation on A is nothing but a Linear Transformation of column vectors of A,
                                        Say, T([x1 x2 x3]) = [x1 x2+x1 x3-x1], find Matrix S s.t T(x) = Sx.
                                        Thus, after Row operation, A becomes [S.a1 S.a2 S.a3 ..] OR = S.A (matrix multiplication)
                                        Carry on with these row operations until make A into I.
                                        In other words, S3.S2.S1.A = I but A^-1.A = I (we saw, being invertible transformation T^-1 after T)
                                        This means A^-1 = S3.S2.S1, the essence of these can be capture by parallelly multiplying these matrices with In.
                                        OR carrying out the same row operations on Identity matrix as on matrix A.
                                    </AugmentedMatrixMethod>
                                    <StandardizingInverseMatrix>
                                        for 2 X 2, we find it comes out as (1/(ad-bc))*[d -b; -c a]
                                        <Determinant>
                                        Let's coin, Determinant(A) = |A| = ad-bc (for 2 X 2)
                                            If Det(A)=0, not invertible.
                                            for 3 X 3 = a11(det(A11))-a12(det(A12))+a13(det(A13)) where Aij is matrix obtained by ignoring ith row and jth column.
                                            Pick a row or column for traversal and apply formula as SIGMA((-1)^(i+j)*aij*Aij)
                                            Rules of Sarrus- Shortcut method, augment matrix with itself
                                                SIGMA(product of diagonals starting from a11 to a1n) - SIGMA(product of diagonals starting from an1 to ann)
                                            k*Det(A) = Det(multiply k with any row or column of the matrix)
                                                REL with 2 X 2 matrix. if with all row and cols, it becomes k^2.
                                                Proof- Expand using determinant formula along that row/col which is multiplied by k, see the formula, gets k on every terms (gotta take it common)
                                                Thus, we can take a factor along row/col as common.
                                            If only 1 row/col of X and Y differs at corresponding elements and Z = X + Y
                                                then Det(Z) = Det(X)+Det(Y)
                                                Proof- Expand the Det(Z) along the differing row/column and segregate (distribute) different elements from every term
                                                Corollary- break Det(A) into workable parts.
                                            Switching 2 rows and cols, changes sign of det(A).
                                            If 2 rows/cols are ditto same for a matrix A, Det(A)=0
                                                Proof- change the rows, it remains same, meaning Det(A) = -Det(A) => Det(A) = 0.
                                                    OR Duplicate rows => never get rref to be In => not invertible => Det(A) = 0.
                                            Any row/col operation on matrix doesn't change its determinant.
                                                Proof- Consider a transformation of A to another matrix with entries different in row/col (replaced by other row/col)
                                                    Obviosly, Det(Transformed(A))=0
                                                    Multiply Transformed matrix by a constant c on the differing row/column. It still remains 0 (no impact)
                                                    Add this matrix to Det(A), we get the desired operation and its value is still = Det(A).
                                            Any upper/lower Triangular Matrix has Det = product of diagonal entries.
                                                Proof- Expand using formula along 1st column/row, then 1st column/row of next minor and so forth.
                                            Det(A) = Det(At)
                                                It's repetative expansion of the two along col for one and row for other.
                                            Strategy- Remove additional parts, Remove common multiplication; Look for repeating rows; perform row/col operations to make entries along a row/col as 0 (intelligent choice), expand along that row.
                                            Area of Parallelogram = Det(A) where A has column vectors making sides of parallelogram.
                                                A = B.H so A^2 = B^2.H^2 = v1^2.(v2^2-(Proj(v2) on v1)^2) = Det(A) (assume expand v1 and v2 also)
                                            Area of T(Rectangle) = |k1.k2.det(A)| = (Area of Rectangle)* Det(A) - Det(A) that of transformation matrix
                                                Find tranforms of all vertices, then substitute in formula for area of parallelogram.
                                        </Determinant>
                                    </StandardizingInverseMatrix>
                                </FindingInverse>
                            </InverseTransformation>
                        </InvertibleFunction>
                        <ScalingTheVectors>
                            Finding Eigen vectors for a matrix- are the vectors which will get scaled up by the matrix.
                            These are more natural basis- helpful in some sort of transformation
                            EigenVectors- The vector which satisfies a scaling transformation (for a Transformation matrix)
                                EigenValue- the factor by which scaling happens for the eigen vector.
                                We want to find out eigen vectors which are non-zero for Av = kv
                                (kI-A)v=0 => v BELONGS N(kI-A)
                                    Recall, D's cols are LI iff N(D)={0}
                                    kI-A matrix has non-trivial solution => must have LD cols => not invertible => det(kI-A)=0
                                    we just gotta find k for which det(kI-A) give 0.
                                Eg- A=[1 2; 4 3]
                                    (k-1)(k-3)-8=0 => k=5,-1 (scaling factor)- eigen values
                                    eigen vectors- the set of vectors satisfying this scaling for transformation matrix.
                                        eigen space- N(kI-A)
                                            E(5)=[4 -2; -4 2][x y]t = 0
                                                = t[0.5 1] for t BELONG R.
                                                any vector along this line- will be scaled to 5 times.
                                            E(-1)=span[-1; 1]
                                                any vector along this line will be inverted by matrix.
                                Eg- A=[-1 2 2;2 2 -1;2 -1 2]
                                    Characteristic equation- P(k)=k^3-3k^2-9k+27=0
                                    P(3) is true- divide by (k-3) and solve -> k=3,-3,3
                                    for eigen vectors, v, A.v=kv or (kI-A).v=0
                                    E(3)=a.[-0.5 1 0]t + b.[0.5 0 1]
                                    E(-3)=t.[-2 1 1] for a,b,t BELONGS R.
                                EigenBasis form a good coordiate system
                                    Take dot product of E(3) and E(-3)
                                    E(3).E(-3)=0
                                    T:Rn -> Rn; T(x) = A.x
                                    Assume A has n LI eigen vectors
                                        T(v1)= Av1 = k1v1 = k1v1+0.v2+0.v3+..
                                        T(v2)= Av2 = k2v2 = 0.v1+k2v2+0.v3+..
                                        T(v3)= Av3 = k3v3 = 0.v1+0.v3+k3.v3+..
                                    Tranforming x, A.x = T(x)
                                        change of basis for x, [x]B=C^-1.x where C is conversion matrix and C.[x]B for x.
                                            transformation of x, uses some D matrix
                                            [T(x)]B=C^-1.T(x) and T(x)=C.[T(x)]B
                                            D maybe a good matrix to work with when Eigen basis (vectors themselves) are used.
                                                [T(v1)]B=[k1;0;0;..]=[d1 d2 ..dn][1;0;0...]=d1
                                                [T(v1)]B=[0;k2;0;0..]= d2 and so on.
                                                D=[d1 d2 ...] = [k1 0 0..;0 k2 0 0..;..]
                                Vectors are abstract representations of real world things
                                    Vectors of stock returns, weather, transformation- markov chains- probability of state change (gotta multiply many times)


                        </ScalingTheVectors>
                    </LinearTransformation>
                </Vectors>
                v.w = vt X w
                    A X x
                        Ax BELONGS Rm and x to Rn.
                        Ax.y = (Ax)t X y = (xt X At) X y = xt X (At X y)
                Left Nullspace
                    N(At) = At.x = 0 and N(A) = Span
                        Find At.x = 0 => (At.x)t = 0t => xt.A = 0t (Left Nullpace)
                        Eg- A = [2 -1 -2; -4 2 6] rref = [1 -0.5 -1.5; 0 0 0]|00
                            N(A) = Span([0.5 1 0]t,[1.5 0 1]), C(A) = span([2 -4]), Rank = 1
                            N(At) = Span([2 1]) = Nullspace of A, C(At) = Span([2 -1 -3]) = Rowspace of A, Rank = 1
                                Rowspace views rows in the form of vectors.
                            Verifies that Rank remains same whether you use column operations or row operations- but must be same throughout.
                        Rank(A) = Rank(At)
                            get rref for both A and At to relate!
                            Rank(A)- tells you #pivot cols => number of independent rows and independent cols (which can express others)
                            Rank(At)- #pivot cols => number of independent columns (that can express others) and number of independent row
                            The corresponding parts are the same for above 2.
                            #Additional Talk (to be merged)- Rank(At)- how many of cols in At are LI = how many of rows in A are LI- all rows in A can be represented in terms of pivot rows (being result of row operations)
                                Rank(At) = dim(C(At))=#of basis vectors for C(At)- rowspace of A.
                                A = [r1;r2;...], At = [r1 r2 r3...]
                                C(At)= span(r1,r2,...rm)- find basis for r1..m
                                rref(A) = pivot entries and non-pivot entries
                                    a set of row operations of A and rref(A) can produce each other.
                                        Thus, all rows of A can be represented as linear combinations of row of rref(A).
                                        Pivot rows are a basis for rowspace of A = C(At)
                                        Thus, Rank(At) = #pivot entries of rref(A)
                                    Rank(A) = dim(C(A))=#vectors in the basis for C(A)

                            It means that to find rank you can use row operations or column operations but should be same throughout.
                        C(A) PERPENDICULARtO N(At)
                            V1= c1.[2 -4]t and V2 = c2.[2 1]t
                            V1.V2 = 0
                        N(A) PERPENDICULARtO C(At)
                            Take any vectors on the plane by N(A)- take the 2 vectors themselves and dot product with C(At)
                            V1= [0.5 1 0], V2 = [2 -1 -3]; So, V1.V2 = 0
                            V1'=[1.5 0 1], V2 = [2 -1 -3]; So, V1.V2 = 0
                            So any other vector V = aV1+bV1' (Linear combination of V1 and V1')
                                will also be 0
                            Rowspace of A is orthogonal to Left Nullspace of At (N(Att))
                                Applications- Find orthogonal complement of subspace V (Span of its basis or C(A))
                                    perp(V) = N(At) = {x BELONGS Rn | x.v = 0 for every v BELONGS V}
                                    Is perp(V) a subspace?
                                        Addition- let a,b BELONGS perp(V)
                                            a.v =0 and b.v=0 for all v BELONGS V
                                            so, (a+b).v=0 for all v BELONGS V.
                                            a+b BELONGS perp(V)
                                        Scalar Multiple- Let a BELONGS perp(V)
                                            a.v=0 => (ca).v=c(a.v)=0 => ca BELONGS perp(V)
                            N(A) = perp(C(At))
                                A= [r1;r2;r3;..]- ri being row vectors- interpreted as cols.
                                N(A)=A.x=0 => r1.x=0 and r2.x=0 and so on. (r1 transpose to be exact)
                                if v BELONGS N(A) means r1.v=0 and r2.v=0 => their linear combination is also 0.
                                    Meaning subspace produced by r1,r2,etc = C(At)
                                    DOT PRODUCT of any N(A) with (Any linear combination of basis of C(At)) = 0 => the 2 subspaces are orthogonal.
                                    Thus, N(A) SUBSEToF perp(C(At))
                                if u BELONGS perp(C(At)) (u being any member of perpendicular to rowspace)
                                    let w BELONGS C(At)
                                    u.w=0 and u.r1=0 and u.r2=0 (u will be perpendicular to any vector in rowspace)
                                    [r1;r2;..].u=0 => A.u = 0 => u BELONGS N(A)
                                    Thus, perp(C(At)) SUBSEToF N(A)
                                Corollary, A=Bt => N(Bt)=perp(C(B))
                            Nullity of At
                                V=C(A)
                                dim(perp(V))=dim(N(At))
                                Rank(At)+Nullity(At)=n
                                dim(C(A))+dim(N(At))=n
                                dim(V)+dim(perp(V))=n
                                V INTERSECTION perp(V)={0}
                            (Remaining- Ep100-133)
            </LA>
            <Statistics>
                Khan Academy- Tags out of alignment.
            Stats
                    Population- average height of America
                            For population (Mu), impossible to get all of it.
                                    SIGMA(xi)/N
                            For sample (Xbar), take average of sample- more realistic.
                                    xi for every data for very element in a sample.
                                    SIGMA(xi)/n (where n < < < N)
            Descriptive
                    tell about data- without going thru it indicative of data
                    come up with a number that repeats a lot or central cendency or average.
                    Average- a number that someone that gives sense of central or e1 gets that!
                            Arithmetic mean (generally for average)
                                    SIGMA(number(i)/n)
                                    representative of a set of numbers.
                                    Dispersion- how much numbers run from mean
                                            find MU, 2,2,3,3 MU = 2.5
                                            0,0,5,5 = 2.5
                                            the 2nd set disperse more from mean- not indicative of mean so variance.
                                            Variance = sigma^2 = SIGMA((xi-MU)^2)/N
                                                    Make a table to calculate xi-MU and then add and divide.
                                                    why squaring- to make them all positive- how much they run away from mean.
                                                    .25*4/4 = 0.25
                                                    for second, 6.25*4/4 = 6.25
                                                    Faster calculation- Raw square method
                                                            (xi-MU)(xi-MU) = SIGMA(xi^2) -2MU.SIGMA(xi) + MU^2.SIGMA(1)
                                                            V = SIGMA(xi^2)/N - 2MU.SIGMA(xi)/N + MU^2.N/N
                                                            = SIGMA(xi^2)/N - 2.MU^2 + MU^2 = SIGMA(xi^2)/N - MU^2
                                            Sample Variance- S^2 = SIGMA((xi-Xbar)^2)/N	
                                                    maybe your sample mean is pretty close to samples but maybe wrong picture.
                                                    It's proven that S^2 is better estimate by divide by n-1 than n.
                                            Standard Deviation = sqrt(V)
                            Geometric mean
                            Harmonic mean
                            Median- position of a person in the middle of distribution (marks of n/2th person from a set)
                                    if even, then take arithmetic mean of middle to number 
                                    these are all human constructs- nth in universe.
                            Mode- what number is most common in set.
                                    if 112344- then 1 or 4 both is right.
                                    Eg- which shirt most saleable
                            Eg- 3 3 3 3 3 100- maybe rate of houses in a city.
                                    mean = 19.1 (1 number skewed it)
                                    median = 3
                                    Mode = 3
            Inferential
                    To make conclusion about things (population from sample)
                    Samples from population- 3 from population who will be president?
            Law of Large Number
                    Take observations and take mean of all observations- take sample mean.
                    Sample mean (Expectation) approaches population mean over infinite such samples.
                    Expectation of coins getting heads- 100 coins = 50 coins
                            gamblers' fallacy- if heads comes frequently, the probability of tail has not increased! But over Infinity, n/2 is expected.
                            after many trials maybe diverge quite a bit- very less probable though
                            but over infinite, it will merge.
                            this is used in casinos that eventually the house will win.
            Normal distribution Excel exercise- this is most important- any scientific field
                    field that curriculum doesn't cover it
                    aka bell curve or gaussian distribution.
                    came from astronomy by gauss.
                    Normal distribution is a good approximation of Binomial distribution and vv.
                            sum of all those trials approach Normal dist.
                            for weather pattern, drugs interactions, normal in finance may not work.
                            Normal is continuous but binomial is discrete.
                    @tossing a coin- heads move right and tails move left
                            steps = 10
                            mean = np = 0.5*10 = 5
                            variance = npq = 10*0.5*0.5 = 2.5
                            Making it n=20 steps- normal gets more skewed
                            My phone is ringing but I will ignore it- normal distribution is so important.
                            Binomial is easy to tell but normal- ending up at 2 feet- exactly to atom is 0 but take interval of 0.5.
                            standard deviation = sqrt(2.5)
                            after 10 trials, 
                                    Probability of being at step k = 10Ck.5^k.5^(10-k)
                            compare the 2 plots- they are pretty close.
                            as we keep increasing the number of trials, the binomial curve and normal distribution curve keep converging.
                    P(x) = (1/sigma.sqrt(2.PI)).e^(-z^2/2)
                            Standard z-score, z = (x-MU)/sigma- how many standard deviations far is X from mean.
                            Probability of exactly 10 (to the atom) is zero
                            we compute over interval of 1 unit so same as P(x) (area under curve)
                            Area under curve- rectangle (+ and -) or trapezium or integral.
                            = 1/(sqrt(2PI.sigma^2.e.z^2))
                    When infinite number of flips- we get normal curve
                            molecular interactions or compound X interacts with Y- but final results end up being normally distributed.                            
                    Eg- ppl whose height is 5 inch greater than average or ppl north of my house.
                    Graph
                            x-value at peak is mean.
                            change mean, changes the spike
                            if s.d is small, the spike graph or flat graph
                    Finding probability = 0, find integral(formula) from -1 to 1- not easy
                        CDF- INTEGRAL(P(x)dx) over -INFINITY to x.
                    Plotting graphs for P(X) and CDF (the integral value) from  -INFINITY to x.
                        1 SD away from mean- is always 68.5%
                    Eg- 
                        Hand span of school studs- normal distributed should be.
                            no negative value and no 1 mile sized hand.
                            can have more crests- say 1 for males and 1 for females.
                        Salary of large shipping company
                            minimal salary- cleaners, etc and whith growing job profile- more salary and outliers.
                            So, not perfect normal distribution (right skewed somewhere)
                        Annual salaries of CEO of major companies
                            base salary below which won't work- and skew way forward.
                        Dates of 100 pennies taken from a cash drawer in a convenience store
                            lots of recent pennies- so left skewed (negatively skewed)
                    mean=81 and SD=6.3 and given x, find z-score?
                    mean = 9.5 and SD = 1.1, what's percentage of ppl in range- 68-95-99.7 rules
                        mean +/- SD = 68% and mean +/- 2SD = 95% and mean +/- 3SD=99.7%
                    Standard Normal Distribution- Mean = 0 and SD = 1
                    z-score does apply to non-normal distribution also.
                    Central limit theorem- For all sets of samples, find the mean and plot the curve of their frequency, it will follow normal distribution.
                        S1 = [1,1,3,6], Mean(S1)=2.75
                        S2 = [3,4,3,1], Mean(S2)=2.75
                        S3 = [1,1,6,6], Mean(S3)=3.5
                        ...(take 1000s of them)
                        Plot mean vs frequency- it's a normal curve.
                            Sampling distribution of sample mean
                            use onlinestatbook.com to visualise your distribution.
                            Skew- long tail to right (positive skew) or left (negative skew)
                            Kurtosis- Positive kurtosis fatter tails, pointy peaks.
                                negative kurtosis (like plateau)- smaller tails and smaller near middle.
                            with increase in sample size, 
                                the skew reduces and kurtosis gets less negative.
                                    gets more normal- smaller SD for the graph.
                                    REL If I take million experiments for a sample- sample mean will be darn close of mean.
                                for n=1, it will be crazy outcome- not near normal.
                                for n=2, some values never happen
                                for n=INFINITY=> normal distribution.
                        mean for all such samples will be mean of the population.
                            this is basis for inferential statistics
                        come up with any crazy distribution (biasd dice)- you take mean of samples and study distribution
                    <StandardErrorOfMean>
                    Standard Error of the mean
                        Standard deviations (or variance) of sample distribution in terms of original distribution
                        It is inversely proportional to n. More the n, lesser the SD.
                        Variance of Sampling distribution =Variance of Original/n.
                        SD of sampling distribution = standard error of the mean.
                    Eg- male needs 2L; SD= .7L and daylong trip of 50 men and took 110L of water. can we run out?
                        P(Run out) = P(Use more than 110L by 22men) = P(average water per man used > 2.2 L)
                        Take sample of 50 men- n=50, mean of samples will still be 50.
                        SD of sampling distribution = 0.7/sqrt(50)= 0.099
                        We have to find out the area under the curve after the 2.2 point on the curve.
                        we can use z-score- z-table to get the area. 0.2 above the mean = 0.2/0.099 SDs away.
                        1 - 0.9783 = 0.0217 = 2.17% probability that we will run out of water.
                    Eg- 36 apples from farm's harvest of 2 lakh apples. Mean weight- 112g, SD=40g.
                        P(mean wt of all betw 100 and 124g)?
                        P(mean is within 1.8 SDs of sample mean of dist) = refer z-table
                        =(0.9641-0.5)*2 = 0.9282 = 92.8% percent chance that apples will weight in this range.
                    </StandardErrorOfMean>
                    <BernoulliDistribution>
                    Bernoulli Distribution- mean, variance, eg
                        Intro
                            go out survey in population- what you think of prez- 0 or 1 (favorable or not)
                            40% unfavorable and 60% favorable. P(U)=0.4 and P(F)=0.6
                            If I ask you what is the mean or expected value- let the outcomes take some value
                            Mean = 0*0.4 + 1*0.6=0.6 (no1 can say I am 0.6 favorable- it's 0 or 1)- no favorability value.
                            Variance = 0.4*(0-0.6)^2 + 0.6*(1-0.6)^2 = 0.24
                            SD = 0.49
                        Formula
                            P(1)=p and P(0)=1-p
                            Mean = (1-p)*0+p*1 = p
                            Variance = (1-p)*(0-p)^2 + p*(1-p)^2=(1-p).p^2+p(1-2p+p^2)
                                = p-p^2=p(1-p)
                            SD = sqrt(p(1-p))
                        <MarginOfError>
                        Margin of Error (inferential statistics)
                            Prez candidates A or B (call them 0 and 1 to do numeric maths on it)
                            say p vote forB and 1-p for A
                            Get a sample and get an idea of p- then how good that survey was.
                                randomly survey 100 ppl- A=57 and B=43
                                Sample Mean = 0.43 and Sample Variance generalized for population (use n-1 for n is small)
                                    (57(0-0.43)^2+43(1-0.43)^2)/(100-1)=0.2475
                                SD = 0.50
                                SD for the sample mean distribution = SD/sqrt(n)= 0.50/10 = 0.05
                                I want to find an interval such that "reasonably confident" that there is 95% chance that true mean is p
                            P(Sample Mean is within 2SD of mean of sampling mean distribution)
                                = P(sampling mean distribution is within 2.dist(SD) of sample mean)=95.4%
                                2.dist(SD)=0.1 we calculated
                                P(sample mean is within 0.1 (sth) of mean of sampling mean distribution)=95% (roughly)
                                P(sample mean is 0.43 +/- 0.1)=95% (roughly)
                                we are 95% confident that range is between 33% to 53%
                                All we have done is giving a margin of interval- confidence interval.
                                Here, margin of error- 10% (this is the best understanding we have)
                            Eg- Teaching survey- 6250 total. 250 were asked if PC is necessaary, 142 said yes.
                                find 99% confidence interval.
                                    Sample mean = (142*1+0*108)/250=0.568 = population mean
                                    Sample SD = 0.426; Population SD = 0.426/sqrt(250)
                                    Plot for normal distribution (theoretical)- for 99% confidence, need 3*SD from sampled dist mean.
                                    refer z-table- 99% chance that it (0.568) is within is 2.58*dist(SD) = 0.08 of the P or that P is +/- 0.08 of 0.568
                                How to narrow confidence interval maintaining 99% confidence level?
                                    ?increase sample size (remember formula for population SD)
                            Eg- after a drug for 3 months, 7 patients' BP increase is given- 1.5,2.9,0.9,3.9,3.2,2.1,1.9
                                find confidence interval for 95% confidence level for BP increase.
                                This is a T-distribution (it has fatter tails and it's not normal)
                                    2-sided- 95% with 6 degrees of freedom- 2.447 SD from sample dist mean = 0.96 from mean.
                                    2.34 +/- 0.96
                        </MarginOfError>
                    </BernoulliDistribution>
                            <HypothesisTesting>
                            Hypothesis testing and p-values
                                Eg- Drug dose to 100 rats (formerly 1.2 sec response time)- mean produced 1.05 sec with sample SD of 0.5 sec.
                                    does the drug have any effect?
                                    Null Hypothesis (status quo- existing state of affairs)
                                        H0: Drug has no effect
                                            population mean = 1.2 sec (even after drug)
                                    Wanna show
                                        H1: Drug has an effect
                                            => population mean != 1.2 sec (after drug)
                                    Assume H0 was true- if we reject H0, we have only other alternative.
                                    dist(SD) = sample SD/sqrt(100)= 0.05
                                    Find z-score- (1.2-1.05)/0.05 = 3 (beyond 99.7% confidence interval)
                                    0.3% chance of result to have appeared in this range. Means drug has an effect.
                                    p-value (probability value) is 0.003 (strong evidence that drug has effect)
                                    We just claimed that drug has an effect (extreme positive or negative)- this is called 2-tailed test.
                                Eg- significant level = 5% (=100-confidence level)
                                    57 outta 150 had internet access. 
                                        sample mean = 57/150 = 0.38
                                    Hypothesis- > 30% in US have internet?
                                    H0: p <= 30%
                                        P(H0) = 0.3
                                        It's a bernoulli distribution- mean = 0.3 and sd = sqrt(0.21)
                                        sample(sd) = sqrt(.21)/sqrt(150)= 0.037
                                        z-score = (0.38 - 0.3)/0.037 = 2.14
                                        check z-table for finding row and col for entry 95%- z-score = 1.65
                                            out z-score is way deeper than that- so H0 rejected.
                                    H1: P > 30%
                                Type1 Error
                                    Rejecting H0 even when it is true.
                                    Assume that H0 is true.
                                    Eg- 1% probability of H0 happening and so is rejected. There were still odds of it not being the case.
                                    Eg- Mean emission should be 20ppm; values of engines is given.
                                        sample mean = 17.17 and Sample SD = 2.98
                                        P(mean=17.17 | H0 is true) < 1%- that is we reject
                                        t-score = (17.17 - 20)/(2.98/sqrt(10)) = -3.00 (from sample to normal sd- population sd is bypassed in TStatistic)
                                        Degrees of freedom = n - 1 = 9
                                        check 99% and 9 degrees of freedom- -2.821
                                        the t-value we have gotten is way lesser than this.
                                        goes into our area of rejection.
                                        We can feel pretty good confident that engine meets standard.
                                    Eg Continued- what is 95% confidence interval
                                        check 2 sided against 9 degrees of freedom for the T-value
                                        substitute in formula to find the dist(mean)
                                Type2Error
                                    Fail to reject H0 when it was false.
                                1-tailed test
                                    H0: Drug has no effect
                                        mean = 1.2 sec
                                    H1: Drug lowers response time
                                        mean < 1.2 sec
                                    P(result lower than 1.05 sec) = 0.0015
                            </HypothesisTesting>
                            <TStatistics>
                            T-Statistic
                                vs z-statistic - (x- dist(mean))/dist(SD)
                                    dist(SD)=population(SD)/Sqrt(n)
                                        population(SD)=sample(SD)
                                            In formula, go ahead used instead of n if n > 30
                                            else we use T-tables to refer and formula, use n-1
                                    dist(mean) = population(mean) = sample(mean)
                                For details, find it interspersed within other/prev section.
                            </TStatistics>
                            <VarianceOfRandomVariables>
                            Variance of difference of random variables
                                say independent random variables X and Y- 
                                E(X) = population(mean of X) and E(Y) = population(mean of Y)
                                Variance of X = Var(X) = E((X-mean)^2) = SD(X)^2
                                Say random variable Z = X+Y
                                E(Z) = E(X+Y) => E(Z) = E(X) + E(Y) => mean(Z) = mean(X) + mean(Y)
                                if Z = X-Y => mean(Z) = mean(X)- mean(Y)
                                var(Z) = var(X) + var(Y) (in either case, X+Y and X-Y)
                                    refer to some book for proof- for var(-Y)=E((-y-E(-y))^2)=E((Y-E(Y))^2)=var(Y)
                            </VarianceOfRandomVariables>
                            <DifferenceOfSampleDistribution>
                            Difference of sample means distribution
                                Z = sampleMean(X)-sampleMean(Y)
                                what will be distribution of Z?
                                mean(Z) = mean(sampleMean(X))-mean(sampleMean(Y))- previous topic
                                Var(Z) = var(sampleMean(X))+Var(sampleMean(Y))
                                    = var(X)/n + var(Y)/m (we have used this formula b4)
                                Eg- mean wt loss for 100 ppl 
                                    in group 1 (fat free diet)- mean= 9.31 and sd = 4.67
                                    group 2- mean=7.40 and s = 4.04
                                    Here we are dealing with variable which deals with difference of mean
                                    mean difference = 1.91
                                    mean of mean difference = mean(g1)-mean(g2)=1.91
                                    z-value- 1.96 to get 95% confidence, i.e- mean +/- 1.96*(sd(mean(g1)-mean(g2)))
                                    Figure out if 1.91 is within 1.96*(sd(mean(g1)-mean(g2))) of mean of mean difference
                                        IOW, 95% chance that mean is within 1.96*(sd(mean(g1)-mean(g2))) of 1.91
                                        @I am 2 feet from you or you are 2 feet from me.
                                        sd of var = sqrt(var(g1)/100 + var(g2)/100)
                                    Hypothesis- H0: there is no change. sd from 0 for 95%- and 1.91 is out of the range.
                                        The range is +/- 1.02 and 1.91 is way out of its bound.
                                        OR the confidence interval for 95% confidence level on weight loss can be computed = 0.7 to 3.12
                                        TEACH I was not as articulate as I would like to be
                            </DifferenceOfSampleDistribution>
                            <ComparingPopulationProportions>
                                men- p1 vote for B and (1-p1) for A
                                women- p2 vote for B and (1-p2) for A
                                I want to check if there is meaningful difference betw P1-P2?
                                Eg- 1000 men- 642 for 1 and 1000 women 591 for 1.
                                    mean(p1)=0.642 and mean(p2)=0.591
                                    var(p1) = p1(1-p1)/sqrt(n)
                                    z = p1-p2 (previous topic)=0.049
                                    mean = p1-p2 and sd = sqrt(var(p1)+var(p2))
                                    sd(z) = 0.022 and z-score = 1.96 and confidence interval = 0.022*1.96=0.043
                                    95% confidence interval for P1-P2 is 0.008 to 0.094
                                    ANOTHER approach, tell 95% confidence interval from 0 (H0- hypothesis testing)- check where 0.049 lies?
                            </ComparingPopulationProportions>
                        <RegressionLine>
                        Regression Line- Squared Error of Regression Line
                            given a set of points- find a line that minimizes the square distance from those points
                            assume y=mx+b be the line. The error1 is vertical distance of points and line.
                            error(p1) = y1-(mx1+b); error(p2)=y2-(mx2+b) and so on.
                            Squared Error (SE) = (y1-(mx1+b))^2+(y2-(mx2+b))^2+...- we have to find m and b to minimize this SE.
                            SE = (y1^2+y2^2+...)-2m(x1y1+x2y2+..)-2b(y1+y2+...)+m^2(x1^2+x2^2+...)+2mb(x1+x2+...)+n.b^2
                            Let's take average over n,
                            y1^2+y2^2+... = n*mean(y^2)
                            SE = n.mean(y^2)-2mn.mean(xy)-2bn.mean(y)+m^2.n.mean(x^2)+2mbn.mean(x)+nb^2
                            Now we want to minimize SE, eth is constant except m and b- slope of SE w.r.t m and b will be zero (partial derivative)
                            Partial derivative assumes that eth except that is a constant so works similar to total derivative.
                            d/dm(SE) = -2n.mean(xy)+2mn.mean(x^2)+2bn.mean(x) = 0
                            d/db(SE) = -2n.mean(y)+2mn.mean(x)+2nb = 0
                            divide both equations by 2n.
                            -mean(xy)+m.mean(x^2)+b.mean(x)=0
                            -mean(y)+m.mean(x)+b=0
                            gotta solve for m and b.
                            OR 
                            m.mean(x^2)+b.mean(x) = mean(xy)
                            m.mean(x)+b = mean(y)
                                2nd eqn proves that (mean(x),mean(y)) point lie on the line.
                            Divide eqn1 by mean(x)
                                m.mean(x^2)/mean(x)+b = mean(xy)/mean(x)
                                (mean(x^2)/mean(x),mean(xy)/mean(x)) point exists on the line.
                            solving
                                m = (mean(x).mean(y)-mean(xy))/(mean(x)^2-mean(x^2)) = cov(X,Y)/cov(X,X) (cov later)
                                b = mean(y) - m.mean(x)
                            Eg- Points (1,2),(2,1),(4,3)
                                mean(x)=7/3 and mean(y)=2
                                mean(xy)=16/3 and mean(x^2)=7
                                m = 3/7 and b = 1
                                y = 3x/7 + 1
                        </RegressionLine>
                        <RSquare>
                        R-Squared or coefficient of determination
                            ?how much points were running from their mean (one another) vs from the line they were closer to.
                                for the same line- the set of points could have arranged themselves in many ways.
                                Measure of how good fit the line is for the points.
                                RS = 0 => x and y are independent
                                RS = 1 => x and y are strongly correlated- fit in 1 line.
                                ?Small p-value, strongly correlated.
                                Pearson's correlation coefficient = cov(x,y)/(sqrt(var(x)).sqrt(var(y)))
                            SE = total error = (y1-(mx1+b)^2)+...
                                REL substituting x1 in the equation gives 2nd part of term for y.
                            How much (%) of the variation in y is described by the variation in x.
                                (SE) from mean(y) = (y1-mean(y))^2+(y2-mean(y))^2+...
                                (SE) from line = (y1-(mx1+b)^2)+...
                                %age of variation not described by the regression line = SE(line) / SE(mean(y))
                                % of variation described by line = 1 - SE(line)/SE(mean(y))- called R-Squared or coefficient of determination.
                                    or %age of variation of y values is explained by variation of x.
                                Thus, if SE(line) is small => r^2 is close to 1 => Line is a good fit for the points.
                                SE(line) is  large then r^2 close to 1- very little variation is described by the line.
                            Eg- (1,2),(4,3),(-1,-1),(-2,-3)
                                y = 41x/42 - 5/21
                        </RSquare>
                        <Covariance>
                        Covariance- between 2 random variables
                            Measure of how much they vary together.
                                it is a term relative to another covariance.
                                Greater the value of covariance, strongly they are interrelated
                                Negative big value => inversely correlated
                                0 => independent.
                                Eg- If Cov(A,B)=150 and Cov(A,C)=50
                                    then A and B are more correlated than A and C.
                                    You may create a matrix of all columns- to tell- which cols are most correlated.
                            Cov(X,Y) = E[(X-E[X])(Y-E[Y])]- product of (distance of random variables from their means)
                                DA formula says- SIGMA((xi-mean(x))(Yi-mean(Y)))/(N-1)
                                E[XY - X.E[Y] - Y.E[X] + E[X].E[Y]]
                                = E[XY] - E[X.E[Y]] - E[E[X].Y] + E[E[X].E[Y]]
                                Recall, (E[E[X]] = E[X]- expected value of population mean is population mean)
                                = E[XY]-E[Y].E[X]-E[X][Y]+E[X].E[Y]
                                = E[XY] - E[X].E[Y] = mean(XY) - mean(X).mean(Y)
                                Corollary, Cov(X,X) = mean(X^2)-mean(X)^2 = Var(X,X)
                                    regression line's m = cov(X,Y)/cov(X,X)
                            Eg- X=1, E[X] = 0 and Y = 3 and E[Y] = 4
                            E[1.-1]- while X was above its expected value, Y was below
                                If 1 going up makes other go down (negative covariance)
                                If 1 going down makes other go down (positive covariance)
                        </Covariance>
                        <CorrelationCausality>
                                Correlation and Causality
                                    Causality established in some articles
                                        Eg- Eating Breakfast => Not obese, etc
                                        These things are not pointing causality- but correlation
                                        The study only looked into correlation- A and B tends to be happening at the same time.
                                        No data proves causation.
                                        Eg- Breakfast => active
                                            may be it is the other way round- those who are active are hungry in the morning.
                                            maybe you have better outcome skipping breakfast.
                                        Breakfast skipping => Obese? maybe reverse.
                                    A hypothesis
                                        Physical activity => Breakfast and Physical Activity => Not obese.
                                        They are thus correlated and not the causation.
                                        Eg- Obese person- will you tell them to eat breakfast and it may make things worse.
                                            maybe physical activity should be focussed on. May be lesser sleep could be problem.
                                        Sleep Late => Obesity
                                        Sleep Late => Skip breakfast
                                            again not related.
                                    I am not saying it is wrong- but there may be other causes and not make blankat statement.
                                    Another one
                                        Poverty => Skip breakfast
                                        Poverty => Less healthy diet => obesity.
                                        Maybe unhealthy dinners.
                        </CorrelationCausality>
                        <ChiSquareDistribution>
                            Chi-Square Distribution (say kai-square)
                                How theoretical distribution explain the observed ones.
                                How good a fit observed results are for theoretical distributions.
                                Process- find chi statistic = SIGMA(((Obs(i)-Exp(i))^2)/Exp)
                                    Check the chi-table for value calculated and row = degree of freedom (n-1) and find out the column 
                                    = p-value- probability- is the criteria to reject or accept the null hypothesis.
                                Random variables- normally distributed random variables
                                    mean is 0 and SD is 1.
                                    E[X] = 0 and var(x) = 1
                                Define a new random variable, Q = X^2
                                    distribution of Q is eg for Chi- square distribution.
                                    Kai has 1 degree of freedom.
                                    Q2- X1^2+X2^2- Q2 has 2 degrees of freedom.
                                Pearson's chi square test (goodness of fit)
                                    I want to buy and restaurant- this is the distribution they get.
                                    Day         M   T   W   Th  Fr  S
                                    Expect(%)   10  10  15  20  30  15
                                    Observed    30  14  34  45  57  20  - 200
                                    ExpectedNum 20  20  30  40  60  30
                                    H0: Owner's dist is correct.
                                        Expected is written in next row
                                        Chi-square statistic = X^2 = (30-20)^2/20 + (14-20)^2/20 + ... = 11.44
                                        Degrees of freedom, when nth entry can be figured from n-1.
                                            Here, degree of freedom = 5
                                            Refer Chi-chart (degree of freedom vs significance/area)- get the critical value 
                                            compare chi-statistic with critical value to reject/not H0.
                                            Chi^2 = 11.07 and ours is less likely 11.44
                                            So, we will reject H0- not a good fit.
                                    H1: Not correct, reliable. significance- 5%
                                Contingency table Chi-square
                                        Herbs vs sickness
                                                Herb    Herb2   Placebo Total
                                    sick        20      30      30      80   
                                    NotSick     100     110     90      300
                                    Total       120     140     120     380
                                    Process
                                        Significance is 10% planned.
                                        Hypothesis
                                            H0: Herbs do nth
                                            H1: Herbs do sth- are they different- may even increase.
                                        Get chi statistic
                                            What are the ideal numbers for the above table
                                            write expected values- find % for last rows and apply for all rows.
                                            2.53                                        
                                        Get critical value
                                            Degrees of freedom = (numberOfRows-1)*(numberOfCols-1)
                                                cuz the last row/col can be figured in terms of others- using percentage or subtraction.
                                            check against significance (col) and degree of freedom (row)- 0.10
                                            2.53 < 4.6 => can't reject H0. Herbs do sth.
                        </ChiSquareDistribution>
                        <Anova>
                                Anova- Calc SST (Total Sum of squares)
                                    3   5   5
                                    2   3   6
                                    1   4   7
                                    Groups are vertical.
                                    mean of means of groups or mean of all elements give same result.
                                    SST = 30 (divide by degrees of freedom to get variance)
                                    m group and n members in each group
                                        if you knew mean already- only 8 would give you new information- 9th can be computed- or 8 independent measurements.
                                        (3-4)^2+(2-4)^2+....=30
                                    SSW- sum of squares within
                                        all groups are computed from within and added.
                                        degree of freedom- need to know 2 for each group and 3rd can be figured out.
                                        so Degree of freedom = m.(n-1) = 6
                                        (3-2)^2+(2-2)^2+...+(5-4)^2+...+(5-4)^2+... = 6
                                    SSB- sum of squares between
                                        total variation is due to variation between groups
                                        degree of freedom = 2 = (m-1)
                                        (2-4)^2+(2-4)^2+...+(4-4)^2+(4-4)^2+...+(6-4)^2+..=24
                                    total variation SST = 30 d=mn-1
                                    SSW = 6 d=m(n-1)
                                    SSB = 24 d=m-1
                                    SSB + SSW = SST (variation in total is variation within groups and that across groups)
                                    d(SSB) = d(SSW)+d(SSB)
                        </Anova>                

            </Statistics>
            <TOC>
                <Foundation>
                    TOC- Sth about computation- task performed by computer or calculator
                        Model such machine- theory about it, capabilities, limitations.
                        Model what computation is and compiler design- 
                            Turing in 36,FSM in 50s,CFL in 60s.
                                Computation- long b4 computers. notion that thinking and logical argument, brute force.
                                He abstracted it all and came up with model- this is what is computation- not this way is too vague- not computation.
                                Nb really knows what goes on in brain. No1 knows mechanism.
                            Chomsky in 50s on grammars.
                            How to communicate to machine thru language!
                            Essentially how to parse a string and do something with it.
                                Knowing your capabilities; not helps make Programs.
                                what is computable.
                                space and time an algo (machine) takes.
                    Basics
                        Symbol- a,b,1,etc
                        Alphabets- A set of symbols- SIGMA = {a,b} or {0,1,2}
                        String- Concatenation of element of Alphabet.
                            a,aa,ab,bac,etc
                            Eg- Over, SIGMA = {a,b}, |SIGMA| = No of symbols in SIGMA = 2
                                SIGMA(2)= No of Strings of length 2 = aa,ab,ba,bb = 4
                                SIGMA(3)=2^3=8 ways to fill three spaces.
                            For |SIGMA| = k, total strings of size n are k^n.
                        Language- @Language is a collection of words (of course, connected by grammar rules).
                            Language in TOC is a collection of Strings following a property
                            Eg- SIGMA = {a,b}
                                Finite Language
                                    L1 = Set of all Strings of length 2 = {aa,ab,ba,bb}; It's a finite Language
                                    L2 = Set of all Strings of length 3 = ... Finite
                                Infinite Language
                                    L3 = Set of all Strings where each string starts with 'a'- {a,aa,ab,aaa,aab,aba,abb,aaaa,...}- Infinite Language.
                            Powers of SIGMA
                                Eg- over SIGMA = {a,b}
                                SIGMA^2 = SIGMA.SIGMA (concatenation) = {a,b}.{a,b}={aa,ab,ba,bb}
                                SIGMA^3, SIGMA^4,...SIGMA^n- language containing strings of length n.
                                SIGMA^0 = Language containing strings of length 0 = {EPSILON} = string of size of 0- no symbol.
                                SIGMA^*or SIGMA*= meaning any number of times concatenation = SIGMA^0 U SIGMA^1 U ....={EPSILON,a,b,aa,ab,ba,bb,aaa,aab,..}
                                    set of all strings possible over the set!- mother of all languages over the alphabet- obviously infinite.
                                    L1,L2,L3 SUBSETOF SIGMA*
                        Where will we use it?
                            Any input conforms to specification- any communication (console, network, information, IOT/Stream data) follows a format or regular expression.
                                check if the streak conforms to accepted pattern.
                            C programming language
                                Symbols- we use a finite set of symbols- a-z,A-Z,*,%& (special symbols), etc
                                Strings- words- void main(){int a,b;}   //In TOC, it is just a string.
                                Language (C Programming Language)- a set of all "valid" C programs- (invalid- errors)
                                    Infinite- {P1,P2,P3,...}
                                    How can I tell if the program is valid or not- 
                                        Given a Language L, is String S in L- Scan all Strings in L and check if anyone matches with S but L infinite, then problem!
                                            Save all programs on PC and compare P matches with Pi- But infinite programs possible!
                                        Using Representation/ Properties
                                            Eg- 
                                                If L1 is strings of length 2, is aaa in Language- Straight- "NO".
                                                    Why? we used a properties of language to conclude.
                                                L2 is all string starting with a, Is baba in Language? No.
                                                    Why? On scanning thru the string, I check for the property that L2 conforms to.
                                                    Imagine comparing in infinite Loop.
                                                L3 all strings where every third symbol is a.
                                                    you start from reading a, ignore 2nd symbol, check 3rd for a, ignore 4th, check 5th for a.
                                            #Partition the SIGMA*- let me partition all the possible strings into sets (regular sets), following different properties- 1 of which is of our interest (final state)
                                                partition may be as simple as 1. string that follow this property 2. strings that don't follow this property. But generally we may need more logical change of states.
                                                As i read the input symbols, I make transitions (conclusion shifts- current state of affair), which set does the string at hand (read so far), falls into.
                                                Call these partitioned regular sets as States and Change in States as Transition.
                                                @Think how psychology works- while reading an input streak of data- what housekeeping you need.
                                            Represent Language in some finite way- another way of writing a set- besides property way or enumeration way.
                                                given a string, check it against the representation and tell results as yes, no.
                                                Finite automata.
                                                    Circles as states- arrow from nowhere is start state and double circle is final.
                                                    arrows marks transition on seeing an input.
                                                    After scanning entire string, we reach final state so string is within language or is accepted.

                </Foundation>
                <Ref>
                    Ravindrababu ravula
                    HarryPorter
                    IITK
                    IITM
                </Ref>
                <concepts>
                    <InformationTheory>Everything can be described in the form of a string.</InformationTheory>
                    Solve Problem vs Problem instances.
                        In TOC, we plan a machine for a problem which will solve all the instances of it.
                            our machine will parse the instance and carry out its tasks to solve the problem instance.
                    cool thinking and lots of application from this course
                            compiler and translate languages.
                            model of computations correspond to progs that help us write compilers.
                            Computer architecture model processor as State machine comes from TOC.
                            String searching in editor is FSM.
                            Compiling or representation, xml do with grammar.
                            We compute something. Abstract it from all specifics of machines and probs.
                    We are essentially talking about programs/computations that take input.
                            and it sees and thinks and calc and do I accept this input or not.
                            pick an alphabet- binary or whatever
                                    Eg- Set of binary strings= set of binary strings that end in 0.
                                    You just look at the end of it and say if it is true.
                                    easy program to make.
                            Java code to binary- was it java code or not? 
                                    set of binary strings that represent legal java program
                                    can you write a program like that? or 7!
                                    compiler design tells spits error out but more complicated that that.
                            Program that looks at java code and tells that program will never stuck in infinite loop.
                            We will abstract out with what PL essentially is- Turing machine.
                                    mathematical abstraction was complete representation of how we use computation.
                                            normal computer- write a program on his machine. Prove that such program can never be done.
                                            If I handicap it- cut off left arm metaphorically. I may not be able to do sth or take longer.
                                    We will start from rock bottom and climb up to turing machine
                    <Acceptor>
                        Mathematical Models to identify the language.
                        They have their graphical representation and execution trace.
                    </Acceptor>
                    <Generator>
                        To generate the entire language- nothing but grammars are used to generate them.
                    <Grammar>

                        <Intro>
                            1959 N Chomsky introduced the term. Gave a mathematical model of Grammar.
                                Any sentence- derivation top to down and down to up is parsing- the tree formed is syntax tree.
                                Let's see the rules here- S-> {Noun phrase} {Verb phrase} and so on.
                        </Intro>
                        To Generate a language as per specified rules
                        it's a tuple- (V,T,P,S) 
                            Vertices (aka non-terminals)- generally denoted by capital letters.
                            Terminals- generally denoted by capital letters.
                                only things final strings contain
                            Productions- rules used to generate strings.
                            Start symbols- BELONGS V. From where production rules can start.
                            Derivation- generating strings from Grammar following P, is called derivation.
                                How to do it?
                                    Eg- V={S,B},T={a,b},P={S->aSB,S->aB,B->b},S=S.
                                    Left Most Derivation- replacing in derivation the leftmost vertex.
                                        S->aSB->aaBB->aabB->aabb (interim sentential/ sequential forms) 
                                    Right Most Derivation- replacing in derivation the right most vertex.
                                    To generate a particular string- see the symbol to be generated and choose apt production.
                                Representation- 
                                    Derivation Tree- make a tree for a derivation
                                        aka parse tree.
                                        yield of tree- string generated (leaves on euler tour)
                                Make a grammar
                                    Finite Language- Let start symbol generate all the strings.
                                        Eg- Strings of length 2- {aa,ab,ba,bb} 
                                            so S->aa|ab|ba|bb.
                                            OR if Regex= (a+b)(a+b), we can write concat of vertex which generates a or b so
                                            so S->AA,A->a|b
                                        Eg- L={a^n|n>=1}
                                            Let a non-terminal keep generating a AMAP and stop aptly.
                                            A->aA|EPSILON- use this whenever Kleene's Closure.
                                                can have many representations like A->Aa|EPSILON or Aa|a.
                                        Eg- L = (a+b)*
                                            It is kleene closure of a+b.
                                            So, A->a|b, S->AS|EPSILON
                                            S->abab- choose strings aptly.
                                        Eg- strings of odd length
                                            regex- ((a+b)(a+b))*(a+b)   (not possible after regular languages but grammars possible for them)
                                            Concatenation and kleene's closure and union
                                                S->AB
                                                A->CA|EPSILON
                                                C->BB
                                                B->a|b
                                        Eg- Strings of length at least 2
                                            regex- (a+b)(a+b)(a+b)*
                                            S->AAB,A->a|b,B->aB|bB|EPSILON
                                        Eg- At most 2.
                                            regex- (a+b+e)(a+b+e)
                                            S->AA,A->a|b|e.
                                        Eg- Starting with a and ending with b
                                            regex- a(a+b)*b
                                            S->aAb
                                            A->aA|bA|e.
                                        Eg- Starting and ending with different symbols
                                            regex- regex- a(a+b)*b+b(a+b)*a
                                            S->aAb|bAa, A->aA|bA|e.
                                        Eg- S->aAa|bAb|a|b|e, A->aA|bA|e.
                                            Starting and ending with same symbols.
                                        Eg- {a^nb^n|n>=1}
                                            2 sided growth together.
                                            S->aSb|e or aSb|ab.
                                        Eg- Palindromes- wwR (even length),wawR,wbwR(odd length)
                                            Grow same symbols on either side together.
                                            S->aSa|bSb|a|b|e.
                                        Eg- Even length strings
                                            ((a+b)(a+b))*
                                            S->BS|e,B->AA,A->a|b.
                                        Eg- a*b*- S->AB,A->aA|e,B->bB|b.
                                        Eg- a^nb^nc^m|n,m>=1; 
                                            concatenation of a^nb^n and c^m.
                                            S->AC, A->aAb|ab, C-> cC|c  (no e cuz n,m>=1)
                                        Eg- a^nb^mc^n|n,m>=1;
                                            Sandwitch b^m in generation of a^nc^n (followed by b^m for sandwitching)
                                            S->aSc|aAc, A->bA|b
                                        Eg- a^nb^nc^md^m (concat of 2 a^nb^n types)
                                            S->AB, A->aAb|ab, B->cBd|cd.
                                        Eg- a^nb^nc^n|n>=1
                                            fallacy- S->aSbc|bc- this is a^n.(bc)^n
                                            Different grammar- CSG (Context Sensitive Grammar)
                                        Eg- a^n.b^2n|n>=1
                                            Generate 2 b's for every a.
                                            S->aSbb|abb
                                        Eg- a^nb^mc^md^n
                                            Sandwich b^m.c^m in a^n.d^n (followed by)
                                            S->aSd|aAd, A->bAc|bc
                                        Eg- a^nb^mc^nd^m|n,m>=1; no CFG again.
                                        Eg- a^(m+n).b^m.c^n|m,n>=1
                                            rearrange as a^n.a^m.b^m.c^n (sandwitch)
                                            S->aSc|aAc, A->aAb|ab.
                                            Similarly, a^n.b^m.c^(n+m)
                                        Eg- a^nb^(n+m)c^m|n,m>=1
                                            rearrange as a^n.b^n.c^m.d^m (concat)

                        <Types>
                            <Type3>
                                aka Regular Grammars.
                                For generating Regular Languages.
                                Form- A-> ALPHA.B | BETA, where ALPHA,BETA BELONGS T* and B BELONGS V.
                                    Right linear form
                                        Eg- A->aB|a,B->aB|bB|a|b.
                                    LLG- Left Linear Form- A-> B.ALPHA | BETA (Variable is left most side)
                                        Eg- A-> Ba|a, B-> Ba|Bb|a|b.
                                    RLG- Combination of the 2 isn't type3.
                                        Eg- A->Ba|a,B->aB|a, isn't type3.
                                Equivalence- to FSM.
                                    FA->RG
                                        for every transition from State S to T on seeing symbol a, write production as
                                            S->aT (Production Rules for every transition) or s (if T is final state, but may not be complete)
                                            For self loop on final state T, T->aT|bT|e.
                                            represents strings starting with a.
                                            This generates Right Linear Grammar
                                        For Left Linear Grammar, 
                                            Reverse the productions, A->Ba, B->Ba|Bb|e  //this is reverse Language of original.
                                            Reverse the FA (Reverses the Language)- (maybe, an NFA, but that's ok)
                                            Construct RLG from the FA (L Reverse)
                                            apply reversing the productions to get LLG (Rev(Rev(L))=L)
                                            FA->(FA)R->RLG->LLG.
                                        This proves that RG is more powerful but let's see the next.
                                    RG->FA
                                        RLG, For productions, put all terminals on transition
                                            concat means extra states, parallel paths means both symbols on 1 edge.
                                            Left vertex becomes From State and Rightmost becomes To State.
                                            For terminals only, take it to final state which on reading anything, goes to dead state.
                                                or intelligently new final state need not be made (maybe one of the vertex)
                                        LLG, 
                                            convert to RLF by Reversing the productions.
                                            LLG->RLG->FA->(FA)R.
                                Equivalence to RE.

                            </Type3>
                            <Type2>
                                aka Context Free Grammar (Context Free cuz replacement of vertex doesn't depend on any context)
                                    Every Type 3 is Type 2 (see defn)
                                Form- A-> ALPHA where A BELONGS V, ALPHA BELONGS (V U T)*
                                Eg- A->aAb|ab
                                    A->aAb->aabb
                            </Type2>
                            <Type1>
                                    aka Context Sensitive Grammars.
                                    Context- aA->aa (in derivation replace A by aa only when A is preceded by a)
                            </Type1>
                            <Type0></Type0>
                            <anotherCriteria>
                                LeftLinear
                                RightLinear
                            </anotherCriteria>
                        </Types>
                        <Refinement>
                            Elimination of Epsilon Productions
                            Elimination of Unit Productions
                            useless symbols, etc.
                        </Refinement>
                    </Grammar>
                    </Generator>
                    <Representors>
                        Operators- RE Represented thru Regular Expressions which use
                            UNION (U)
                            CONCAT (.)
                            Kleene Closure (*)
                        Primitive Regular Expressions
                            Special Symbols- PHI (for language that contains nothing or NULL state)
                            EPSILON (empty string or language that contains empty string)
                            a BELONGS SIGMA and b BELONGS SIGMA.
                        Obtained thru applying operations
                            r1+r2, r1.r2, r1*
                            apply operators any numbers of times and that gives Regular expression.
                            Eg- a*- {EPSILON,a,aa,..}, a+- {a,aa,..}, (a+b)*- {EPSILON, a,b,ab,ba,aa,...}
                    </Representors>
                </concepts>
                <Languages>
                    <RegularLanguage>
                        <RegularSets>
                            Or Regular Expressions
                            Write all possible states and search some pattern
                            Eg- strings of length 2 = {aa,ab,ba,bb}
                                aa+ab+ba+bb = a.(a+b)+b.(a+b) = (a+b).(a+b)
                                strings of length n = (a+b)^n   //^ is not valid regular expression
                            Eg- Strings of length at least 2 = {aa,ab,ba,bb,aaa,aab,..}
                                (a+b)(a+b)(a+b)*- Strings of length 2 concatenated with any string over sigma.
                            Eg- Strings of length at most 2 ={e,a,b,aa,ab,ba,bb}
                                e+a+b+aa+ab+ba+bb
                                (e+a+b)(e+a+b)
                            Eg- Even length strings- could be formed by concatenating 2 length strings.
                                ((a+b)(a+b))*
                            Eg- Odd length strings- concatenate even length string with a or b.
                                (a+b)((a+b)(a+b))* = (a+b)^(2n+1)   // not valid but to get an idea
                            Eg- Strings of length divisible by 3.
                                closure of string of length 3.
                                ((a+b)(a+b)(a+b))*
                            Eg- Strings which are of form (a+b)^(3n+2)- 2 mod 3.
                                concatenate strings of length 2 with strings divisible by 3.
                                ((a+b)(a+b)(a+b))*(a+b)(a+b) = (a+b)((a+b)(a+b)(a+b))*(a+b) = (a+b)(a+b)((a+b)(a+b)(a+b))*
                            Eg- number of a's is exactly 2.
                                2a's can have any number of b's anywhere around them
                                b*ab*ab*
                            Eg- at least 2 a's
                                There can be more than 1 regEx.
                                b*ab*a(a+b)*    //considering only 1st 2 a's 
                            Eg- at most 2 a's.
                                b*(a+e)b*(a+e)b*
                            Eg- even number of a's.
                                closure of exactly 2 a's.
                                (b*ab*ab*)* but the problem is it can't generate bbb; any string 2 a's come with it- so adding to b*
                                (b*ab*ab*)*+b* OR (b*ab*ab*)*b*
                            Eg- Starts with a- a(a+b)*
                            Eg- Ends with a- (a+b)*a
                            Eg- contains a- (a+b)*a(a+b)*
                            Eg- Starting and ending with different symbols
                                a(a+b)*b+b(a+b)*a
                            Eg- Starting and ending with same symbols
                                e+a+b+a(a+b)*a+b(a+b)*b
                            Eg- no 2 a's should not come together= {e,b,bb,bbb,a,ab,aba,abab,ababa,ba,baba,babab}
                                observe the building blocks- we can use b,ab,ba.
                                not both ab,ba together- baab will put a's together.
                                (b+ab)*- but not enough what about strings ending with a.
                                (b+ab)*+(b+ab)*a = (b+ab)*(e+a) Or (b+ba)*(e+a)
                            Eg- no 2 a's and no 2 b's should come together = {e,a,b,ab,ba,bab,aba,...}
                                I can categorize such strings in 4 classes
                                    starts with     Ends With   Strings
                                    a               a           {a,aba,ababa,...}=a(ba)* or (ab)*a
                                    a               b           {ab,abab,ababab,..}=(ab)* or a(ba)*b
                                    b               a           {ba,baba,bababa,...}=(ba)* or b(ab)*a
                                    b               b           {b,bab,babab,bababab,..}=b(ab)* or (ba)*b
                                Taking common factors, together we have-
                                    (ab)*a+(ab)*+b(ab)*a+b(ab)* = (ab)*(a+e)+b(ab)*(a+e)=(e+b)(ab)*(e+a)
                            Identities of RE
                                PHI + R = R + PHI = R
                                PHI.R = R.PHI = PHI
                                e.R = R.e = R
                                e* = e
                                PHI* = e
                                e + RR* = R*R+e=R*
                                (a+b)*=(a*+b*)=(a*+b)*=(a+b*)*=(a*b*)*=(a*(ba*))*=b*(ab*)*
                            Is given language regular?
                                Every finite language is regular- connect all strings by +.
                                Infinite- there should be FSM to make it- there has to be a loop to generate (so pattern has to be there)
                                    Pumping lemma- 
                                        Put a pattern; if you can find a pattern, doesn't mean Regular but if you can't find a pattern, it is not regular.
                                        It's a negativity test- can prove non-regularity; for proving regularity, use FSM, regex,etc.
                                    a^n|n>=1, yes, it's simple.
                                    a^mb^n|m,n>=1, yes, DFA for it.
                                    a^nb^n|n<=10^10^10  ; yes, it's finite
                                    a^nb^n|n>=1; count a's then b- without memory I can't. DFA remembers thru states.
                                    w.wR||w|=2; finite set so regular.
                                    w.wR|w BELONGS (a,b)*- memory reqd
                                    ww|w BELONGS (a,b)*- no
                                    a^nb^mc^k|n,m,k>=1; DFA possible, nth to remember.
                                    a^i.b^2j|i,j>=1; no couting reqd. DFA possible
                                    a^i.b^4j|i,j>=1; DFA possible
                                    a^n|n is even- pattern is AP- it's DFA.
                                    a^n|n is odd- pattern in AP
                                    a^n|n is prime- can't find a loop so not regular
                                    a^(n^2)|n>=1; no pattern, not reg
                                    a^(2^n)|n>=1; no pattern, not reg.
                                    a^i.b^j^2- b^j^2 makes it not reg- can't generate that.
                                    a^i.b^2^j- no
                                    a^i.b^p| p is prime- no
                                    w|w has equal number of a and b.    keeping track of growth of 1 over other is not possible in DFA.
                                    number of a mod 3 = number of b mod 3; can count modular but not unbounded so reg.
                                    wwwR- not possible; counting and comparison reqd.
                                    a^nb^nc^n- memory reqd.
                                    a^n.b^(n+m).c^m- memory reqd
                                    wxwR|w,x BELONGS (0,1)+
                                        Surprise! this is regular. since x is arbitrary- let it eat up eth and compare only 1st and last symbol to declare in language or not!
                                        I am free to take x as anything- so I will take it as 1(0+1)*1+0(0+1)*0
                                    wxwR||x|=5, this is not regular cuz x can't be expanded.
                                    xwwRy|for x,y BELONGS (a,b)*
                                        expand x and y to find any repeating alphabet/symbol- language containing 00 or 11 as substring- (0+1)*(11+00)(0+1)*
                                        if x and y are restricted by length or so- it is not regular anymore.
                                    xwwR- x can be growing but no guarantee of finding wR for w.
                                    wwRy- even expand till last symbols- no guarantee to find same symbols.

                        </RegularSets>
                        <AcceptorFSM>
                            <FAwithoutOutput>
                                <DFA>
                                Quintuple. A machine which is in a state and makes a unique transition on seeing an input.
                                        Write down A start State, SIGMA, Set of States, Set of Final States SUBSEToF Set of States, Transition Rules.
                                        Transition SUBSEToF Q X SIGMA -> Q ( a relational triplet- state seeing input goes to a state.
                                            DFA- Unique Q and being a function, all elements of Q X SIGMA must map somewhere.
                                            Motions are conditional statements in PL.
                                Representations- 
                                    Function- writing all mappings, mathematically.
                                    Relational Diagram- mapping from a set to another. 1 set into another.
                                    State Transition Diagram- Graph with nodes and edges to denote state and transitions- edges labelled by input symbol.
                                    State Transition Table- States vs Input and table entries contain changed state.
                                About- 
                                        DFA are important in CS- programmable.
                                        FSM can do anything by remembering essence of all information till now
                                            a machine that has head from front and moves from state to state after reading i/p.
                                        Decision problems- Only answers are Yes or No. Later, computational work.
                                    Eg- SIGMA = {a,b}, of length = 2, Identify the acceptable strings (or regular expression- not necessary but enumeration helps)
                                        Write the skeleton of acceptable strings.
                                        Add states to accomodate others with transitions.
                                        Reached C on seeing aa or ab or so- on seeing one more alphabet, we should go to dead state. To complete, on seeing a,b in D state, stay there.
                                        aa is accepted cuz on scanning entire string, I reach accepting state abba is not cuz I am at a non-accepting state.
                                    String Acceptance-
                                        Accepted- if we reach final state from initial state after scanning entire string.
                                        Rejected- if not in final state (non- accepting state)
                                    Language Acceptance- A FSM is said to accept a language if 
                                        all the strings in language are accepted 
                                        all strings not in language are rejected    //I can always make an FSM that accepts eth- but property checking is lost. 1 with 1 state- keeps it itself on seeing anything and is final state.
                                    Solving-  
                                        Basic
                                            Algo- 
                                                Identify the language (some sample inputs,regular expression)
                                                determine a criteria for states 
                                                s.t final acceptable and unacceptable are identifiable.
                                                are exhaustive
                                                are mutually exclusive
                                                with a bit of input added, the "unique" (true for all members of state) state change can be known.
                                                    add transitions on possible inputs for all the states.
                                                (basically partioning defn only)
                                                Draw the basic/fundamental DFA that accepts strings within language- then accomodate others.

                                            For every finite language, we can give DFA but infinite, we try.
                                                1 language can have many DFA but unique minimal DFA.
                                            Length/Counting Based
                                            Eg- L which has words of length >=2,<=2,=2 (only >=2 will take 3 states (why? 2 or more will suffice))
                                                let states represent set of all states of length =0,1,2,3 or more.
                                            Eg- Length of string be even- |w|mod2=0 ; infinite so let's try for DFA.
                                                see pattern if we were take 2,4,6 as states, it will never end.
                                                It is called finite automata (cuz finite states represent it)
                                                2 states- odd length, even length- we can minimize DFA with 3 states- where 1st just starts off.
                                            Eg- No of a's = 2.
                                                states= no of a's seen- 0,1,2,more.
                                            Divisibility Based- Under Counting only
                                            Eg- |w|mod3=0. states on remainder- 0,1,2. 
                                                could be |w|=1 mod n(same as |w|mod n=1)- will take n states.
                                            Eg- No of a's is even, (or multiple of 3)
                                                states- no of a's is odd, even.
                                                No of a's is N- N states.
                                            Eg- No of a's and b's be even (different from even length strings- Eg- ab)
                                                on a new bit of symbol- either of numbers change- can say flip states- let's take their cross product- ee,eo,oe,oo- take all strings can be put in 1 of these)
                                                    ee is final. EPSILON in ee.
                                            Eg- a string over {0,1} when interpreted as binary is divisible by 2.
                                                unary system- using stones to count- only 1 symbol- 0. 0 for 1,00 for 2, 000 for 3, so on.
                                                Decimal Number- 0,1,2,3...- 10 symbols- 0,1,..9. Octal- 0,1,..8; Binary- 0,1; Hexadecimal- 0,1,2,..9,A,B..F.
                                                in decimal, 1 concatenated 2 means 12 or 1 of 10s and 2 of 1s.
                                                    123 means 1 of 100s, 2 of 10s and 3 of 1s. weight in 10's power grows as we move left.
                                                Same goes with binary; another way to interpret it is
                                                    101101- 10 means 2, go ahead multiply by 2 and add 1- 5, go ahead mult by 2 and 1= 11- *2+0 - 22*2+1=45.
                                                    Applicable to any number system.
                                                        (101)base 3 = 1*3+0=3*3+1=10
                                                    you can imagine how decimal to binary will be reverse of this.
                                                Here, divide strings into 2 classes- remainder 0,1.
                                                    Take specific eg to plot the DFA. say 10 or 11, etc.
                                            Eg- Divisible by 3 when interpreted as binary.
                                                remainder of 0,1,2.
                                                State Transition Table- States vs Input symbols- table data is state reached.
                                                    blindly write q0,q1,..in streak. It's right answer.
                                            Eg- Binary number divisible by 4.
                                                    Bad way- convert it to base 10 by adding 'em. Divide by 4. No remainder then yes. Deterministic!
                                                            it's hard way to do it.
                                                    Good- Any division by power of 2 is obvious. See last few symbols.
                                                            write a machine that identifies a binary string ending with 00.
                                                            Decide end in 2 0's- start from the end- write 2 0's and nth b4 that.
                                                            2 states- last 2 bits were 0. last 1 bit was 0.
                                                Shortcut approach- transition table as follows: blind writing:
                                                        0   1   012 0   1   2
                                                    Q0  Q0  Q1      Q0  Q1  Q2
                                                    Q1  Q2  Q3      Q3  Q0  Q1  
                                                    Q2  Q0  Q1      Q2  Q3  Q0
                                                    Q3  Q2  Q3      Q1  Q2  Q3
                                                    Verify!!
                                            Eg- SIGMA = {a}; L={a^n|n>=0,n!=3} OR L={a^n|n>=0,n!=2,n!=4}
                                                count till three- seen nothing,seen 1 symbol, seen 2 symbol, seen 3 symbols, seen more.

                                            Pattern Checking
                                            Eg- Strings starting with a
                                                make a skeleton- on a final state but complete it- on b- dead state (meaning we can't reach final state from there). On B, keep to itself on seeing anything.
                                                Need 3 states- 1 extra dead state
                                            Eg- Strings that contain a
                                                Skeleton- single a and complete-
                                                States- seen no a till now, seen an a. 
                                                    whatever after that accept.
                                            Eg- Strings ending with a.
                                                Last read symbol was a, Last read symbol was not a.
                                                Skeleton- 1 a transition to F.
                                            Eg- starts with ab.
                                                let's draw skeleton- a and then b to F state. Remove all exceptions.
                                                States- I last saw an a, I last saw b after a, I saw nothing, I saw exception.
                                            Eg- containing ab as substring
                                                seen a, seen ab, seen nothing (seen exception won't exist- can see it later)
                                            Eg- ends with ab
                                                last saw a, last saw b after a, others.
                                            Eg- Every a followed by b.
                                                seen a, seen ab, seen a but not b, seen nth.
                                            Eg- Every a should never be followed by b.
                                                This is not the complement of previous one- many common elements like EPSILON,b,bb,etc.
                                                    it's complement should be every a is not followed by b OR there exists an a which isn't followed by b.
                                                Make skeleton for dead state first.
                                            Eg- every a followed by bb. Not same as contains abb.
                                                containing abb somewhere once or so vs must have.
                                                no a at all, is ok but if a, then bb.
                                            Eg- a should not be followed by bb- make skeleton for dead state. all other states are acceptable.
                                            Eg- L={a^nb^m|n,m>=1}
                                                Seen nothing, seen 1 or more streaks of a, seen 1 or more streaks of b only, exception state.
                                            Eg- L={a^nb^m|n,m>=0}
                                                seen streaks of a, seen streak of b after a's, exception.
                                            SIGMA = {a,b,c}
                                            Eg- L={a^nb^mc^l|n,m,l>=1}
                                                draw the skeleton- seen 1 or more a, b, c, exceptions.
                                            Eg- L={a^nb^mc^l|n,m,l>=0}
                                                seen a's,seen 1 or more b's,seen 1 or more c's, exceptions- may see a c after a!
                                            SIGMA = {a,b}
                                            Eg- 2nd symbol from LHS is a. (or kth symbol is a- k+2 states)
                                                Start, seen 1st symbol, seen a as second symbol,exception.
                                            Eg- L={a^3bwa^3|w BELONGS SIGMA*}   //start string and ending string is same.
                                                make skeleton.
                                                Exception, self loop for w (for NFA but DFA works it out)

                                            Eg- {a^n|n>=1}
                                            Logical Operators-
                                                Regular Sets are closed under everything.
                                                Operations over languages (may make it NFA- check NFA solving separately)
                                                Cross Product (AND)
                                                    About
                                                        A INTERSECTION B = (A' U B')'
                                                        Complement A machine, B machine- Union them and then complement it.
                                                        So closed under intersection.
                                                        But in literal sense- use product of the 2. Total states mn can show up.
                                                        State with both alphabets are final states of individual machines.
                                                    Algo- cross product method-
                                                            make DFA for 1 condition.
                                                            make DFA for 2nd condition
                                                            take their cross product (of DFA)
                                                                cross product their states.
                                                                for all such state combinations- check how state combination transition happens for an input- (state of 1st,state of 2nd)-transitions into-(state of 1st,state of 2nd)
                                                    Eg- Even no of a's and even no of b's
                                                        Make L1 for even no of a's and L2 for b- keep track of states of both DFA with any input symbol.
                                                    Eg- no of a's divisible by 3 AND no of b's divisible by 2- 6 states.
                                                        states- 00,10,20,01,11,21 (no of a,no of b)
                                                        if no of a mod 3 > no of b mod 2. meaning final states- 00,10,20,21,11
                                                        if no of a mod 3 > no of b mod 2. meaning final states- 00,11
                                                        make a horizonal a counter and vertical b counter and u are good to go.
                                                    Pattern Probs
                                                    Eg- starts with a and ends with b.
                                                        concatenation of language L1 starts with a with L2 ends with b.
                                                        Do necessary plugging.
                                                    Eg- starts and ends with different symbol
                                                Union (OR)
                                                        Merge start states of 2 DFA or a new start state with epsilon transition (NFA) to starts states of the 2 DFA.
                                                        Eg- no of a's OR no of b's are even.
                                                        a start and b end or b start and a end.
                                                        Traffic police and redirect as per first symbol- 2 DFA connected thru common start state.
                                                        their start state could be merged cuz one's dead state was alive for other.

                                                        Eg- Even # no 0s OR contain 101.
                                                        Instead of trying both at a time, just abstract a little and just mix the 2 ideas thru epsilon-transitions.
                                                COMPLEMENT (NEGATION)- Applies only to DFA.
                                                    (Q,SIGMA,DELTA,q0,F)->(Q,SIGMA,DELTA,q0,Q-F)
                                                    L1 = L2'
                                                        L1 accepts all the strings rejected by L2 and rejects all in L2.
                                                    Just take the same DFA and switch the accepting states with non-accepting state.
                                                    Start state (everything) remains same.
                                                    //also logical, pattern
                                                    Eg- Doesn't contain a- its complement is contains a.
                                                    Eg- starts and ends with same symbols
                                                        a start and a end OR b start b end.
                                                        This diagram is just COMPLEMENT of former.
                                                    Eg- set of even length strings- odd length strings
                                                    Eg- Starting with a, [starting with b vs] not starting with a
                                                    Eg- Language with strings containing ba is complement of 1 not containing ba.
                                            Others
                                                Concatenation- L1.L2
                                                    L1.L2 = {w1.w2| FORALL w1 BELONGS L1 and w2 BELONGS L2}
                                                    make a transition (on EPSILON) from final state of DFA for L1 to DFA for L2 (or merge them)
                                                    Eg- starts with a and ends with b (L1 and L2)
                                                    Eg- any problem of type- starting with and ending with strings.
                                                    Eg- 1st part has even 1's and then containing 101.
                                                        This machine and all final states to e-move to start state of 2nd machine- guess when to use that.
                                                        It is closed.
                                                Reversal- w made wR. Eg- abbb becomes bbba.
                                                    Eg- Every 1 has at least 2 zeros following immediately.
                                                        Reverse- precedes.
                                                    Keep all the states. 
                                                    Make initial state final and final state initial
                                                    Reverse all edges of the original DFA (it's NFA likely). Dead States need to be removed cuz they unreachable.
                                                    OR
                                                    Double reversal gets you minimal FSM- You lose dead states and non-identical things.
                                                    Eg- 
                                                    L1 contains languages starting with a.
                                                    L1R will be reverse every string in L1.
                                                    Eg- Strings of Length 2, reversed- 

                                    Closure ideas- give a repertoire of tools to decide if a set can be accepted by FSM or not.
                                            way to complement, way to add 2 probs together- union.
                                            No that aren't divisible by 4. Do we start from scratch- Just toggle final and non-final states.
                                            Other later.
                                    Eg- Contain 110110 somewhere in it. String searching tools making.
                                            Many good and bad ways to do it. a whole discipline.
                                            states of progress of how much we have seen. Anything else, we come back to appropriate state- use your head- not original state.
                                            How much of pattern overlaps with the right side stuff of contain.
                                            Keep this in mind, when we give it an extra arm, extra power (Non-determinism) write easier machine- in a flash we will write it.
                                                    need to prove it not intuition.
                                            Doesn't contain- reverse the arrows- it will be right- 
                                    Eg- Every 1 is followed by at least 2 zeros.
                                            Imagine you are a machine how will you do it.
                                            minimize the machine- back to the same state as does exactly the same thing.
                                    Eg- String not divisible by 3.
                                            We considered next few number in our primary school as we go along.
                                            Consider the first alphabet- what's remainder- how does remainder change with every coming alphabet- if 0 at last- final state-it is.
                                            Remainder is doubled as shifted to left and one more guy added. FSA acc.
                                    There may be strings in which you need to remember.
                                            no of 0s followed by equal no of 1s.0n1n.
                                            Equal no of 0s and 1s.
                                            But prove it! That proof technique is diagonalization.
                                            This proof will be constructive. Lot of logic.
                                    <Minimization>
                                        Minimizing the states in DFA- what properties
                                            There is no minimum for NFA but unique minimum for DFA.
                                            Equivalence
                                                (p,q) are equivalent if word w takes state p to Final then q also to Final and vv.
                                                    equidistant from final.
                                                and inverse- if w doesn't take p to non-final state, so will q.
                                            n-equivalence
                                                If for |w| = 0, 2 states hold- then they are 0-equivalent.
                                                for 1, 1-equivalent and so on.
                                            Steps
                                                Remove unreachable states from DFA (Depth First Search Algo)
                                                Make transition table.
                                                Find 0-equivalent states- 
                                                    2 sets- final and non-final
                                                Pick a state from a current set and compare it others within the set for equivalence
                                                    if they transition into same sets (maybe other set in current)- then they are equivalent.
                                                    if it is equivalent to none, make a separate equivalent class.
                                                        Place them in one of the obtained sets (for next iteration), partition from current set.
                                                    1-equivalent states- choose 2 from a set and check if they hold equivalence property (on an input, they transition into same sets( as obtained in previous step))
                                                        intelligent choosing- once an equivalence is found- don't repeat with other members of equivalence.
                                                        we will have a set of 1-equivalent states (being transitive)
                                                        on reading any 1 alphabet, 1-equivalent states will either reach final state or keep it to themselves or transition into other equivalence class.
                                                        we know for sure that sets so formed are not equivalent but there's a possibility of equivalence is 1-equivalence.
                                                    Find 2-equivalent and so on.
                                                    Continue until next iteration is same as previous (cuz it will not change unto infinity)
                                                Refer to transition table and make DFA for merged states (set of equivalent states)
                                                    for every equivalent set of states- find their transition to other equivalent set of states.
                                    </Minimization>
                                </DFA>
                                <NFA>
                                    On reading a string, you may (not will) end up in one of many states or nothing.
                                        No real machine in NFA. Backtracking helps.
                                        Any game- my move determines goal.vs Many moves at same time- some of them will win and some lose.
                                    Quituple- (Q,SIGMA,DELTA,q0,F) 
                                        DELTA is defined as may move (transition to) Q X SIGMA X Q (Or Q X SIGMA -> 2^Q)
                                        There is always 1 final state possible in NFA- thru E-transition.
                                        limiting final states to 1-restricts
                                NFA- gives more expressive power (conversion to DFA) but not computive power.
                                        every DFA is an NFA (by defn)
                                    DFA was hopping 1 state to another until alphabets are exhausted.
                                    vs NFA has 2 choice- to stay or to go ahead. what we get is a tree- of all choice that we could have taken- if any leaf is accepting state- we have Yes.
                                        NFA to DFA will tell me what all states I can end up in after reading a string.
                                    Eg- contains 110110- make diagram immediately.
                                    Construction- just think of favorable strings- forget unfavorable ones and keep no restriction on reusing symbols from states.
                                    Accepting criteria- If 1 out of many choices of transitions takes takes me to destination- I accept the string.
                                        1 good choice. Ignore all bad choices.
                                        Not defined takes you to empty state (PHI)
                                        Proof we can convert any NFA to DFA. It lies in considering all states reachable for input string at once.
                                            after string is exhausted if one of state is the final state I have a Yes.
                                            It's like guess work- some guess will be right.    
                                    How much large can the equivalent DFA get- 
                                        for 3 states- there may be 2^3 sets to get. 
                                        Superset.
                                        In general the payoff, from NFA to DFA is exponential. No worries if constant.
                                        exponential blow of states- does it make it exponential algorithm?
                                    Proof- I will eat up all alphabets b4 it by staying in initial state and in final state.
                                            Ok, the right string will reach there but also, that wrong string will not reach there.
                                            No way for you to sneak to final state without traversing thru that sequence.
                                        Doesn't need to have arrow for every input- may take to dead state and keep it there for all symbols.
                                    Draw the skeleton straight away.
                                    Eg- any string with 0s in the end of it. This machine works- accepts YES and doesn't accept NO.
                                            You go to dead state on 1 and then 00. It turns out situation that it was bad guess. If many guesses don't work, does'nt mean next won't
                                            No response is like instruction is not listened.
                                    Eg- Strings ending with a- just make skeleton for specification and refine later- state 0 accpets eth and transit on a to final state.
                                        Here on seeing a from state 0 I can go to state 0 or state 1.
                                    Eg- Starts with a. make a transition on a to final state. but didn't tell what happens on b.
                                        on b, no move so dead configuration (dead states are for all unspecified transitions)
                                    Eg- ends with a. or contains a.
                                    Eg- starts with ab; contains ab; ends with ab.                                        
                                    <Complement>
                                        Not true as in DFA- switching accepting and non-accepting states.
                                        Complementing Language vs Complementing NFA
                                            NFA complement- make final states non-final and vv.
                                            Take the language and subtract from SIGMA*.
                                        Eg- words starting with a- L' will be words not starting by a but NFA(L)' means- EPSILON.
                                            Complementing NFA doesn't complement its language.
                                        Q- what is the language accepted by complement of NFA? What is complement of language accepted by NFA?
                                    </Complement>
                                </NFA>
                                <NFAWithEpsilonTransition>
                                    Epsilon means empty string.
                                    NFA or DFA that support transitions on reading nothing (or empty string)
                                    Here, DELTA: Q X {SIGMA U EPSILON} -> 2^Q.
                                    Epsilon-Closure(A)- all states reachable from A on reading EPSILON (or nothing)
                                        itself and check other epsilon transitions (transitive also)
                                    Eg- construct FSM for a*b*c*- state for a*, for b* and for c*- epsilon moves midst them.
                                </NFAWithEpsilonTransition>
                                <Equivalence>
                                    <Conversion2DFA>
                                        Inter convertible => Equally powerful!
                                        Every DFA is an NFA.
                                        NFA to DFA
                                            Using subset Construction
                                                Make the NFA transition table first- no transition, take to PHI (dead state)
                                                    what a state does on seeing a symbol.
                                                Construct DFA transition table
                                                    use start state[s]- see what all states are reachable on input symbol (take for all)- call it state combination.
                                                    take an unexplored state combination (in table data) in transition table 
                                                        check what all states could they lead into 
                                                            1 by 1 consider all states of combination and check state combination it leads to, for all inputs (refer to NFA table)
                                                            union them (reachable) the state combinations together and fill the table data.
                                                    goto Step 3 until finish.
                                                All state combinations are the states and use the table to constuct DFA 
                                                    (not minimum, can cause exponential blow up)
                                                    All states containg NFA's final state are final states of DFA
                                            Eg- start with a
                                                state on a moves to final state and stays there (NFA- cuz on b is not told)
                                                Here, adding a dead state was the only missing link.
                                            Eg- end with a.
                                                state A stays on all inputs and on seeing a, goes to final state B.
                                                NFA- A on a has more moves and B doesn't know what to do on a,b.
                                                Make transition table.
                                            Eg- second symbol from RHS is a.
                                                Regular Expression- SIGMA*a(a+b)
                                                A keeps to itself; but seeing a goes to second last state and another symbol takes to final state.
                                            Eg- third symbol from RHS is a.
                                                Direct DFA is difficult (involving)
                                                for n states of NFA we can go up to 2^n states in DFA.
                                            Eg- Strings of length 2,>=2,<=2.
                                                forget deadstate, that's it.
                                    </Conversion2DFA> 
                                    <nfaAndEpsilonNfa>
                                        every nfa is epsilon NFA (cuz missing EPSILON) is permitted in Epsilon-NFA.
                                        Epsilon-NFA to NFA
                                            Write down EPSILON-CLOSURE of all states (helpful later on)
                                            Construct Transition Table for NFA.
                                            for every transition, calculate EPSILON-CLOSURE(DELTA(EPSILON-CLOSURE(State),INPUT)), write that in corresponding table data entry.
                                                DELTA can spit PHI (no state)
                                                Take union of all of those.
                                            Draw State Transition Diagram back (the NFA)
                                            Eg- for a*b*c* convert from Epsilon-NFA to NFA.
                                    </nfaAndEpsilonNfa>
                                </Equivalence>
                            </FAwithoutOutput>
                            <Limitation>
                                {a^nb^n| n>=1}
                                    PS- if n is finite, then FSM can be constructed.
                                    Don't mistake it with a*b* (the counting has to be exactly same)- this will accept more than a^nb^n.
                                        this violates rule of acceptance of language. It even accepts aab.
                                    in other words, the language will have any number of a's and b's (should be same)
                                        introducing memory to FSM is the solution
                                        Let's introduce workspace for memory in the form of stack.
                            </Limitation>
                        </AcceptorFSM>
                        <EquivalenceRE_FSM>
                        <RegularExpression2FSM>
                            PHI- only 1 state (start state) keeps to itself (isn't final)
                            EPSILON or e- only 1 state (start and final)
                            a- start state transits to final on a.
                            a+b- transits to final state on a,b.
                            a.b- transits on a followed by b (interim state)
                            a*- many epsilon transitions refer to diagram.
                            ab*- a takes to final state and loop on b in final state.
                            (ab)*- means loop on ab Or loop thru a state (transition edges a and b)
                            (ab+ba)*- loop on ab+ba- create 2 parallel paths for ab and ba. create new state for concat.
                                State Creation Method.
                        </RegularExpression2FSM>
                        <FSM2RE>
                            RDSLemma- write equations and substitution.
                            State Elimination Method
                                Initial State should not have an incoming edge.
                                    if there, create a new initial state.
                                There be 1 Final state which should not have an outgoing edge.
                                    Merge multiple final states into 1 final thru e-move.
                                    create new final state on e-move.
                                    make earlier final state as non-final.
                                Other than initial and final state- eliminate all states 1 by 1,
                                    replace by the edge to capture the essence (all paths should remain intact- effect should be alive still)
                                    self loop becomes- Kleene Closure.
                                    for every incoming edge and outgoing edge combination, write down the apt regex.
                                Eg- a,b,c parallel to final state- (a+b+c) regex.
                                Eg- sequence becomes a.b, ab*c, 0(10*),a(b+c+d), b(c+ab)*d, (10*1+0)* (accepts even no of 1's), regex of DIVISIBLE BY 3- (10*10*1+0)*
                        </FSM2RE>
                        </EquivalenceRE_FSM>
                        <ComputationProblems>
                            <WithOutput> Helps in computation (vs decision)
                                6-tuple (Q,SIGMA,DELTA,q0,CapDelta,LAMBDA)   //output alphabet, output function
                                They are deterministic.
                                Moore Machine- 
                                    Output associated with every state. When in a state- an output gets spitted.
                                    how to remember- 2 oo- output for every state. n+1 outputs for n input.
                                    Write down the execution trace and for all states, write their outputs.
                                    State Transition Table- For Q X SIGMA, write Outputs for every row q BELONGS Q.
                                    Eg- count number of baa- construct a DFA which ends with the string.
                                    Eg- produces 'A' as output if i/p ends with 10, 'B' on 11 else 'C'
                                        make DFA skeleton. associate output A and B with appropriate "Final" states- others as C.
                                    Eg- spits remainder of binary number modulo 3. make DFA of 3 divisibility and associate remainders as outputs.
                                    Eg- spits remainder modulo 5 for number of base 4. Use the trick of transition table construction.
                                        write output function also for them.
                                Mealy Machine                                
                                    Output associated with transition. When a transition happens, an output is spitted.
                                    n bit input spits n bits output.
                                    write down the execution trace and for all transitions, write their outputs.
                                    State Transition Table- write outputs in the table data (along with states)
                                    Eg- that produces 1's complement of a binary number.
                                        1 state- on seeing 1 output 0, seeing 0 output 1.
                                    Eg- produce 2's complement- add 1 to 1's complement
                                        from lsb to msb traverse until you find a 1, complement all bits following that.
                                        2 state machine- 1 waiting for 1st 1 and other for complementing.
                                    Eg- Sum of present and previous bit.
                                        3 states- last seen is 0,01,11 (redundant- last seen is 0,1 will do?)
                                            spit output as per input on transition.
                                <Equivalence>
                                    which is more powerful- that 1 machine is more powerful than other.
                                        Both! Proof? 1 is convertible to the other.
                                        Moore to Mealy
                                            Eg- Number of a's mod 3.
                                            For every transition, associate the output which one gets from the head node state's.
                                                1st output of being in initial state will be forgotten by this.
                                            In transition table, check the next state in table data and associate its output function's value.
                                                Eg- verify over a string containing counting numbers of ab.
                                        Mealy to Moore
                                            Move output from every transition to its incident (head node) state
                                            There may be clashes- some states may conflict on the output they should spit for different transitions incidented.
                                                Create a new state for each output, unlike Moore to Mealy.
                                            If a mealy machine has n inputs and m outputs, corresponding moore may have m*n states (cross product)
                                                complete the state transition diagram for all states- consulting with original mealy.
                                            Ravula- for every state, drag its output from transition to next state
                                                if the state doesn't exist already, create a new one.
                                            Eg- convert 2's complementing mealy machine (lsb to msb) to moore.
                                                ignore 1st bit in moore.
                                </Equivalence>
                            </WithOutput>
                        </ComputationProblems>
                        <Grammar>
                            Type 0/3-
                        </Grammar>
                        DFA can be expressed as Regular expression- 3 different windows to same picture.
                            more views more tools- certain prob gets easier in certain situation.
                            Regular Grammar also equals to FSM. 4 are all the same.
                    </RegularLanguage>
                    <CFL>
                        Used for PL.
                        Eg- 0n1n- you also include what you were not supposed to include.
                    <PDA>
                        FA + Memory (stack) (Q,SIGMA,DELTA,q0,Z0,F,TAO)
                            DELTA- Q X SIGMA X TAO -> Q X TAO*
                                reading an input string and stack symbol, State moves from 1 to the other, while writing few symbols on stack.
                                (a,a/ba) means reading a on tape, a on stack; push a and b on stack- b on top.
                            F- Set of final states- PDA can also accept by empty stack (in non final state)
                            Z0- Bottom stack marker.
                            TAO- Stack Symbols (on reading it, you take it out)
                            To keep memory-
                                1 stack
                                give it array- turing machine. 
                                2 stacks- turing machine. 
                        Types
                            Deterministic
                                DELTA- Q X {SIGMA U e} X TAO -> Q X TAO*
                            Non-deterministic- 
                                DELTA- Q X {SIGMA U e} X TAO -> 2^(Q X TAO*)
                        Transition Representations
                            Transition Funtion
                            Transition Table- use pivoting.
                            State Transition Diagram
                                Transitions labelled by (input,readStackSymbol/WrittenStackSymbols)

                        Regular sets- can pump To keep memory-
                            1 stack
                            give it array- turing machine. 
                            2 stacks- turing machine. it up at regular intervals to get other things in the set.
                            Not following pattern (growing faster than linear) is not regular.
                            I came up with 24 states- express 0 24 1 24- it will surely have a loop somewhere- repeat the loop and that also I get.
                            getting more than I want.
                        Execution Trace- consists of sequence of configurations (or instantaneous descriptions) of machine- (currentState, RemainingString, Stack)
                        Eg- a^n.b^n- keep reading pushing on stack on reading a's. Start popping on b's.
                            If stack becomes empty after string is over, string is accepted.
                            If unexpected alphabet appears, reject the string, Dead State.
                                after 1st transition, the topmost stack element Z0 is removed.
                                    You can keep it by pushing it back.
                                on reading a with a on stack, in state q0, we add 2 a's to stack (to retain previous 1)
                                on reading b, with a on stack, pop it (meaning do nth); also change the state 
                                    why? so that after seeing a b, I should not see an 'a' again.
                                    keep popping b in that state. (think how mind works)
                                on reading e with Z0 on stack, transition into final state, pushing Z0 back.
                                OR on reading e with Z0 on top, keep to itself (non-final); empty stack accepts it.
                        Eg- No of a's in w = No of b's in w (in any order they come)
                            counting is reqd (the difference will fluctuate on either side but will be zero for acceptance)
                            so from Z0 if see a symbol, push on stack and pop on other symbol; for different symbol (change push/pop)
                                if input symbol same as one on stack, push it.
                                if you see input different from stack symbol, then pop it.
                        Eg- a^n.b^n.c^m|n,m>=1
                            Keep pushing on a, pop on seeing b (move to different state), on seeing c move to different state.
                                we move to different state to make sure all b's follow a's (no interleaving)
                            move to different state, which keeps to itself and does nth to stack.
                        Eg- a^n.b^m.c^n|m,n>=1
                            (a,Z0/aZ0),(a,a/aa),(b,a/a) go to next state, (b,a/a)(leaving a's alone),(c,a/e),(e,Z0,Z0)to final state.
                        Eg- a^(m+n).b^m.c^n
                            (a,Z0/aZ0),(a,a/aa),(b,a/a) go to next state, (b,a/e),(c,a/e) transit to next, (c,a/e),(e,z0/z0)
                        Eg- a^n.b^m+n,c^m
                            (a,Z0/aZ0),(a,a/aa),(b,a/a) go to next state, (b,a/e) until empty stack, so (b,Z0/b) no need to transit to next state, (b,b/bb),(c,b/e) transit next, (c,b/e), (e,z0/z0)
                        Eg- a^n.b^m.c^(n+m)
                            (a,Z0/aZ0),(a,a/aa),(b,a/ba) no need for next state cuz b on top,(b,b/bb),(c,b/e) transit to next,(c,b/e),(c,a/e),(e,Z0/Z0) to final
                        Eg- a^n.b^n.c^m.d^m
                        Eg- a^n.b^m.c^m.d^n
                            push a's, push b's keep popping b's on seeing c and pop a's on seeing d.
                        Eg- a^n.b^m.c^n.d^m. Stack doesn't allow to look below top so not possible.
                        Eg- a^n.b^2n
                            for every a, push 2 a's and seeing b, pop an a off (in different state)
                            OR temporary state before even b's to pop a.
                                1st b does nth, 2nd does popping and transit to a state, 3rd no popping and bring back, 4th pops and so on. Final transition (e,Z0/Z0) from final state.
                        Eg- a^n.b^(2n+1)
                            eth same as b4, final transition on (b,z0/z0)
                            or don't do anything for first b and then start working on stack on seeing b.
                        Eg- a^n.b^n.c^n|n>=1 not possible.
                            you may think push 2 a's and pop on b and c but it will also accept aabbbc.
                        Eg- wcwR|w BELONGS (a,b)+
                            when to stop to push and start popping- on seeing c.
                            keeping push a and b until c and popping on seeing anything.
                        Eg- wwR- even length palindromes
                            this time we don't know the center- don't know when to stop pushing and start popping.
                            at center we want to stop but during parsing we don't know the center.
                            at center, both symbols will be same (there's a chance)- so non-deterministically we will transition on seeing same symbols.
                                one of our guess will be right if it indeed is palindrome.
                                (a,Z0/aZ0),(b,z0,bz0),(a,b/ab),(b,a/ba),(a,a/e) transit if center or (a,a/aa) if not center, (b,b/bb) or (b,b/e), matching on another state- (b,b/e),(a,a/e)
                                Execution Trace (tree)- (qs,aaaa,z0),(qs,aaa,az0),(qs,aa,aaz0) or (q1,aa,z0) (dies), (qs,a,aaaz0) or (q1,a,az0), 2 path- (qs,e,aaaaz0) amd (q1,e,aaz0) for 1st case- both die; (q1,e,z0) for 2nd case-> (qf,e,z0) so got it.
                            Non-determinism goes to more than 1 states on seeing input and stack symbol.
                            It is more powerful than deterministic PDA cuz this was not possible for it.
                        Eg- {a^n.b^n|n>=1} U {a^n.b^2n|n>=1}- for a string I don't know which of the 2 categories it will fall under. so non-determinism will solve it for us.
                            push all a's on stack and seeing b keep popping and accept if empty stack
                            OR push 2a's and pop 1 b.
                            Let's keep an initial state qs which on seeing a pushes 1 a or 2 a and transits to 1 of 2 states aptly.
                            See execution trace in notes.
                                aabb- assumption that it was a^n.b^n is true and a^n.b^2n is not.
                                2 copies and 1 succeeds- if 1 reaches destination string is in language.
                        Eg- {a^i.b^j.c^k.d^l|i=k or j=l}
                            since they are connected by OR, we can non-deterministically try for a^i.b^j.c^k.d^l- use stack to match i and k (ignoring other symbols); other option use stack to match j and l. 
                            if one of them succeeds, string is in language.
                            AND can't be done.
                        Eg- {a^n.b^m|n>m}- last move be (e,a,anything)
                        Eg- {a^n.b^n^2}- isn't CFL. 2n was possible cuz a loop could use a stack.
                            or b^2^n isn't
                            ww- isn't
                            a^n.b^n.c^m|n>m- nothing to compare so not CFL.
                            a^n.b^n.c^n.d^n|n<10^10- wouldn't have been but since it's bounded it's DFA
                            a^n.b^2n.c^3n- can't compare- not CFL.
                            xcy- for x,y over SIGMA*- it's DFA- containing c in it. Hence, it is CFL also.
                            xxR- for x over SIGMA and |x|=10, it is DFA.hence eth
                            wwwR over SIGMA- not CFL.
                            a^m.b^n|m!=n- non-determinism for m>n or m < n
                            a^(2n+1).b^n- Deterministic CFL.
                            a^i.b^j|i!=2j+1- DCFL.
                            a^n^2- not CFL.
                                2^n,n!,m is prime,n^n
                            a^i.b^j.c^k|i>j>k- memory can't do it.
                            a^i.b^j.c^k.d^l|i,j,k,l>=1 is RL
                            a^n.b^4n- DCFL.
                            a^3,a^8,a^13,..- since in AP-it's RL.
                            a^2n+1 for n>=1- RL
                            w|w over SIGMA, |w|>=100, it's complement of |w|<100 so RL.
                            w|w over SIGMA-a,b,c s.t number of a=that of b= that of c- Not CFL.
                            w|w over SIGMA-a,b,c s.t number of a>= number of b + 1- DCFL.
                    </PDA>
                    <CFG>
                        Grammar- next layer- from hardware model to closer to PL.
                            This is generative- the production rules or a symbol state can spit out/generate the string from rules and given a string account for it
                            Keep making substitutions- A generate 1 and moves to state B for it to generate things.
                            We should get rid of capital letters to generate a string.
                        Context Free Grammar- vs linear grammar- Grammar are NFS by Nature.
                            NFA fits well with grammar model.
                    </CFG>
                    </CFL>
                    <CSL>
                        Eg- {a^nb^nc^n|n>=1}
                        <Acceptor>
                            LBA- Linear Bounded Automata- is the machine to accept CSL.
                        </Acceptor>
                        <Generator>
                            CSG- Context Sensitive Grammar.
                        </Generator>
                    </CSL>
                    <Recursive> TM can accept and reject (halting guarranteed)
                        Eg- {a^nb^nc^n|n>=0}
                    <TuringMachine>
                        Turing machine- that can be computed- with computer, normal PL.
                                hierarchy of complexity theory takes place here.
                                        within it there may be P and NP probs.
                            Undecidable- No program/algorithm anywhere that can figure out the answer.
                                    NP on outside.
                            These all describes machine with different amounts of power.
                                    describe a language/strings by machine, grammar, expression.
                            Allen Turing in 1936- Mathematician. CS Scientist.
                        Motivation- to capture the notion of computability
                                can all computation problem be solved? If not today, then 2mro- thru diff kinds of computers.
                                Even before PC Turing gave a model. Prove that PC can do what a TM can do and inverse.
                                        It's a big claim- if there exists an algo to solve a problem- TM can do it.
                                                can't prove- algo is an intuitive notion and no formal defn- TM captures this intuitive notion formally.
                                                TM definable with great clarity but not algo. So, it's a thesis.
                                        Church Turing Thesis- what can be done algorithmically can be done by TM and vv.
                                                Turing (TM) in UK, Church (Lambda Calculus) and  Post (Rewriting System) in USA, Godal (General Recursive Functions) in Germany and Markov (Markov Processes) in USSR- all looked different but solved same class of problems.
                                                        adds to faith that thesis must be correct.
                                                        All attempts to counter eg- have failed.
                        <TMModel> #TM is model of how mind works- standardize the solution for all instances of a problem. Think about state changes you undergo while checking if a written here is equal to b.
                            M = (Q,SIGMA,Gamma, Delta, q0,blank,F)
                                Gamma- Tape- Jagged lines => continues to infinity. Cells have symbol. 
                                Finite Control reads a cell at a time while in a state say q.
                                Blank is a special input symbol which means nothing is written in the cell = empty slate/notebook
                                Q: State- FC is in some state.
                                        Control can read and write sth on tape and moves head to left/right.
                                        Every state specializes in a purpose- what to do on seeing a symbol based on their purpose.
                                Delta: Transition
                                        (q,a)-> (p,b,R) means in state q if read symbol is a, write back b and go to state p and move R one step.
                                                Dynamic behavior captured thru this quintuple that the TM has. 
                                                The set of quintuples is finite- alphabet is finite, also are states; determinism=> Less than |Q| X |SIGMA|
                                                        if there is no quintupse with state p and scans b- nothing defined- machine halts.
                                                #Sth like we are automating or generalizing moves but putting them in categories, abstracting out.
                                                        given any situation (all situations captured), this is what TM is supposed to do.
                                                        so solve all instances of a problem by telling set of steps that solve it.
                                q0 initial state and scanning leftmost symbol of input. How is it finite? not used part of tape is blank.
                                        Like a copy book- you start solving- remaining part of copy book is vacant.
                                Acceptance defn- stop as soon as machine enters into final state. Definite event.
                                Rejection- such a state will never arise- 2 ways it happens-
                                    1. TM enters a non-accepting halting state.
                                    2. TM invokes a non-terminating computation (infinite loop)- no way to tell if it will ever stop. (not definnite)
                                Eg- 1^n if n is even and > 0. In this case acceptance and rejection is definite for former diagram.
                                    Latter one also gives but is indefinite.
                                    Refer to Diagram.
                                Eg- so as to convince you that it can solve all problems more than PDA- a^nb^nc^n for n>=0
                                        aaaaabbbbbccccc
                                                sees an a- search corresponding b and corresponding c- marks a cross, tick when found first b and $ for c.
                                                bring head back to first a. checkoff next b and next c with respective symbols.
                                                Current state,sees symbol, Next state, write symbol and move
                                                q0,a,q1,blank,R- if see a tick, go right, see a c reject and halt. Blank? accept and halt.
                                                q1,a,q1,a,R- q1 state is master in hunting for next b to the right. Mark tick when found
                                                q1,b,q2,tick,R- if it sees a c or dollar- then #b < #a. Reject and halt.
                                                q2,b,q2,b,R- q2 state is specialized in hunting for next c after streak of b.
                                                    q2 on seeing blank, goes to reject state, halt cuz #a > #c.
                                                q2,c,q3,$,L- q3 intends to come left to see 1st a. (left moving state)
                                                q3,$/a/b/tick,q3,$/a/b/tick,L
                                                q3,X,q0,X,R
                                                Ultimately no separate a,b and c found then end it.
                                                    Many cases arise to be considered- for a, not able to find b, #a> #b,#a> #c,#a=#b<#c Block of a's are over- seeing a b- halt.
                                                    This TM has solved which no previous machine could identify. More powerful.
                                Formal Defn- Q- finite set of states, tape alphabet, input, blank, transition fn, start state.
                                    all are finite so TM is finite in description.
                                    Accept and reject states to halt.
                                    algorithm is finite text so should be TM.
                            <GraphicalRepresentation>
                                Description of TM thru a graph
                                        refer to diagrams. Qs become nodes with Direction(optional) and transitions labelled by readSymbol/writeSymbol:Direction. Accepting/Reject state
                                        Our diagram for turing machine is general enough.
                                        similar to FSM otherwise.
                                        Avoid messing things- self loops which don't change symbol, then omit it.
                                            for direction associated with states diagram.
                                            remove circle for halting (it is not moving states)
                                    thru a table, transition fn.
                            </GraphicalRepresentation>
                            <ExecutionTrace>
                                What configuration the TM was in (define configuration)
                                    blanks flannking b/s. Underline the letter where our head of TM is. and the state b4- eg- (q1, aa'abbbccc)
                                    Configuration is snapshot at any time to state of affairs to take TM from- tape contents, state of TM, position of RW head.
                                        machine in state q going to read b written as abaqbad- note the q.
                                        so start config for string x will be q0x.
                                        eg- q0aby -> bpby for Transition q0,a-> p,b,R.
                                        C1|-C2 if single step takes TM from config C1 to C2.
                                        C1 |-* C2 in 1 or more steps ( relation only; transitive closure of former).
                                        accepted if q0x |-* alpha p beta where p is final state.
                                            ? called Recusive languages(? or re)
                            </ExecutionTrace>
                            <ConstructionTechniques>
                                Techniques for construction
                                Storage in finite control- as state- as a tuple.
                                        Eg- ab^n V ba^n. [q,a] then look for only b.
                                        Eg- wcw- w BELONGS {a,b}- while moving remember the state as [q,a] to be able to match it.
                                multitrack TM- 1 head- inputs are read and written as a tuple.
                                Shifting of symbols- if a string can be generated by a grammar- use multitrack.
                                        Shift tape 2 cells to the right. I don't know the length- take state as a tuple which remembers current alphabet and previous alphabet.
                                        write the state tuple part for writing on tape.
                                Checking off symbols- wcw accepting
                                        check off symbols to keep track of what you need to remember.
                                Subroutines- 1 TM calling another.
                                        Given unary- multiply them.
                                        check off numbers on left and copy them to other side of tape.
                                        Main TM T calls T1. States are disjoint- the delta mapping in T takes me to q0 of T1.
                                Eg- Subtraction proper- 0^m10^n- 0^m-n or blank
                                        change first into blank, go hunt for 0 on rhs- make it 1. and come back to first 0 until- no zero on other side.
                                        change into blank if lhs 0 are exhausted.
                            </ConstructionTechniques>
                            <Capabilities>
                                Effective procedure can be realized by a TM
                                Infinite tape with cells with finite non-blank portion called input
                                    Effective procedure is a program- procedure vs algorithm
                                            algorithm always halts (Recursive) but procedure (RE) doesn't necessarily.
                                            Is a number prime? Is n a perfect number?
                                    TM is sequential access but current computer with RAM and registers are random access
                                            simulate 1 with other- one in T other in T^2, etc.
                                Any New Model- show that it has capability of TM.
                                    A polynomial equation in 1 variable- tell if roots are integers- ppl could not write.
                                            Turing breakthrough- You cannot write an algorithm for it- this is a strong statement- have to prove it.
                                    Given a grammar is it CFG- undecidable.
                                    Allen Turing- in south India studied and award in his name.
                                <InputOutputComputations>

                                    if number of 0 is odd or even- we had FSM for it.
                                            same config, just unconditionally move right.
                                    Parity checker- FSM can do it.
                                    Well formed parantheses- PDA did it.
                                            on seeing right paranthesis, go back and strike off first left panathesis.
                                            q0 to q1- q1 is left moving state. ignores X along way both states.
                                            if q1 sees A- then halt with rejection.
                                            q0 sees blank or A- convert to q2 right moving state until sees A- then accept if seeing left paranthesis, then reject.

                                    unary to binary converter
                                            BAAB for 11...(9 times)
                                            divide by 2 technique-
                                            skip alternative 1s and see which state you reach blank, go back thru different state q3, write in front.
                                            why not rub off every second 1 also- cuz we want to remember quotient for next iteration.
                                                    changing state to q0 is like a for loop. 
                                            2 states- strike off 1 and update binary over again.
                                                    but takes hell lot of time.
                                    binary to unary
                                </InputOutputComputations>
                                <Acceptor>
                                    how to accept a language and not as i/o device as seen b4.
                                    Instantaneous description (ID) aka configuration
                                    x1x2qx3x4 means q is in state x2.
                                    from x1 you can't move left.
                                    q0w is begining configuration.
                                    L(M) if sh reach qf in any config.
                                    accept a^nb^n- change state on seeing a, to hunt for first b and left moving state to go back first X and repeat.
                                            consider case when extra a or extra b.
                                    Computation of function- 
                                            adding unary- append.
                                            not concerned with steps involved but just doing it.
                                            Turing computation functions.
                                            Any program can be written as TM.
                                </Acceptor>
                                <Generator>
                                    UG- for generating grammar- Unrestricted Grammars.
                                    output tape strings are printed within hash marks.
                                            print on the output tape
                                            move to the right
                                            written once is never erased.
                                            Betw # symbols- is generated string Denotee by G(M) = {w|w is generated by M}
                                                    in any order not necessarily in standard/lexicographic order
                                                    string can be generated more than once
                                                    if in lexicographic order, then recursive set (halts on all inputs)
                                    L = T(M1) iff L = G(M2) - if a TM can accept a language- another TM can generate it and vv.
                                            Proof- 
                                            generate => accept
                                                    M1 simulates M2. 
                                                    When # appears, check output tape if that matches with input halt else go further.
                                            Accept => Generate- 
                                                    suppose TM halts on all inputs (recursive), 
                                                            a will be generated first, M2 simulates M1. If a is accepted then write on output tape. Then next a and repeat.
                                                            as soon as w is generated by M2- M1 accepts it.
                                                    doesn't halt
                                                            can't emulate M1 infinitely.
                                                            M2 has a tape where pair of integers (i,j) are generated.
                                                                    how to generate 1 by 1 (countable so possible)- count diagonally one by one.
                                                                            so any string can be given a number. eg- for SIGMA = {a,b,c}- ac is 7th number.
                                                                    when (i,j) is generated, generate wi in enumberation and simulate M1 for j steps, if it accepts on jth step include it on output tape.
                                                                            if it doesn't, go to next (i,j). If a wi is to be get accepted, at some stage, (for some j in the (i,j) enumeration) it will be.
                                                                            that's why the name recursively enumerable comes- strings can be generated in some order.
                                                                            Here, 1 string will be generated only once.
                                </Generator>
                            </Capabilities>
                            <Eg> Convert Unary to Binary representation.
                                    how do we do that otherwise. Express logic in TM. Dividing by 2 and noting the remainders.
                                        use B,A (1,0) to avoid confusion with 0 and 1.
                                        cross 1st 1 and ignore 2nd and so forth- odd if last doesn't come after 1.
                                        for next iteration, follow same procedure, ignoring X. They pair up and inform odd or even.
                                            keep noting the remainder to the left most.
                                        Draw a diagram for ideas using a sample string.
                                Our focus in course is to focus on recognizing language and not computing functions,.
                            </Eg>
                        </TMModel>
                        <Variations>
                            We gain no advantage in computation power thru facilities on TM.
                            If we change a model a little bit- our RE set may grow (recurively enurmerable)
                                it doesn't make a difference. 
                                Robustness of basic TM model thru- 
                            <addExtraCapabilities> And Check if its power grows; meaning that if it can accept more languages; solve more probs.
                                <TwoInfiniteToOne>
                                    Two way infinite = 1 way.
                                    1 way halts if told to move left from 1st symbol. for 2 way, keep a special symbol to demarkate the 1st symbol and halt on reading it.
                                    how 2 to 1 way. give two tracks to 1 way tape.
                                            say to the left lie A-1A-2 etc copy to 2nd track
                                            special symbol as first symbol on 2nd track.
                                            state info thru [q,U], [q,D]- so that we can shuffle left movings to right and vv in D.
                                            number of moves not affected by this simulation.
                                </TwoInfiniteToOne>
                                <MultiTrack>
                                        multi-track tape TM- tuple of all track's symbols is read at a time.
                                            how to specify transition function
                                            q on reading sigma1,2,3,4 goes to state p and writes back sigma 1',2',3',4' and moves to R.
                                            any difference in sigma's make a different symbols. track column combinations- eg- 00, 10, 01 are different symbols for the head.
                                            only changing of symbol and eth same- recognition capabilites not grown. Extended alphabet set.
                                </MultiTrack>        
                                <MultiTape>
                                    polytime multitape TM accepted by polytime TM in single tape.
                                    2 tapes say and 2 RW heads.
                                            on reading a from 1 and b from 2.
                                            Next state/config determined by present state and symbols on combination(tape1,tape2, etc)
                                                Delta(q,a,b,c)->([A,R],[B,L],[C,R])
                                                this guy has separate tape heads. unique transitions for all.
                                                either of tapes can move to either side.
                                                Can a multi-tape TM recognize a language that which no single tape TM can? No!
                                    <Mapping>
                                        for k tapes, make 2k tracks in 1 tape. every odd track has tapes' input, and even track to track of current head location.
                                            convert multi-tape to multi-track- 4 tracks for 2 tape- odd tracks store the contents of tape.
                                            Even (2,4,6) tracks use marker to show the current position of head. Remaining cells blank.
                                            Many steps to simulate 1 step of multi-tape.
                                                make passes left and right and vv. state keeps track of #(head location for tape) found.
                                                    State has many components, (q,2,x,y,-)- keeps track of symbols read by 1st head, 2nd head.
                                                    by moving thru to right- we at a certain state get all the tuple members filled. we precisely know the config of TM.
                                                go back left and change X locationin even tracks. decrement #(head location for tape) to be able to do.
                                                assume we start where- all the X in tracks coincide- then after first pass to-fro- X can be max 2 cells apart. 2nd pass, 4 cells apart, so on. 
                                                    for ith step- 2i apart they will be- so for i steps in multihead- move (2i+2i) + maintainence steps in single = ki (k[4,6])
                                                    for all i steps = SIGMA(ki) = O(n^2)                                            
                                                    2 or 1 to keep track of who is to the left. t(n) steps- in multihead makes every step take 2t(n) time (exponential growth). so t2(n)
                                    </Mapping>
                                </MultiTape>
                                <NTM>
                                    The relationship definition has changed- will go to can go. (for config change)
                                        DELTA(q,a) = {(p1,A1,R),(p2,A2,R),(p3,A3,R)} take either one of them.
                                    Non-deterministic TM- can take more than 1 moves for an input read.                                    
                                        Execution Trace- 
                                            tree of choices- if 1 branch takes to acceptance.
                                                My TM can move to state q1 from p on reading a and write b1 OR go to state q2 and write b2 on reading a.
                                            Configuration Tree- configuration execution trace is linear for deterministic but tree-like for NDTM.
                                                If any one path takes you to accepting configuration. A certain choice of configuration does the job.
                                                Some path may be non-terminating. that's not a prob.
                                        apparently adds power over DTM. Does it? No means convenience; Yes means extra power.
                                    How to simulate? 		      
                                            take max of #(rhs of delta mappings) choices. call r.
                                            standard ordering- 1,2,3,,,10,11,...; lexicographic.
                                            DTM has 3 tapes for 1 NTM- input copy on 1st tape and execution on 2nd tape- seq generated on 3rd.
                                            sequence means path to accepting configuration. 3rd tape contains candidates for such sequences.
                                            number of sequences of length 1 = r,2 = r^2, so on = r + r^2 + ....= r^n-1 (exponential growth)
                                </NTM>
                                Multidimensional tape- 
                                        2-d tape- we can move LRUD. infinite in all directions.
                                        write all rows separated by # (delimiter/separator) symbol.
                                        How to move up? keep a counter on another tape- how many steps b4 delimiter comes.
                                        reach previous # and go right again. same with down.
                                        more moves but not exponential.
                                        Eg- generating a x pattern.
                                multihead TM- 
                                        Delta(q,a,b,c)->([A,R],[B,L],[C,R])
                                        same idea as mulitrack- k+1 tracks for k heads.
                                        1st track contains string to test and markers in all others.
                                        if >1 head in 1 tape- which 1 to go where? Use symbol rewriting.
                                Offline TM-
                                        input in 1 tape but restricted in both ends and read only.
                            </addExtraCapabilities>
                            <RestrictSomeCapabilities>Limited forms of TM but power of TM is not lost (can simulate)
                                <TwoPDTapeTM>
                                    2PD tape TM- 2 tapes behave like stack. can simulate a TM.
                                        2nd tape top always contains the current symbol read by TM.
                                        1st tape - all left to current symbol and 2nd tape- all afer that.
                                </TwoPDTapeTM>
                                <CounterMachines>Counter machines- finite control has a number of counters to store any non-negative integers.
                                    4 counters a TM.
                                        1 PD (PushDown) tape by 2 counters. Using Godal's numbering for strings, graph, stack, etc. (refer to madam notes)
                                            Operations allowed check if a counter contains zero. increment/decrement by 1.
                                                Counter can be seen as a restricted version of stack.
                                                empty stack, push x, pop x.
                                                go to only right (like pda). 
                                            Eg- (q,a,pos,zero,pos) when 3 counters- operation you can go for are inc c1,etc.
                                    3 counters and I can make you 2-stack TM.
                                        each of 2 stacks by a counter. c1 represents stack1 and c2 for stack2.
                                            Think of every symbol as xi in k+1-ary representation= 1 number.
                                            write xi to correspond to k+1-ary representation.bottom most is most significant digit.
                                            when you pop the top symbol- do n div (k+1)
                                            push = n * (k+1) + pushing number.
                                            how to calculate mod.
                                    2 counter machine can simulate 3 counters.
                                        prime number exponents- 2^n13^n25^n3
                                        for c2 is zero, means n2 is zero- check for divisibility by 3. same formula.
                                        for increment of c3, multiply n by 5.
                                </CounterMachines>
                                <TwoInputSymbols>
                                    2 symbols are enough- for n symbols- convert them into some binary representation. so log(n) binary for every one.
                                    read many symbols before transition- so states grow.n to kn.
                                </TwoInputSymbols>
                            </RestrictSomeCapabilities>
                        </Variations>
                        <SimulatesComputers>
                            take a processor- this is not to limit power of TM.
                                    Executes program
                                    memory- data and programs
                                    registers
                                    Contents of PC tells us which instruction is to be executed next. address of instruction basically.
                                            sequence determines by data we know.

                                    Memory- every memory cell address- which has patterns- 
                                            like add M1,M2,M3.
                                            add contents of M1 and M2 and store result in content of M3.

                                    Tape 
                                            for modeling memory
                                                    Special symbol then string and other special symbol and string. (address and content of the address)
                                            work tape 
                                                    work tape has opcode and 3 addresses.
                                            contents to be fetch in a tape (ALU)
                                                    looks for addr1 pattern in memory tape- when match then copy address to content (this) tape.
                                                    depending on opcode machine can go to a part of its...machine can decide to go a part of its program.
                                                            to carry out operation.
                                                            maybe another tape for addition.
                                            PC tape another one
                                                    add 1 to PC means go to next instruction
                                                    so physically go to next instruction.

                            fetch next instruction to work tape.
                        </SimulatesComputers>
                    </TuringMachine>
                    Union of R is R- how? construct a machine M from M1 and M2 s.t on yes from M1 shows, no from M1 is input for M2- return yes, no shows.
                    Complement of R is R- how? construction machine M' from M s.t when M's output is reversed by M'
                    </Recursive>
                    <RE>
                        Language L is recursive if there is TM that
                            accepts L
                            halts on every input (stricter)- re could go in infinite loop.
                        There are non-RE languages
                        Union of RE is RE. How? construct M from M1 and M2 s.t input is given to M1 and M2 simultaneously- if one of them spits yes- say yes.
                        If L and L' are RE then L is R. How? Construct s.t- if M1 spits yes- say yes. If M2 spits yes- say No. And one of them will say yes (being RE)
                        Eg- {a^p|p is a prime}
                        <TMLimitationsInLanguageRecognition>    
                            computation probs have algorithms- Eg- Decision Problems- 2 Outputs- Yes/No.
                                Eg- Membership decision problem.
                                input x over a set A- is x in A- yes/no.
                                        such algo exists iff A is recursive.
                                Decidable
                                        If there is an algorithm that decides the membership decision problem of a set- then that problem is called decidable.
                                        Undecidable means corresponding language would not be recursive.
                                        Existence of a decision algorithm makes the decision problem decidable.
                                given an re language. is it recursive? So that useful algorithms can come.
                                    eg- Primality- is n prime or not. 
                                    are all re languages recursive? Every recursive is recursively enumerable. There is a separation.
                                    Lu is re but not recursive = {(M,w) | M accepts w}. (refer to Others section for Ld before this)
                                        1. Lu is RE
                                            Encode TM, and we can describe an re
                                                Universal Turing machines (UTM) 
                                                    a fixed TM exist which which can simulate other TM  over a string for language recognition.
                                                    on its input tape we have Machine M and word w. and it tells M could have accepted w.
                                                    Lu = L(UTM)
                                                    Can such a machine exist?
                                                        We have encoded our TM in string. (w also in binary for symbols can be different)
                                                        Copy w on 1 tape
                                                        other tape has current state separator current symbol being read (in its simulation of T) separator quintuples of transitions.
                                                        head can scan thru to check for quintuple with current state and input symbol- UTM knows the next state to go to and symbol to write.
                                                            if size of symbol to write is bigger then do shifting.
                                                            We are ready for the next cycle of the TM.
                                                        If the TM gets into final state- the UTM would know and thus can identify the strings of that type.
                                        2. Lu is not R
                                            it's not recursive because if we can solve this we can solve Ld (refer to others)- but we know we can't solve Ld (with proof).
                                                If Lu is Recursive then Ld becomes recursive. Which is contradiction.
                                                If Lu is recursive, it will also spit "No" when TM doesn't accept w.
                                                Let's make a machine- which on input (x,x) says yes or no- for no, we flip and say yes and  for yes, its says No (this is Ld (later))- so Ld will halt 
                                                    but not possible so contradiction.
                        </TMLimitationsInLanguageRecognition>								
                    </RE>
                    <Others>
                        does some TM exist to accept a language over Sigma* that we choose? No!
                            Make M for the L s.t. L(M) is L.
                            Proof is by diagonalization argument. by contradiction.
                            <REL>
                                Eg- there can't be bijection betw real numbers and natural numbers
                                Eg- there can't be a bijection between a set X and its power set P(X).
                                    P(X) = {X1 | X1 < X}
                                    Start by negation of what you wanna prove. 
                                    Assume that there is a bijection betw X and P(X), let it be f:X->P(X)
                                    We define Y <= X.
                                    Y = {x belongs X | x doesn't belong to f(x)}
                                            Y can't be the map of any element of X. 
                                            Witness of this statement will be an element which is in (f(x1)\Y) U (Y\f(x1))
                                    being bijection there is some x' BELONGS X for which f(x') = Y belonging to P(X).
                                    Suppose x' BELONGS Y => x' BELONGS f(x') => x' !BELONGS Y.
                                    Suppose x' !BELONGS Y => x' !BELONGS f(x') => x' BLEONGS Y.
                                            BOTH give contradiction. so f can't exist. So, no bijection.
                            </REL>
                            All possible TMs to accept languages over SIGMA (fixed)- M1,M2,...
                            <TMEncodingAsString>
                                    TM is a tuple (remember).
                                    Quintuples of Delta by - present stae, current symbol scanned, next stae, symbol written and move.
                                            qi,sj,qk,sl,d represent as i,j,k,l,0/1 (L/R)
                                            eg- 5,2,3,2,1 - from state 5 5o state 3 on reading 2 and writing back 2 again and move right.
                                            write these numbers in unary. separated by 0 (delimiter)
                                            2 Zero's to separate quintuples.

                                    Say state q0 is initial state and q1 is only accepting state (from all accepting states come to q1)
                                    Symbol S2 is blank symbol.
                                    Any ill formatted binary string is said to represent a TM which accepts a language PHI.
                                    So, Every finite binary is a representation of some TM that accepts a langugage over SIGMA 
                                    for every TM that accepts some language over SIGMA we have an encoding for that TM.
                                    Enumerate all TM thru binary combinations.
                                    their languages will be L(M1),L(M2),...
                            </TMEncodingAsString>                                
                            Enumerate all finite binary strings over SIGMA.
                            Matrix
                                Contents of matrix aij = 1 if Mi accepts jth binary string else 0.
                                we are going to find a language Ld and ensure that Ld != L(Mi) for any i.
                                    => Ld is not re.
                                    Let's define Ld as {x BELONGS {0,1} | The TM whose code is x doesn't accept x  }
                                        Basically flip the diagonal values.
                                    Let's assume there is a TM which accepts Ld.
                                    So, M be the rth TM in our enumeration. Let x be the rth binary string in the enumeration.
                                    Either x BELONGS Ld or doesn't. Contradiction in both cases.
                                        IF x BELONGS Ld => M doesn't accept x => L(M) != Ld.
                                        IF x !BELONGS Ld => M would accept x => L(M) != Ld.
                            Ld is not re.
                                Ld defn- Ld != L(M1); != L(M2); .....
                        Halting problem
                            Input (contradict,contradict) to the supposed halting program, it spits out yes/No.
                                if yes, the only case d(contradict) TM halts is when it stops and says that the TM you have inputted doesn't halt for the input
                                    in this case, it says the D(contradict) TM for the input (of itself) doesn't halt. Then, the original TM should have said- yes it does halt (to say that it doesn't halt)
                            then it means when contradict was inputted into contradict, the first part would have also generated yes, it should have gone into infinite loop and had not stopped.
                                if No, it means first part of d(contradict) would have said- that it doesn't halt and thus, should have halted.
                        <Decidability>//Not organized
                            Problem and Instance
                                    What is problem and what is its instance?
                                            is language accepted empty? does a graph have hamiltonian circuit.
                                            TM checks for yes/no instance for a decision probs.
                            Problem Types
                                    Computational Problems- given input, find output.
                                    Decision Problems
                                            Come up with algo- then decidable else not
                                                    no general algo that can tell.
                                            Instance of boolean expression is satisfiable.
                                            given a grammar, is it ambiguous?
                                                    Eg- S->aSb|ab (unambigous) vs S->SS|a (ambigous)- no/yes instance of problem.

                                            PIE is undecidable problem means L (all instances of problem as strings)- are not recursive.
                                    Optimization problem- Find hamiltonion path is optimization problem.
                                            find a string with 1 or more derivation trees.
                                Ld' is re but not recursive- for all wi run Ti- if matches accept, reject or loop.
                            Reduction
                                Solve x you can solve undecidable y means x is undecidable. y reduces to x.
                                Ld reduces to Halting problem- so HP is undecidable.
                            Some Probs
                                (x1+x2)(x1'+x2')- this is satisfiable means whether there is an assignment that makes it true- decidable.
                                        given an expression- is it satisfiable- can you find out an assignment for which you can make wff true.
                                        1 instance is an expression. given a string of boolean expresssion- get those strings that evaluate to 1.
                                AMB- given grammar as string. L amb- set of all ambiguous strings. should be recursive (must halt on all input)
                                        RE and Outta RE are undecidable.
                                Does M accept w?
                                        Similar to halting-
                                Validity problem of propositional logic- ~ to SAT logic- whether a formula in propsitional logic is tautology- whether eval to 1 always.
                                        SAT problem- find out if there's an assignment of variables make it one.
                                        draw truth table and so decidable. First order logic- is it valid or not- 
                                        second order puts a bound on first order logic also.
                            Rice Theorem- L in RE- has to accepted by TM so L = L(M).
                                    Property S (problem like square a number) can be implemented by many function "strings"
                                    Let a Language L implemented by a TM contain some of such strings then L in in S.
                                    Plan- Ls is recursive, so Lu recursive but Lu is not. So Ls is not.
                                    wlog means without loss of generality- 
                                    S is not empty means some L BELONGS S say L is accepted by Ml.
                                    Construct M' as- L(M') = L if M accepts w else PHI.
                                Does w BELONGS L? Membership problem. 
                                        CFL is decidable but TM aren't.
                        </Decidability>        
                    </Others>
                </Languages>
                <CompilerDesignTheory>
                    Nervous nahi iccha hai sabko hasane ki
                    Nervous kyun kaun si maar khani hai
                        <CompilerDesign>
                                <What>
                                        steps of making programs to enable writing programs in HLL
                                        <How>
                                                HLL- Define your High level language (services, syntax)
                                                <InvokeCompiler>
                                                        gcc -c 1.c
                                                        Does following things
                                                        Preprocessor-
                                                                Automatic- remove all #define, #include- for ease of programming
                                                                #define to include constants, function macros- repetitive codes.
                                                                #include to include files within the code.
                                                        Compiler
                                                                generates assembly language code
                                                                It's platform specific.
                                                        Assembler
                                                                generates machine code
                                                                        relocatable- Program can be moved.
                                                                        absolute- Program should be at 1 place.
                                                                @Item Manual specific to instruments- platform specific
                                                </InvokeCompiler>
                                                <Linker>
                                                        generates executable and stores it in pwd.
                                                        gcc 1.o 2.o -o output
                                                </Linker>
                                                <Loader>
                                                        generates process
                                                </Loader>
                                        </How>
                                </What>
                                <Why>
                                        comfortable in HLL (avoiding low level thinking)
                                        When- parsing input.
                                        Where- Applications!
                                </Why>
                                <How>
                                        Eg- x = a + b * c;
                                                we will see how it evolves thru stages- the stream of characters ends up as instructions to machine parts of computer.
                                        <MachineIndependentPart>
                                                aka front end of Compiler
                                                <LexicalAnalysis>
                                                        generates stream of token- iteratively passes onto Syntax analysis.
                                                        removes/ neglects whitespaces and comments.
                                                                you can write whole C program in 1 line or format for neat code.
                                                        useful in reporting errors
                                                                line number = number of \n encountered!
                                                        identifies identifiers, operators, etc- thru regular expressions.
                                                                Eg- l(l+d)*
                                                        ThruEg- id = id + id * id ; //spits each one of them 1 by 1 to syntax analyser.
                                                        Tools- Lex, flex, etc
                                                        Eg- number of tokens here = 25 (ignoring comments)
                                                            int max(x,y)
                                                            int x,y;
                                                            //find max of x and y
                                                            {
                                                                    return (x > y?x : y);
                                                            }
                                                        Eg- printf("%d Hi",&x);
                                                                No of tokens = 8 (String is 1 token inside printf)
                                                </LexicalAnalysis>
                                                <SyntaxAnalysis>
                                                        aka Parser
                                                        generate parse tree from tokens using grammar specification.
                                                        picks tokens and forms a tree using grammer rules
                                                        <Grammar>
                                                                G = (VTPS)
                                                                        Eg- V = {E}, T = {+,*,id}, S = E
                                                                        P = {E -> E+E | E * E | id}
                                                                <Derivation>
                                                                        id + id * id
                                                                        <Leftmost>
                                                                        Leftmost- replace first non-terminal to terminal.
                                                                                E => E + E => id + E => id + E * E => id + id * E => id + id * id
                                                                                E => E * E => E + E * E => id + E * E => id + id * E => id + id * id
                                                                        </Leftmost>
                                                                        <Rightmost>
                                                                        Rightmost- rightmost variable is replaced first.
                                                                                E => E + E => E + E * E => E + E * id => E + id * id => id + id * id
                                                                                E => E * E => E * id => E+E*id => E+ id*id => id+id*id
                                                                        </Rightmost>
                                                                        <ParseTree>
                                                                        This derivation can be written as a parse tree.
                                                                                E- E-id
                                                                                |-+E- E-id
                                                                                   |-*E-id
                                                                                Yield of Parse tree- write terminals along euler tour.
                                                                                More than 1 derivation or parse tree 
                                                                                        parser doesn't know how to generate- confusion -> ambiguity
                                                                                        different evaluations for different parse trees so error is given.
                                                                                        gotta convert ambiguous grammar to unambiguous.
                                                                                        Practice- no procedure/algo to find out. Undecidable Problem!
                                                                        </ParseTree>
                                                                        <AmbiguousGrammars>
                                                                                Eg-
                                                                                        S -> aS | Sa | a
                                                                                        for aa- S => aS => aa OR S => Sa => aa.
                                                                                Eg-
                                                                                        S -> aSbS | bSaS | EPSILON
                                                                                        for abab, S => aSbS => abab OR s=> aSbS -> aEPSILONbaSbS => abaEPSILONbEPSILON=> abab
                                                                                Eg- 
                                                                                        R -> R + R | RR | R* | a | b | c
                                                                                        this is grammar for regular expressions.
                                                                                        a+bc => R + R => R+R.R
                                                                                        R => R.R => R+R.R
                                                                                        cuz a+bc could be (a+b).c or a+(b.c)
                                                                                <DisambiguityRules>
                                                                                        target root cause of ambiguity
                                                                                        <AssociativityProblem>
                                                                                                Eg- id + id + id
                                                                                                        E => E + E => E + (E + E) => id + (id + id)	//parantheses for understnading
                                                                                                        E => E + E => E + E + E => (id + id) + id	//associativity problem
                                                                                                Problem- middle operand has operator on either side- which one to associate it with.
                                                                                                        There is no order of growth for parse tree.
                                                                                                Decisions
                                                                                                        +, etc are most (of operators) are left associative.
                                                                                                        ^ is right associative.
                                                                                                        Recursion
                                                                                                                if derivations go in left direction then left associative and vv
                                                                                                                Left Associative
                                                                                                                        leftmost symbol in RHS = LHS
                                                                                                                        Eg- E -> E + id | id
                                                                                                                        id + id + id + id = (((id + id) + id)+id)
                                                                                        </AssociativityProblem>
                                                                                        <PrecedenceProblem>
                                                                                                Eg- id + id * id
                                                                                                        E => E + E => E + E * E => E + E * id => E + id * id => id + id * id
                                                                                                        E => E * E => E * id => E+E*id => E+ id*id => id+id*id
                                                                                                Problem- which operator to associate with.
                                                                                                Decisions
                                                                                                        * should have greater precedence than +.
                                                                                                        Levels
                                                                                                                * should be lower level to + so that it is evaluated first.
                                                                                                                        E -> E + T
                                                                                                                        T -> T * F
                                                                                                                        meaning generate all + terms first and then go to mult- thus mult will be first (precendence)
                                                                                                                                once reaching T you can never reach + cuz T can't generate it but E can.
                                                                                                                                what if no + in grammar? so E -> E + T | T and T -> T * F | F.
                                                                                                                                There are levels of grammar generation. Once on next level, prev won't exist.
                                                                                                        Precedence in PL
                                                                                                                Brackets, dot operators.
                                                                                                                Bitwise negation, unary operators, pointers
                                                                                                                Arithmetic
                                                                                                                Bitwise Shifting
                                                                                                                Relational
                                                                                                                Bitwise Gates (AND, XOR, OR)
                                                                                                                Logical (AND, OR)
                                                                                                                Ternary, Assignment
                                                                                        </PrecedenceProblem>
                                                                                        <Eg>
                                                                                        Eg- Arithmetic Expressions
                                                                                                E -> E + T | T
                                                                                                T -> T * F | F
                                                                                                F -> G ^ F | G
                                                                                                G -> id
                                                                                                +, *, ^ in this sequence.
                                                                                        Eg- Boolean Expressions
                                                                                                B -> B OR B
                                                                                                   | B AND B
                                                                                                   | NOT B
                                                                                                   | True
                                                                                                   | False
                                                                                                Precedence - NOT, AND, OR
                                                                                                Associativity- right associative.
                                                                                                So
                                                                                                B -> B OR E | E
                                                                                                E -> E AND F | F
                                                                                                F -> NOT F | True | False.
                                                                                        Eg- Regular Expressions
                                                                                                R -> R + R | RR | R* | a | b | c.
                                                                                                E -> E + T | T
                                                                                                T -> TF | F
                                                                                                F -> F* | a | b | c
                                                                                        Given a grammar you can tell precedence rules- associativity also and ambiguity.
                                                                                                Eg- 
                                                                                                        A -> A $ B | B
                                                                                                        B -> B # C | C
                                                                                                        C -> C @ D | D
                                                                                                        D -> d
                                                                                                        Associativity- all operators are Left
                                                                                                                $ > $ (left associative)
                                                                                                        Precedence- @, #, $
                                                                                                                $ < # < @
                                                                                                Eg- 
                                                                                                        E -> E * F | F + E | F
                                                                                                        F -> F - F | id
                                                                                                        Ambiguous on precendence among +,*
                                                                                                                * = + > - 
                                                                                                        Associativity- left- *, right- +, ambiguity for -.
                                                                                                                * > * and + < + and - ? -
                                                                                        </Eg>
                                                                                </DisambiguityRules>
                                                                        </AmbiguousGrammars>
                                                                        <RRRecursive>
                                                                            LR Grammars- A -> A a | b
                                                                                Generates- ba*
                                                                                Not liked by Top Down parsers
                                                                                    equivalent to a recursive function calling itself b4 any statement (conditional check) => Infinite Loop.
                                                                                Solution- convert them to RR.
                                                                                    Eg- A -> A a | b
                                                                                        A -> bA'
                                                                                        A' -> aA' | EPSILON.
                                                                                    Eg- E -> E + T | T      (Equivalent to Aa|b)
                                                                                        E -> T E'
                                                                                        E' -> EPSILON | +TE'
                                                                                    Eg- S -> S 0 S 1 S | 01
                                                                                        S -> 01S'
                                                                                        S' -> EPSILON | 0S1SS'
                                                                                    Eg- S -> (L) | x; L -> L,S | S
                                                                                        L -> SL' and L' -> ,SL' | EPSILON
                                                                                    Eg- A -> Aa1 | A a2 | A a3 | ....|b1|b2..
                                                                                        A -> b1A' | b2A' |...
                                                                                        A' -> a1A' | a2A'....|EPSILON.
                                                                            RR Grammars- A -> a A | b
                                                                                Generates- a*b
                                                                        </RRRecursive>
                                                                        <DeterministicGrammar>
                                                                            A -> ab1 | ab2 | ab3
                                                                                multiple paths to take
                                                                            for ab3, we may choose ab1 and turns out to be bad choice.
                                                                                backtrack again! Then try with ab2 then finally ab3
                                                                                cuz of common prefix- backtracking happening- we are choosing leftmost derivation b4 looking at prefix.
                                                                            Solution- Postpone the choice of suffix.
                                                                                aka Left Factoring or Eliminating Non-Determinism.
                                                                                Eg- A -> ab1 | ab2 | ab3
                                                                                    A -> aA'
                                                                                    A' -> b1 | b2 | b3
                                                                                    So no decision for first part and right decision at second part.
                                                                                Eg- S -> iEtS | iEtSeS | a ; E -> b
                                                                                    this is Statement = if Expression then Statement OR added else part OR assignment.
                                                                                    Expression can be any boolean statement.
                                                                                    Non-deterministic cuz common prefix. Let's take common prefix outside.
                                                                                    S -> iEtSS' | a
                                                                                    S' -> eS | EPSILON
                                                                                    E -> b.
                                                                                    Ambiguous?
                                                                                        S => iEtS => iEt(iEtSeS)
                                                                                        S => eEtSeS => iEt(iEtS)eS
                                                                                        After determinism, still ambiguous- it's a different thing altogether
                                                                                            S => iEtSS' => iEt(iEtSS')S' => iEtiEtS(eS)EPSILON
                                                                                            S => iEtSS' => iEt(iEtSS')S' => iEtiEtS(EPSILON).eS
                                                                                            Root cause of ambiguity is dangling else- whom to associate else to.
                                                                                            Decision- else is associated to closest if.
                                                                                Eg- S -> aSSbS | aSaSb | abb | b
                                                                                    common prefix for lhs (S) is there - 'a' or 'aS' (anyone will work)
                                                                                    S -> aS' | b
                                                                                    S' -> SSbS | SaSb | bb
                                                                                    Still, S' -> SS'' | bb; S'' -> SbS | aSb.
                                                                                Eg- A->aA ; B-> aB  - it's not non-deterministic.
                                                                                Eg- S -> bSSaaS | bSSaSb | bSb | a
                                                                                    common prefixes- bS or bSSa- use either.
                                                                                    S -> bSS' | a
                                                                                    S' -> SaaS | SaSb | b
                                                                                    but common 'Sa'
                                                                                    S' -> SaS''| b
                                                                                    S'' -> aS | Sb.
                                                                        </DeterministicGrammar>
                                                                        <Strategy>
                                                                            <TopDownParser>
                                                                                acronym- TDP
                                                                                Somehow reach word starting from S using intelligent derivations.
                                                                                Eg- S -> aABe; A -> Abc|b; B -> d
                                                                                w = abbcde
                                                                                S => aABe ; now choice for A and B => a(Abcd)Be => abbcdde- done!
                                                                                    always uses left most derivation!!
                                                                                Choice is which alternative of product to choose.
                                                                                <withBacktracking>

                                                                                </withBacktracking>
                                                                                <withoutBacktracking>
                                                                                    Grammar should not have Non-determinism OR Left Recursion.
                                                                                    <RecursiveDescent>
                                                                                        Brute Force- Try all possibilities- it goes wrong then backtrack.
                                                                                            E->iE'
                                                                                            E'->+iE'|Ep
                                                                                            Write down productions in form of functions
                                                                                            E(){
                                                                                                if(l=='i'){     //l is lookahead character.
                                                                                                    match('i');
                                                                                                    E'();
                                                                                                }
                                                                                            }
                                                                                            E'(){
                                                                                                if(l=='+'){
                                                                                                    match('+');
                                                                                                    match('i');
                                                                                                    E'();
                                                                                                }
                                                                                                else
                                                                                                    return;     //would have written switch case- if many.
                                                                                            }
                                                                                            match(char t){
                                                                                                if(l==t)
                                                                                                    l=getchar();
                                                                                                else
                                                                                                    printf("Error");
                                                                                            }
                                                                                            main(){
                                                                                                E();
                                                                                                if(l=='$')
                                                                                                    printf("Successful Parsing");
                                                                                            }
                                                                                            This also mimics- stack or parse tree using system stack.
                                                                                    </RecursiveDescent>
                                                                                    <NonRecursiveDescent>
                                                                                        LL1- Left to right; Leftmost derivation used. 1- 1 symbol seen at a time.
                                                                                            Components
                                                                                                LL1 Parser- Parsing algorithm- what action to take.
                                                                                                LL1 Parsing table- Data Structure constructed using grammar
                                                                                                Stack- $ bottom marker
                                                                                                input buffer- ended by $
                                                                                            Methods
                                                                                                To Determine the next candidate production to use
                                                                                                First(V)- first symbol (or terminal) that Vertex (or non-terminal) can generate.
                                                                                                    gotta draw a tree to find out.
                                                                                                    Eg- S-> aABCD; A -> b ; B -> c ; C -> d ; D -> e
                                                                                                        First(S) = {a}, First (A) = {b}
                                                                                                Follow- In process of derivation what will that vertex be followed by
                                                                                                    Eg- S$ => ABCD$ => ABdD$ => Follow(B) = {d}
                                                                                                    Another way is as follows:
                                                                                                        $ is follow of e1.
                                                                                                        check if it appears anywhere in RHS of a product
                                                                                                            get first of vertex appearing next to it. if terminal, ?then write.
                                                                                                    Follow(S)={$}, Follow(A) = {$,c}, Follow(B) = {$,d}, Follow(C) = {e}
                                                                                                    Eg- A -> BC
                                                                                                        Follow(C) = Follow(A)
                                                                                                        Eg- ...=> Aabc$ => BCabc$
                                                                                            Eg- S -> ABCDE; A -> a | EPSILON ; B-> b | EPSILON; C -> c ; D -> d | EPSILON ; E -> e | EPSILON
                                                                                                First; Follow
                                                                                                    S- A - a, b (if A generate Ep), c ;;$
                                                                                                    A- a, Ep    ;;=first(B)=b and first(C)=c (if B generates Ep)
                                                                                                    B- b, Ep    ;;c
                                                                                                    C- c        ;;first(D) = d and Ep so first(E) = e and Ep, so First(S) = $
                                                                                                    D- d, Ep    ;;{e,$}
                                                                                                    E- e, Ep    ;;{$}
                                                                                            Eg- S-> Bb | Cd ; B -> aB | Ep; C -> cC | Ep
                                                                                                First;; Follow
                                                                                                    S- {a,b,c,d}    ;;{$}
                                                                                                    B- {a,Ep}       ;;{b}
                                                                                                    C- {c,Ep}       ;;{d}
                                                                                            Eg- E-> TE'; E'-> +TE | Ep; T-> FT'; T'-> *FT'|Ep ; F -> id | (E)
                                                                                                First;; Follow
                                                                                                    E- id, C(opening brace)     ;; $, J (closing brace)
                                                                                                    E'- +, Ep                   ;; $, J
                                                                                                    T- id, c                    ;; +, $, J
                                                                                                    T'- *,Ep                    ;; +, $, J
                                                                                                    F- id, c                    ;; *, +, $, J
                                                                                            Eg- S -> ACB | CbB | Ba; A-> da | BC ; B -> g | Ep; C -> h | Ep
                                                                                                First;; Follow
                                                                                                    S- dghba,Ep    ;;$
                                                                                                    A- dgh,Ep   ;;h,g,$
                                                                                                    B- g, Ep    ;;$,a,h, g.
                                                                                                    C- h, Ep    ;;g,$, b,h,g,$
                                                                                            Eg- S -> aABb; A -> c | Ep; B -> d | Ep
                                                                                                S-a         ;;$
                                                                                                A-c,Ep      ;;d,b
                                                                                                B-d,Ep      ;;b
                                                                                            Eg- S -> aBDh ; B-> cC; C -> bC | Ep; D -> EF; E -> g | Ep; F -> f | Ep
                                                                                                S-a         ;;$
                                                                                                B-c         ;;gfh
                                                                                                C-b,Ep      ;;gfh
                                                                                                D-g,f,Ep    ;;h
                                                                                                E-g,Ep      ;;f,h
                                                                                                F-f,Ep      ;;h
                                                                                                we use DP principles also- reuse computed results.
                                                                                        Make A matrix- Non-terminal vs terminal- values contained- candidate productions.
                                                                                                    id      +       *       (       )       $
                                                                                            E     E->TE                 E->TE'
                                                                                            E'          E'->+TE'                E'->Ep      E'->Ep  (use follow for Ep transitions)
                                                                                            T     T->FT'                T->FT'
                                                                                            T'          T'->Ep   T'->FT'        T'->Ep      T'->Ep
                                                                                            F     F->id                 F->(E)
                                                                                        Eg- S -> (S) | Ep
                                                                                            For matching parantheses
                                                                                                (       )       $
                                                                                            S   S->(S)  S->Ep   S->Ep
                                                                                            Eg- (())$
                                                                                                stack starts with $ and S.
                                                                                                to generate (, look up in table, S->(S) should be used- we want to wipe off ( for it is being produced and S and ) remain.
                                                                                                so push on stack from right to left of rhs of production- stack- $)S.
                                                                                                Next ( is to be generated, so again, table look up, S->(S), so stack- $)JSC. matches so pop and increment indicator.
                                                                                                Next, J is to be generated, so S -> Ep. Stack- JJ. Match with last 2 closing braces, match- pop off.
                                                                                                $ on stack and $ on tape = generated.
                                                                                                But won't work always because >=1 production in table entry is confusion!
                                                                                            Eg- S -> AaAb | BbBa; A-> Ep ; B -> Ep
                                                                                                    a       b       Ep
                                                                                            S   S->AaAb S->BbBa
                                                                                            A   A->Ep   A->Ep
                                                                                            B   B->Ep   B->Ep
                                                                                                1 entry in table => LL1 grammar.
                                                                                        Precondition
                                                                                            LL1 Grammar
                                                                                                1. 1 entry per table (later)
                                                                                                2. Not Left Recursive (LR)
                                                                                                3. Not Non-deterministic (LF)
                                                                                            Eg
                                                                                                semicolon separates for productions.
                                                                                            Eg- 
                                                                                                S-> aSbS    - a
                                                                                                    | bSaS  - b
                                                                                                    | Ep    - a,b,Ep
                                                                                                It's not LL1
                                                                                            Eg- 
                                                                                                S-> aABb    -a
                                                                                                A -> c | Ep -c;d,b
                                                                                                B -> d | Ep -d;b
                                                                                                all in different cells- LL1
                                                                                            Eg- 
                                                                                                S->A|a      -a,a
                                                                                                A->a
                                                                                                Nope
                                                                                            Eg- 
                                                                                                S->aB|Ep    -a;$
                                                                                                B->bC|Ep    -b;$
                                                                                                C->cS|Ep    -c;$
                                                                                                LL1.
                                                                                            Eg-
                                                                                                S->AB       -a,b,$
                                                                                                A->a|Ep     -a;b$
                                                                                                B->b|Ep     -b;$
                                                                                                LL1
                                                                                            Eg-
                                                                                                S->aSA|Ep   -a;$c
                                                                                                A->c|Ep     -c;c
                                                                                                NOT LL1
                                                                                            Eg-
                                                                                                S->A
                                                                                                A->Bb|Cd    -ab;cd
                                                                                                B->aB|Ep    -a;b
                                                                                                C->cC|Ep    -c;d
                                                                                                LL1
                                                                                            Eg-
                                                                                                S->aAa|Ep   -a;$a
                                                                                                A->abS|Ep
                                                                                                NOT LL1
                                                                                            Eg- 
                                                                                                S->iEtSS'|a     -i;a
                                                                                                S'->eS|Ep       -e;e
                                                                                                E->b
                                                                                                Not LL1
                                                                                    </NonRecursiveDescent>
                                                                                </withoutBacktracking>
                                                                            </TopDownParser>
                                                                            <BottomUpParser>
                                                                                acronym- BUP
                                                                                aka SR Parsers- Shift Reduce- Stack Push, pop.
                                                                                Eg- abbcde => aAbcde => aAde => aABe => S.
                                                                                    Uses right most derivation- read backwards.
                                                                                Choice to make is when to reduce it now or not.
                                                                                <OperatorPrecedenceParser>
                                                                                    aka Infix to Postfix algorithm
                                                                                        Based on push/pop or shift Reduce (synonym)
                                                                                    Operator Grammar- used to generate operators arithmetic etc- with some restrictions on grammar.
                                                                                        E->E+E|E*E|id
                                                                                        vs
                                                                                            E->EAE
                                                                                            A->+|*
                                                                                            2 variables are side by side- not accepted.
                                                                                        Eg- S->SAS|a; A->bSb|b
                                                                                            Not Operator Grammar cuz- variables together.
                                                                                            S->SbSbS | SbS | a
                                                                                            A-> bSb | b
                                                                                            this is OG.
                                                                                        Only parser which can parse ambiguous grammar.
                                                                                        Operation Relation Table
                                                                                                id      +       *       $- Input
                                                                                        id      -       >       >       >
                                                                                        +       <       >       <       >
                                                                                        *       <       >       >       >
                                                                                        $       <       <       <       -
                                                                                      Stack
                                                                                        Eg- id+id*id
                                                                                            Push on stack top lesser than input and Pop on greater (vv)
                                                                                            Stack- $
                                                                                                $ < id, so push id. Stack- $,id
                                                                                                id > +, pop id, meaning reduce it to E. Stck- $
                                                                                                + < id, push id. Stack- $,+,id
                                                                                                id > *, pop id. stack- $,+,*
                                                                                        Size of table, O(n^2)




                                                                                </OperatorPrecedenceParser>
                                                                                <LRParsers>
                                                                                    so called? parse from left to right. Reverse of Rightmost derivation.

                                                                                </LRParsers>
                                                                            </BottomUpParser>
                                                                        </Strategy>
                                                                </Derivation>
                                                                PL has 100s of production rules.
                                                                        Eg- 
                                                                        S -> id = E;
                                                                        E -> E+T | T
                                                                        T -> T*F | F
                                                                        F -> id
                                                                        Acronyms- start symbol, expression, term, factor.
                                                        </Grammar>
                                                        ThruEg-
                                                                S-id
                                                                |-=E- E-T-F-id
                                                                   |-+T-T -F-id
                                                                      |-*F-id
                                                                top down
                                                                bottom up
                                                        Tools- lance, yacc, cup, etc.
                                                </SyntaxAnalysis>
                                                <SemanticAnalysis>
                                                        generates semantically verified Parse Tree.
                                                        Symbol Table- used thru the stages??
                                                        ThruEg- correctness- lvalue can't be constant or function name, arrayname.
                                                </SemanticAnalysis>
                                                <IntermediateCodeGeneration>
                                                        3-address Code (or n-address code as per machine)
                                                        t1 = b * c;
                                                        t2 = a + t1;
                                                        x = t2;
                                                </IntermediateCodeGeneration>
                                        </MachineIndependentPart>
                                        <MachineDependentPart>
                                                aka back end of compiler
                                                Platform dependent- depends on machine used.
                                                        java takes advantage of this.
                                                <CodeOptimization>
                                                        reduces number of lines
                                                        ThruEg- 
                                                        t1 = b * c;
                                                        x = a + t1;
                                                </CodeOptimization>
                                                <TargetCodeGeneration>
                                                        is the assembly code.
                                                        ThruEg- mul R1,R2
                                                                add R0,R2
                                                                mov R2,x
                                                                assuming a in R0, b in R1, c in R2.
                                                </TargetCodeGeneration>
                                        </MachineDependentPart>
                                </How>
                        </CompilerDesign>
                </CompilerDesignTheory>
                <CompilerDesign>
                    <Theory> Chapter 1-3 of Ravula Done
                        Compiler high level language to low level language
                            why? we are not comfortable writing it in 0 and 1 but in english and convert our intent.
                            Turbo C or gcc does all that.
                        <StagesOfProgramExecution>
                            <PreProcessor> remove preprocessor directives to make it Pure high level language (Pure HLL)
                                    #define to change it in one place- reflect ew in program or macro extensions.
                                    File inclusion.
                            </PreProcessor>
                            <Compiler>
                                Pure HLL to Assembly language. All stages are going to take support from symbol table and talk to module called error handler.
                                Tool for compiler project- Lance- implementation of the front end of compiler which gives IMC (intermediate code) and implement back end on your own (depending on platform)
                                Compilation
                                    multiple sources files and header files (fn declaration)
                                    converted into object code by compiler(parser does syntax check, etc)
                                    gcc gives option to link and load with it- -c option means only compile.
                                <FrontEnd>
                                    <LexicalAnalysis>
                                        HLL to stream of tokens.
                                            x=a+b*c;/*statement*/
                                            id = id + id * id   //removed comment. Using patterns the identifiers/keywords are identified
                                            Tool- flex,lex.

                                            only phase which read character by character (letter never seen later (int is a lexiom))
                                                    identify lexiom
                                                    remove whitespace (C program in 1 line no error)
                                                    at this phase only we see the line number- syntax error- because lexical analyser knows the line number.
                                                    eg- in printf statement- 8 tokens identified.
                                    </LexicalAnalysis>
                                    <Parser>
                                        aka Syntax analysis/ parser- stream of tokens to parse tree.
                                            tokens are given to grammar. Every language is represented as 100s of productions of grammar.
                                            Using these grammar production rules, parse tree is generated. see thru euler tour of the tree.
                                            yield should be same as input string.
                                            Tool- Yacc (Yet Another Compiler Compiler)

                                            Parser- input is grammar- so let's study grammar.
                                        <Grammar> VTPS.
                                            Eg- P = E-> E + E | E * E | id
                                                V = {E} T = {+,*,id} S = E
                                            <Ambiguous>
                                                To derive id + id * id
                                                    Left most derivation- E-> E + E -> id + E -> id+E*E-> id+id*E -> id+id*id
                                                            also, E-> E * E -> E + E * E -> id + E * E -> id + id * E -> id + id * id
                                                    Right most derivation- E -> E + E -> E + E * E -> E + E * id -> E + id * id -> id + id * id
                                                            also, E-> E * E -> E * id -> E + E * id -> E + id * id -> id + id * id
                                                for a given grammar, there are more than 1 derivation/ parse tree. Confusion- which is right? Both yield different answers.
                                            </Ambiguous>
                                            <StepsInvolved>
                                                how to identify ambiguous grammar.
                                                    if I see more than 1 parse tree for a grammar ->gotta convert! experience.
                                                How to convert to unambiguous. Why they become ambiguous?
                                                <Associativity> id+id+id 
                                                    when 2 operators on either side of operands which operator should I associate it with- left associativity vs right.
                                                    decide left associative or right for a given operation.
                                                    if left associative, I want parse tree to grow along left branch so 1 direction growth restriction.
                                                        E-> E + id / id means E -> E + id (I am forced to grow along left branch (no branch possible to create ambiguity)
                                                            no way to get another parse tree. 
                                                </Associativity>
                                                <Precedence>
                                                Precedence- id+id*id
                                                    * will be evaluated before +.
                                                    + will be at higher level and * at lower ( for * to be evaluated first)
                                                    E -> E + T (E is left associative) | T ( once T is generated, your power of generating + thru T is gone so that T is gonna be the last + separated expression)
                                                    T -> T * F (* is left associative) | F   F -> id
                                                    * is possible only after +. Generate all + at high levels and * at lower ones (* eval first)
                                                    but what if no * or + in the string- have a unit production to id.
                                                    Gurantees unambiguity- unique parse tree.
                                                    ^ is right associative. so F -> G ^ F | G.   G -> id
                                                    after generating all + there is no way to come back so precedence implemented.
                                                    Operation closest to start symbol has lowest precedence and farthest has highest precedence.
                                                </Precedence>            
                                                <CaseStudies>
                                                    Boolean Expressions- bExp -> bExp OR bExp | bExp AND bExp | NOT bExp | TRUE | FALSE.
                                                            E -> E OR F | F
                                                            F -> F AND G | G
                                                            G -> NOT G | TRUE | FALSE
                                                    Regular Expressions- R-> R+R| RR| R*|a | b| c
                                                            E -> E + T | T
                                                            T -> TF | F
                                                            F -> F * |a|b|c
                                                    Eg- A -> A $ B | B
                                                            B -> B # C | C
                                                            C -> C @ D | D
                                                            D -> d
                                                            $,@,# are all left associative. so $ > $ (associative) and $ < # < @.
                                                    Eg- E -> E * F | F + E | F; F -> F - F | id
                                                            + and * have same precedence at same level and - has more precedence.
                                                            + is right associative, * is left associative.
                                                            - is both sides associative.
                                                            grammar is ambiguous.
                                                             + = *; * > * and + < + and - can be either.
                                                </CaseStudies>
                                            </StepsInvolved>
                                        </Grammar>
                                    </Parser>
                            (Lecture
                                        3 Done)
                                            Semantic analysis- to parse tree (semantically verified)
                                                    verify- lvalue has to be a variable and not function call, or constant.
                                                    meaningfully verified parse tree.
                                            Intermediate code generation- To 3 address code.
                                                    many but 3-address is famous.
                                                    compiler design for new platform? just change the last 2 phases.
                                </FrontEnd>
                                <BackEnd>
                                    Code optimization- 
                                        Reduce the number of lines- unnecessary/ extra stuff removed.
                                    Target Code generation- 
                                        make assembler understand the output.
                                        a->R0,b->R1,c->R2; mul R1,R2 add R0,R2 mov R2,x.
                                </BackEnd>
                            </Compiler>
                            <Assembler>
                                    ASL to machine code (relocatable)
                                    ppl would write in ASL b4 HLL.
                                    Compiler makes sure you write anywhere in RAM.
                            </Assembler>
                            <LinkerLoader>
                                all object files .o are Linked together by linker to make an execution- resolving function calls and where to jump to 
                                    Compilation just marks the location with BRANCH (or sth) to be resolved later- when other object files are available
                                    Compiler doesn't know their addresses until then.
                                    Relevant portions are taken and put in a single disk file.
                                    Also, other objects code is automatically included.
                                    Then this executable is loaded by loader to become a process(program under execution).

                            </LinkerLoader>
                        </StagesOfProgramExecution>
                    </Theory>
                    <Tools>
                        <EnviornmentSetUp>
                            Refer to Photos- self explanatory
                            Download
                                    mingw download- https://sourceforge.net/projects/mingw/files/
                                            mark for installation- gcc,etc and apply Changes from menu bar->Installation
                                    Bison Download- http://gnuwin32.sourceforge.net/packages/bison.htm
                                    Yacc Download- http://gnuwin32.sourceforge.net/packages/byacc.htm
                                    Flex Download- http://gnuwin32.sourceforge.net/packages/flex.htm
                            Set Envt Variables
                            Use commands in program
                            Caution
                                    direct under the drive or 1,2 levels or special locations (program files) don't give permission to write executables,etc so choose location with this caution.
                            Info	
                                    $ marks end of string/sentence
                                    2 approaches
                                    Top Down- source derives string at hand.
                                    Bottom Up- YACC uses this.
                                            Push symbols/tokens into the stack until an rhs of prod matches and reduces it to lhs
                                            recusively go on until source is reached.
                        </EnviornmentSetUp>
                        <LexicalAnalyzer>
                            C code using flex directly to read the file contents
                            flex myscanner.l 
                                    .l file tells patterns to look for and actions to take.
                                    uses myscanner.h (for returning number codes for every pattern) gives 
                                    generate lex.yy.c code which facilitates
                                            yylex() - matches next lexiom/token and action says return the corresponding number code.
                                                    which spits out the next token's number code (mentioned in header file) that matches any of the patterns specified in input to flex.
                                                    yylineno and yytext for line and text read.
                                                    call it till yylex returns null (EOF)		
                                            when? on seeing return statement in action code(?)
                                    along with all the computation that action section of lex file specified for every pattern.
                            gcc myscanner.c lex.yy.c -o myscanner
                                    Easy to write a compiler but biggies are complicated.
                                    dbName is written b4 identifier else it will capture the "dbName" as identifier.
                        </LexicalAnalyzer>
                        <Parser>
                            Input gets CFG, action on match and main function (not necessary)
                                    Specification of your tokens (pattern class- a set with elements conforming to the regular set.Eg- a set of identifiers (sharing the property of pattern)) calc.l
                                    Preamble of the code- in %{ and %}
                                    Grammar meanings
                                            %start tells the start symbol of productions
                                            %token- different token types coming from lex. (terminals given a class eg identifier)
                                            %type to represent types (non-terminals?)
                                            %union associates datatype with a tokens, or different values my lex can return. works similar to union in C.
                            Command- yacc -d calc.y
                                    -d option is necessary for header generation- necessary for lexical analyser.
                            Output- returns C code of parser y.tab.c and y.tab.h)
                                    yyparse in invoked by main function (within/out). yyparse implicitly uses yylex() to make tokens (all at once)
                                    yyparse iteratively parses tokens until EOF or error
                                    Syntax analyser uses yacc generated code.
                            Working
                                    Calls Lex
                                            first part of lex is optional.
                                            when a pattern matches (1st one), corresponding action is taken
                                                    '+' is alphabet but + in action side for C code- is fundamental addition
                                            get the pattern value (that matched) from yytext (string)
                                                    values and data structures are with lex.yy.c and can be invoked in other pattern(?)
                                                    yylval (used by lexical analyser) is temporary data structure (union)(refer to y.tab.h produced by yacc calc.y which in turn comes from first part of .y)
                                                            yylval.id = yytext[0]; followed by return identifier;
                                                            means get the first char of pattern that emerged and save it as member var "id" of type identifier.
                                                            yylval.f is global value in parser, associated with this token
                                                                    regular expression for floating point is written
                                                            shift reduce means error in grammar.
                                            "return"- passes control back to calling program with return value
                                                    return x means return the constant corresponding to x defined in y.tab.h 
                                                            x is deciphered in parser code- x is a token wrapper(label) REL toffee brand but every toffee may have different colors.
                                                    Give a name to those (wrappers) eg- identifier can have id= empId,csStud,les_1 in different cases- but all are identifiers (banner) or a set of identifiers.
                                                    "return" brings control back to the program invoking lex.
                                            they are all terminals. Their label-names and type (union with datatype) is speciified in yacc file as %token
                                            yywrap necessary when many files involved
                                            Output- Return a C code- lex.yy.c which supports yylex() fn call, returns what is specified in return clause, yylineNo and yytext (the pattern instance)
                                    the streak of tokens thus produced are used as input to settle grammar rules.
                                            as soon as a grammar production rule satisfies, the corresponding action is taken (print,compute cumulatively) as stack push pops are done
                                                    as it builds parse tree- there is a room for generating code and interpret meaning or associate C statements
                                                    the action can interact with classes/methods defined outside of itself (use include preprocessor directives) to get services.
                                                    action can use function definitions in 3rd part of yacc file (declared in 1st part).
                                                            symbolVal() function is to look up symbol table (A-Zthen a-z column entries against 52 cells 0 for A and 26 for a)
                                                    when final match is done. the action is invoked and yyparse() fn returns.
                                                    $$ left side symbol and $1- first symbol on rhs (T,N included)
                                                    In expressions, the rhs evaluate the value and assigns to the lhs (pushed into stack)
                                                    action section contains C statement[s]
                        </Parser>
                        <YaccLex>
                            Envt set up
                                Refer to Photos- self explanatory
                                Download
                                        mingw download- https://sourceforge.net/projects/mingw/files/
                                                mark for installation- gcc,etc and apply Changes from menu bar->Installation
                                        Bison Download- http://gnuwin32.sourceforge.net/packages/bison.htm
                                        Yacc Download- http://gnuwin32.sourceforge.net/packages/byacc.htm
                                        Flex Download- http://gnuwin32.sourceforge.net/packages/flex.htm
                                Set Envt Variables
                                Use commands in program
                                Caution
                                        direct under the drive or 1,2 levels or special locations (program files) don't give permission to write executables,etc so choose location with this caution.
                            Info	
                                    $ marks end of string/sentence
                                    2 approaches
                                        Top Down- source derives string at hand.
                                        Bottom Up- YACC uses this.
                                                Push symbols/tokens into the stack until an rhs of prod matches and reduces it to lhs
                                                recusively go on until source is reached.
                            Lexer Alone
                                    C code using flex directly to read the file contents
                                        extracts tokens as defined.
                                        used to extract specific "class" values from the text.
                                    How?
                                        Create Lexer
                                            Input
                                                a set if regex and associated actions (in C) (.l file)
                                                .l file tells patterns to look for and actions to take.
                                                How?
                                                    [Part1]
                                                        generate tables internal to lex.
                                                        definition for text replacement- global C code for actions.
                                                        Regex
                                                            %{
                                                            [includeStatements]+
                                                            %}
                                                        %option noyywrap
                                                            if main function is inbuilt
                                                            else 
                                                                give definition for wrap function( in part 3 for main function calling it from outside)
                                                                OR use gcc -lfl LINUS or -ll in OSX10- gives main function to lex,yacc.
                                                    %%
                                                    PatternAction
                                                        regex pattern and associate C code- semicolon separated or block of code.
                                                            regex   [{][CStatements]+[}]
                                                            regex
                                                                abc- matches string "abc"
                                                                [a-zA-Z] - match any lower or uppercase.
                                                                dog.*cat - match any sring starting with dog and ending with cat.
                                                                (ab)+ - Match one or more occurences of "ab" concatenated.
                                                                [^a-z] - match any string of one or more characters that do not include lower case a-z.
                                                                [+-]?[0-9]+ - match any string of one or more digits with an optional prefix of + or -.
                                                                sequence of regexAction is important- because the first match is taken.
                                                                "(string)"- to match with exact string.
                                                            Action
                                                            Eg- [ \t\n]- square braces for a set.
                                                                "String"- string for a string.
                                                    %%
                                                    [Part3]
                                                        C code used as is. contains different functions for actions.
                                                        if gonna use > 1 .c files then include it here
                                                            int yywrap(void){
                                                                return 1;
                                                            }
                                                        if no main program supplied then
                                                            main()
                                                            {
                                                              printf("Let's start it, baby");
                                                              yylex();
                                                            }
                                                    Eg-
                                                        %%
                                                        "hello world"   printf("Krishna");
                                                        .               ;
                                                        %%
                                                        //prints Krishna on console when hello world is read- else does nth.
                                                uses myscanner.h (for returning number codes for every pattern) gives 
                                            Process
                                                flex myscanner.l 
                                                    flex is open source utility of UNIX Lex utility.
                                            Output
                                                a table driven scanner (lex.yy.c)
                                                facilitates
                                                        yylex() - matches next lexiom/token and takes action as specified
                                                                which spits out the next token's number code (mentioned in header file)
                                                                yylineno and yytext for line no(useful for error) and text read respectively.
                                                                    yytext[0] to get first character. OR atoi(yytext)
                                                                    yylval.id (where id is union type)- fixes id and returns whatever.
                                                                    when parser invokes these- the case statements, etc is done by them
                                                                    and we get readymade value inside our "class"
                                                                call it till yylex returns null (EOF)
                                                                action may say return the corresponding number code.
                                                                    or may say perform some computation or print on console.
                                                        when? on seeing return statement in action code(?)
                                        Perform Lex
                                            gcc lex.yy.c -ll
                                                -ll option to grab main() from the lex library.
                                            gcc myscanner.c lex.yy.c -o myscanner
                                                Easy to write a compiler but biggies are complicated.
                                                dbName is written b4 identifier else it will capture the "dbName" as identifier.
                                            ./a.out
                            Parser- 
                                Does semantic processing on the stream of tokens produced by lex.
                                Overview
                                    a = b + c * d
                                    Lexical Analyser
                                    id1 = id + id * id
                                    Syntax Analyzer
                                    Parse Tree is built
                                    Hook up actions like machine codes load id3, mult id2, add id1, store id1, etc.
                                Input
                                    mylang.y
                                        Regex
                                            FirstPart
                                                Preamble- C declarations in 
                                                    %{
                                                        declarations
                                                            C libs, global declarations; yyerror(char *s);
                                                    %}
                                                yacc definitions
                                                    %start tells the start symbol of productions
                                                    %token- different token types coming from lex. (terminals given a class eg identifier)
                                                        %token (tokenName) or %token < unionType > number
                                                    %type to represent types (non-terminals?)
                                                        types and tokens can be associated with a data type or not
                                                    %union associates datatype with a tokens, or different values my lex can return. works similar to union in C.
                                                        same storage area for different things.
                                                        Eg- %union {
                                                                int num;
                                                                char id;
                                                            }
                                            %%
                                            ProductionAction
                                                Regex
                                                    GrammarRule     Action
                                                Production
                                                    gets CFG, action on match and main function (not necessary)
                                                    multiple right hand sides may follow separated by |
                                                    Regex
                                                        (lhs):(rhs)     [{]CStatements+[}] 
                                                            [ | (rhs)    [{]CStatements+[}]]*
                                                Action- C statements in code block optional.
                                                    CStatements
                                                        $1,$2
                                                            references to every symbol rhs of grammar (values associated with them)
                                                        $$
                                                            reference to lhs of grammar (value associated with it)
                                                            $$ = $1 (by default)
                                                            ?this is pushed into stack (can be referred to later)
                                                        can call function definitions in 3rd part.
                                            %%
                                            ThirdPart
                                                valid C code that supports the language processing
                                                symbol table implementation
                                                functions that might be called by actions associated with the productions in the second part.
                                                function definitions that can be invoked by actions
                                                main functions
                                                    int main(void){
                                                        for(int i=0;i< 52;i++)
                                                            symbols[i] = 0;
                                                        return yyparse();       //internally invokes yylex() and switch case for return values.
                                                    }


                                        Grammar meanings
                                Process
                                    yacc -d calc.y
                                        -d option is necessary for header generation- necessary for lexical analyser.
                                Output
                                    C code of parser y.tab.c and y.tab.h
                                        from types and tokens -> .h file generated (used by lex to return symbols.)
                                    yyparse in invoked by main function (within/out). yyparse implicitly uses yylex() to make tokens (all at once)
                                        yyparse iteratively parses tokens until EOF or error
                                        Syntax analyser uses yacc generated code.

                                Usage
                                    Processing
                                        gcc y.tab.c lex.yy.c source.c -o source
                                        source < sourceCode > compiledCode
                                    Input 

                                            Specification of your tokens (pattern class- a set with elements conforming to the regular set.Eg- a set of identifiers (sharing the property of pattern)) calc.l

                                    Working
                                            Calls Lex
                                                    first part of lex is optional.
                                                    when a pattern matches (1st one), corresponding action is taken
                                                            '+' is alphabet but + in action side for C code- is fundamental addition
                                                    get the pattern value (that matched) from yytext (string)
                                                            values and data structures are with lex.yy.c and can be invoked in other pattern(?)
                                                            yylval (used by lexical analyser) is temporary data structure (union)(refer to y.tab.h produced by yacc calc.y which in turn comes from first part of .y)
                                                                    yylval.id = yytext[0]; followed by return identifier;
                                                                    means get the first char of pattern that emerged and save it as member var "id" of type identifier.
                                                                    yylval.f is global value in parser, associated with this token
                                                                            regular expression for floating point is written
                                                                    shift reduce means error in grammar.
                                                    "return"- passes control back to calling program with return value
                                                            return x means return the constant corresponding to x defined in y.tab.h 
                                                                    x is deciphered in parser code- x is a token wrapper(label) REL toffee brand but every toffee may have different colors.
                                                            Give a name to those (wrappers) eg- identifier can have id= empId,csStud,les_1 in different cases- but all are identifiers (banner) or a set of identifiers.
                                                            "return" brings control back to the program invoking lex.
                                                    they are all terminals. Their label-names and type (union with datatype) is speciified in yacc file as %token
                                                    yywrap necessary when many files involved
                                                    Output- Return a C code- lex.yy.c which supports yylex() fn call, returns what is specified in return clause, yylineNo and yytext (the pattern instance)
                                            the streak of tokens thus produced are used as input to settle grammar rules.
                                                    as soon as a grammar production rule satisfies, the corresponding action is taken (print,compute cumulatively) as stack push pops are done
                                                            as it builds parse tree- there is a room for generating code and interpret meaning or associate C statements
                                                            the action can interact with classes/methods defined outside of itself (use include preprocessor directives) to get services.
                                                            action can use function definitions in 3rd part of yacc file (declared in 1st part).
                                                                    symbolVal() function is to look up symbol table (A-Zthen a-z column entries against 52 cells 0 for A and 26 for a)
                                                            when final match is done. the action is invoked and yyparse() fn returns.
                                                            $$ left side symbol and $1- first symbol on rhs (T,N included)
                                                            In expressions, the rhs evaluate the value and assigns to the lhs (pushed into stack)
                                                            action section contains C statement[s]
                        </YaccLex>
                        <MakeFile>
                            calc: lex.yy.c y.tab.c
                                    gcc -g lex.yy.c y.tab.c -o calc
                            lex.yy.c: y.tab.c calc.l
                                    lex calc.l
                            y.tab.c: calc.y
                                    yacc -d calc.y
                            clean: 
                                    rm -f lex.yy.c y.tab.c y.tab.h calc
                        </MakeFile>
                    </Tools>
                </CompilerDesign>
            </TOC>
            <AFV> aka Automated Formal Verification
                aka Modeling Checking
                Reference- https://www.youtube.com/channel/UCUXDMaaobCO1He1HBiFZnPQ/videos
                <ModelChecking>
                    Model Checking
                    Many devices come with piece of code tht control its working- controller
                            airplane controller- decide trajectory on parameters
                            we want controller to be reliable.
                            must satisfy requirements- give inputs and outputs to check
                            when number of components increase- manual checking is difficult- errors may go unnoticed
                            Solution- make Mathematical model of controller and write its requirements in formal notation
                                    our challenge is reduced to if mathematical model (of i/o) conforms to formal notations (requirements)
                                    There are tools available to do that.
                                    This approach is called Model checking- 96,07 turing awards
                    In the course (meant for CS)
                            How to model system as extension of FSM
                            How specify requirements as formal notations
                            Algos for checking these reqt on the models (back end algos)
                            electricals also can use it- Engrs embedded augment testing procedures.
                            basic BFS, DFS is preferable.
                    Unit1- Models of Code
                    Introduction to course
                            What are we interested in Software controllers- code that controls the working of an ICT (Information and Communication) device.
                                    Eg- ATM- working controlled by program that listens to user inputs- does manipulations and generates output action- cash, display balance, etc
                                    Eg- Airplane- lots of code to decide trajectory based on location, weather, etc.
                                    Eg- Medical- Pacemaker- for heart patients to regulate heart beat- generates electical signals to generate a heart beat.
                                    Eg- Traffic lights controller, Automatic gear control.
                            Controller does (many safety critical systems are controlled by code)
                                    takes input
                                    takes decisions
                                    gives output action
                            How reliable is controlling code
                                    correct- decision making should be correct
                                    Complete- all possible scenarios should be considered.
                            Costly bugs (dramatic consequences)
                                    Intel Pentium2 processor- floating division error code lost 475 US dollars.
                                    Ariane5 rocket- crash 26 sec after launch in 96
                                    Therac25 radiation therapy machine- 6 patients died of radiation overdose.
                            Goal- make low defect software controllers
                                    traditional testing insufficient for safety critical systems- give test cases (not exhaustive- sw may incorrect execution)
                                    new verification technology called model checking
                                            by clarke, emerson, sifakis
                                            uses FSM to model and verify controllers
                            Applications
                                    Hardware- Intel, IBM, Synopsys
                                    Avionics- Rockwell Collins, Honeywell
                                    Automobiles- Toyota
                                    Space- NASA, European Space Agency
                                    Others- Microsoft Research, Tata, Mathworks
                                    Research by many university
                            Why do this course?
                                    Various industries adopting model checking into their design cycle
                                    Need engineers qualified in model checking technology
                                    scope for higher studies
                                    Introduction to techniquees and tools
                                    Book: Principles of Model Checking (MIT Press)
                                    I will prefer pretty pictures in place of scary maths notations
                                    No pre-req (BE, ME welcome from CS/IT/EEE/ECE)
                    Modeling code behavior
                            in succinct way- with eg
                            ATM- edge labelled by input/event
                            Idle Code --Insert_card--> Pin? --correct--> TRAN --balance --> BAL --print--> MORE --yes--> TRAN
                                    A complete graph can be obtained
                                    States, Transitions- triggers can be external or internal (insert card or correct value)
                                    Thus we represent a code inside of an ATM- this is transition system, or FSM, state transition graphs, etc.
                            Eg- Vending Machine- insert coin- choose beverage and get it.
                                    States- Idle, select, Cola, water
                                    triggers- coin, cola, water, get_cola, get_water
                            Terminology-
                                    Terminal state- if no outgoing transition from the state.
                                    Execution of FSM- can be infinite or finite which terminates in Terminal state.
                    Modeling Hardware Ckts
                            OR, AND, NOT, XOR- Gate is nth but ckt
                                    draw boolean function repr for them
                                    we can combine them to generate different outputs for input configuation
                                    Sequential hardware ckt- value depends on previous value of register.
                            Sample execution for a ckt diagram- from a start state of 100
                                    we have 4 states in this case- initial state be those with r=0
                                    all possible execution trace can be used to represent behavior of ckt in form of a graph.
                                    Here, >= 1 initial state and >=1 transition- NFA
                            Transtion Systems types
                                    Deterministic- Single initial state and unique transition
                                    Non-deterministic- Many initial state OR multiple transitions for an input
                                    Eg- refer diagrams
                                    Eg- ATM was deterministic, so goes with vending machine. Hardware ckt was NFA- to model incomplete information.
                    Modeling Data Dependent Programs
                            That manipulate data
                            Variables + Conditional branching + Assignments
                            The vending machine's working depends on number of water cans (nwater, ncola, max- max number of bottles for cola and water)
                                    with every transition- nwater -= 1 on get_water. select state to W iff nwater > 0
                                    Thus guards can be put for all transitions- this is called Program Graph- advanced to transition system.
                            Consider a program
                                    while(x > 0)
                                            if(x % 2 == 0) x -= 2;
                                            else x--;
                                    decide locations and complete the CFG.
                    Modelling Concurrent Systems
                            Independent-
                                    Eg- 2 parallel roads- traffic lights modelled by transition system.
                                            joint behavior of 2 lights- cross product.
                                            TrafficLight1 ||| TrafficLight2- ||| means interleaved (behavior)
                                    Eg- Concurrently running programs- 
                                            Interleaving of TS1 and TS2
                                    Eg- TS1 ||| TS2 ||| TS3 |||... (Cartesian Product of all)
                            Shared Variables
                                    Conflicting values for x which is shared so former way doesn't work.
                                    TS(PG1 ||| PG2 ||| ...)
                                    Eg- Interleaving of programs
                                            Question- is value of x always between 0 and 200- any interleaving (execution trace) takes us to a state with x < 0
                                            there are tools available to answer such questions.
                                    Eg- Mutual Exclusion- No 2 processes can access the resource simultaneously.
                                            P1 thru Pn- access Shared Resource (variable, printer, etc)
                                            Goal: Modeling the protocols used for mutual exclusion.
                                                    The state with C1 and C2 doesn't exist
                            Shared Actions
                                    Eg- Book keeping system in a supermarket.
                                            barcode scanned by scanner/reader, input for a program which search DB and gets price, sends price to printer to print it.
                                            BCR || BP || P (These processes change states together on seeing an input) (|| called handshake operator)
                                            the shared actions (triggers) are called handshaking actions.
                                    Eg- Train gate controlling system
                                            Railway crossing with automated gate controller
                                            train signal sent and controller lowers the gates
                    Unit2- Model Checker NuSMV- Model checking software
                            Model-checking tools
                            How reliable is the code?
                                    requirements may be like- x is in range [0,50], x < y always in code.
                                    x > 50 => y > 200- give test cases and check but manual difficult on huge size- errors can go unnoticed
                            Eg of requirements- x >= 0 always
                            Eg of requirements- Mutual exclusion property
                            Input the model and reqt in formats of model checker- the checker automatically solve the above question
                            Eg of Open Source model checkers- 
                                    SPIN- well-suited for concurrent systems
                                    NuSMV- Well-suited for hardware ckts, more reqt can be checked
                                            http://nusmv.fbk.eu/NuSMV/download/getting-v2.html -> NuSMV 2.5.4 (or sth) -> Download binary files -> Register to download
                                            Mac users- www.macupdate.com/app/mac/46133/nusmv
                                    which is better? depends on the question trying to solve.
                    Simple models in NuSMV
                            NuSMV -int (int means interactive mode)
                            read_model -i intro-demo.smv
                            flatten_hierarchy
                            encode_variables
                            build_model
                            pick_state -i (intial)
                            simulate -i -k 10 (execution for 10 transitions)
                            print_reachable_states -v
                    Checking Requirements in NuSMV
                            Execution is just a path on the transition system
                            Transition system satisfies a requirement means all its executions satisfy the requirement
                            Requirement type 1: G (global)
                                    Execution satisfies G(expr) if expr evaluates to T in all its states.
                                    Transition system satisfies G(expr) if all its executions satisfy G(expr)
                                    G(x >= 0), is it globally true?
                                    G(request=0)- it becomes 1 so doesn't support.
                                            some executions do satisfy but not TS as a whole.
                                    command in NuSMV- check_ltlspec -p "G (x >=0)"
                            Requirement type 2: F (future)
                                    F(x >= 5) means st in future the value of x becomes >= 5
                                    TS of above PG with intial value x=0 satisfies F(x >= 5)
                                    Execution satisfies F(expr) if expr evaluates to T in one of its states
                                    Transition System satisfies F(expr) if all of its executions satisfy F(expr)
                                    check_ltlspec -p "F (x >= 5)"
                                    check_ltlspec -p "F(request = TRUE)
                            Combining G and F
                                    G(request=1 => F(status=busy))- if request =1, status become busy in future
                                    TS satisfies G(request => F(status=busy))
                                    check_ltlspec -p "G(request=TRUE -> F status=busy)"
                    Hardware Verification using NuSMV
                        Define when the value of y in a state depends on current values of x and r
                        not specified in states in NuSMV means refer above for values
                        Empty assign block means all possible transitions and empty init means all are init states.
                        Assign block when TRUE case means all other than mentioned options


                </ModelChecking>
            </AFV>
        </Maths>
        <DigitalLogic></DigitalLogic>
        <InstrumentationAndControl></InstrumentationAndControl>
        <COA></COA>
        <About>
            We program in an environment- taking services- but compiler hides that from us.
            Program may need persistence to remember data across sessions, devices, etc.
                    can't keep worlds' data in MM.
            Program gets input in a format- gotta know how to read it.
        </About>
        <ComputerContext>
            <What>
            Computation and Data Management
            Is A system
                    There are components
                    They interact amongst themselves
                to give outcome as a whole.
            </What>
            <Components>
                    @Body Intelligence
                    <Hardware>
                            @Body- Does all the physical work- without thinking, analysis or solving of its own.
                    </Hardware>
                    <Software>
                            <Why>
                                Automate the physical series of work.
                            </Why>
                            <WHAT>
                                    @Intel- Guides Hardware what and how to do a meaningful task from its capabilities or solve a problem.
                                            Employ use of binary. At a given point of time, which all tasks should be carried on and sequence thereof so that end result is obtained.
                                                    Difficult to remember so Programmer writes source code in a PL- and PL's "Compiler" Compiles/translates it to machine.
                                            what and how- means to instruct- Sequence of instructions make program and seq of prog make software.					
                                                    Exploiting instructions types available in specific terms.
                                                            I/O
                            </WHAT>
                            <Types>
                                    <SystemSoftware>
                                            <What>						
                                                    Providing/maintaining environment/platform for programmer or user to create and run applications.
                                                    New functions emerge for programmer that were not available at H/W level.
                                                    Interface b/w Hardware and Applications- transparent to user.
                                            </What>
                                            <VIZ>
                                                    <BIOS>
                                                            also, device drivers
                                                            Stored on ROM chip- Basic fn to operate/control H/W- connected or built in.
                                                                    1st code on Computer ON
                                                                            Steps Followed
                                                                                    Controller- Identifies and Initializes all devices connected
                                                                                    POST- Power ON Self Test- that all devices working correctly.
                                                                                    Booting- Locates S/W on peripheral/storage devices.
                                                                                            Loads it.
                                                                                            Executes it and gives it control.
                                                                            Access- Has UI menu- Pressing a key when PC starts.
                                                                                    Can configure H/w
                                                                                    Set System Clock.
                                                                                    Enable / disable components.
                                                                                    Eligible potential boot devices and password prompts.
                                                                                    System Summary.
                                                    </BIOS>
                                                    <OperatingSystem>
                                                            Makes System Convenient & Efficient to Use.
                                                                    Offering generic services for user apps (doing mundane tasks).
                                                                    GUI- Icon to launch & work on an application. Interface to hide instructions.
                                                            ?Conceptualizing New things- like files to discern diffn tasks.
                                                            ?Relieving Programmer of trivial and mundane routine low-level (Machine) tasks->Enabling logic.
                                                                    Eg- Reading Input from Keyboard should be an assumption for a programmer. Hidden.
                                                                    Eg- Web Server- Many progs running- which one to wait or allocate resources. Stop- Suspending from processor-> Need a control policy->Algo to allocate resources.
                                                    </OperatingSystem>
                                            </VIZ>
                                    </SystemSoftware>
                                    <Utilities>
                                            <WHAT>
                                                    Analyse,configure, optimize, maintain the system
                                                    Use system calls given by the OS
                                                    may be requested by application program.
                                            </WHAT>
                                            <VIZ>
                                                    Disk Defragmentation- Dec Fragmentation in Disk.
                                                    Disk Checkers- Find corrupted file/area & delete them- maybe because not saved properly.
                                                    Disk Cleaners- Disk fullhelp user decide in deletion.
                                                    Disk space analysers- Space usage by getting size of folder,etc.
                                                    Disk Partitions- to divide into logical disks and file system to OS.
                                                    Back-up utilitities- copy of all information on disks for restorage on failure.
                                                    Disk Compression- inc space in disk by compressing data.
                                                    File Managers- Routine Data-Management Task.
                                                    System Profilers- S/W and H/w attached on system.
                                                    Anti-Virus Utilities
                                                    Data Compression- on files.
                                                    Cryptographic utilities
                                                    Laucher Application
                                                    Registry Cleaners- Clean and optimize windows Registry by deleting old keys no longer in use.
                                                    N/W utilities- Analyze connectivity,configure N/W setting, check data transfer and lopg events.
                                                    CLI,GUI- to make changes by OS.
                                            </VIZ>
                                    </Utilities>
                                    <ApplicationSoftware>
                                        Solves a particular or specific problem of user. "Computer Program"
                                                using computer capabilities to perform user defined task.
                                                @Using system softwares like Electric bulb uses electric power generator.
                                        Eg- DB,Spreadsheets,IDE,Games,Web Browser,Media Players, Educational S/W, Data Communication,Statistical Software.
                                        May Bundle multiple apps together as a package- APPLICATION SUITE.
                                        <Editors>
                                            editor- textpad- 8.1.1
                                            notepad++- 7.3
                                                    deleting multiple databases
                                                    used editor to copy paste and adding drop database
                                                                                                    Replace option in text editor- choose option extended for \t\n and regular expression for regex searches
                                                    can write a shell script to do it
                                                            write_([0-9]+) replace with drop database write_$1; in textbox for making queries!
                                                            writ([a-z]+)_([0-9]+) by drop database writ$1_$2;
                                                            viz
                                                                    drop database write_1488537983465;
                                                                    drop database writepoints_1488539026695;
                                            vi
                                                    esc :%s/swallowd/swallowed
                                                    Search- esc.jpg/spider
                                                    :set number
                                                    go to a line- :86, or vi +86 filename
                                                    End of file- esc+shift+G or :$.
                                                    Go to start of file- esc + G + G; :1
                                        </Editors>
                                    </ApplicationSoftware>
                            </Types>
                    </Software>
            </Components>
        </ComputerContext>
        <AbstractOfAllSubjects>Information Theory- Study of how information flows.
            TOC- Theory of computability.

            Digital Image Processing- Image to processed image or feature added/identified.
            Pattern Recognition- Image to description- eg- Satellite images and regions identified. Criminal face identified.
                    applies to all human senses.
            Machine Perception- Ability of machine to interpret image, sound, etc. Face Detection.
            Robotics- decision making based on input. Respond to stimuli.

            Neural Networks- make parallel computation effective modelling brain.
            Artificial Intelligence- How to represent and store knowledge.
            Machine Learning- How to enable machine to simulate human learning. Store i/p, remember, recall on stimuli.
                    Amazon product ads[?]
            Data Analytics- make sense out of data for decision making.


            Computer Graphics- From description to an artificial image.
            Data Visualization- description of data to image to capture biz reqt.



            Web frameworks devp was 1 prob that was addressed to avoid rework.
            IDE addressed devp process ability easy.
            OS devp was for facilitating application programs job's environment set.
                    Science of facilitation (kernel of life)
            CN at app layer uses information theory- protocol. Science of communication.
            DSA- Science of logic and reducing effort for problem solving (for all instances)- TOC in practice.
            DB- Science of dealing with data.
                    Data Models.
            Images taken is an electronics problem. Analysing an image may be a CS problem.
        </AbstractOfAllSubjects>
        <PuzzlesSolving>
            Puzzles
            25 horses- 3rd fastest
            1 marked pick the nut to make sure bomb is deactivated
            4 people on bridge with different speeds- 2 capacity- gantt chart. pipelining.
            2^10 bottles of alcohol- find #ppl reqd to tell poisoned bottle- encoding- 10 people (bits)
            9 balls- find with minimal balance usage.
            10 machines spitting bolts of 5 g but 1, 4.9g- tell it once on weight- 1*1+2*1+...k*(4.9)+..=find k.
            10 people hold 10 hats- white or black color- e1 can see numbers below it. tell hat on itself.
                    10th tells the parity (can be wrong)- 9th computes and tells its hat color and so forth.
            http://puzzlefry.com/top-50-common-interview-puzzles-with-answers/
            tell 1 thing that I don't know- salami slice- name of a dish.
            Find fastest 3 horses amongst 25
                    5 races to get the columns sorted. 
                    1 race to sort the fastest amongst the fastests - rearrange rows for sort along last column (being fast)
                    R1C5 is the fastest - what is input space for 2nd - R1C4 or R2C5; input space for 3rd - triangle excluding the corner. 5 horses they make.
                    7th race will determine for certain the 2nd and 3rd horses.
            Find ages of daughters - product is 72, sum = house number (admits not enough) ; oldest likes strawberries - found.
                    brute force on numbers ; need to chunk out irrelevant information and choose which matters.
            if  "condition"	printf ("Hello"); else printf("World"); //print hello world
                    !printf("hello")
        </PuzzlesSolving>
        <Uncat>
            <User>
                iso files are essentially archive file of an optical disc (image)
                        CDs DVDs even blu-ray discs and we want to create an exact copy of that disk we will create iso file 
                        Optical discs- you could lose disc, scratch, destroyed for some reason 
                        contains a specific piece of software that you need to install on the client machines 

                        creating iso image, allows us to burn new discs on demand
                        technology changes we use OD lesser- laptops don't come with 'drive holder'
                                proprietary software how to install?
                                create an iso file and then mount that iso file as if it is a drive on the computer allows you to be able to install software from that iso file
                                means mount an iso file is just like the equivalent of being able to put a CD or DVD into your computer and be able to run a process from there
                        different pieces of software that you can use in order to do this
                                free, paid; diff levels of functionality
                                disk imaging software, win cd emu is free
                                portable software is software that you don't have to install you can basically just double click and run it and we'll go
                                        earlier, we'd store all those iso files on shared drive on the server
                                        you can mount that iso image you can do whatever you need you can unmount it 
            </User>
            <Misc>
                Tools
                    https://www.math10.com/en/geometry/geogebra/fullscreen.html
                    Ctrl+F1 for showing ribbon on/off in outlook.
                    Use excel to find set difference.
                    Also solve the problem of pinpointing sound problems, etc.
                        Is device all right - works with other device. Is system all right - works with other headset.
                        is windows allowing? is application allowing - vlc or browser?
                        Is device driver outdated?
                        How to make java read regedit to make an interesting appication - or other language.
                    Solve the problem of pin pointing the problem in computer networks
                        am I connected to internet - which DHCP gave me this IP - is it a valid IP / Private IP? List all DHCP or network providers!!
                        can I contact its DNS - what is its DNS IP btw? what did DNS look up bring? what all hops were made to reach there?
                        did packets reach me?
                Find elements from array that add up to a number - first could be finding thru a binary search but using again for second element is not using full potential cuz we know that the scope for next number has reduced to current to where we found previous number's counterpart.
                    again binary on the obtained scope vs linear from there - linear is guaranteed to finish it in O(n)
                    implement cat, ls are pretty simple programs
                    Double click a file - launch the program using extension-app association in windows - with file as an argument OR ask the program to open the file as its input
                    Make a shell program - which reads a set of commands in text with .sh extension and executes them on command prompt.
                            it uses fork to launch programs you desire.
                            editing a program using vi interface is asking vi program to write into file for us (which has write permission) - bash's write system call fails on the file.
                Making sure that numbers are not wasted
                    do database minus operation to find missing numbers and at session start set up apt data structure to represent a range of numbers.
                    array XOR, etc - not real
                    Perform hashing with offset and iterate over array to find missing numbers
                    sort the numbers and iterate over array while printing missing pieces
                software information in windows - wmic - product get name, version, installdate.
                CLI based program will be faster than browser rendering for user's request and response but comfort is more important than commands and syntax.
                    but processor does waste time in creating a response as user wants it.
                Using Geolocation thru GPS in Android
                    Using Ardino or Raspberry Pi for automation home.
                    https://www.forbes.com/sites/danielnewman/2017/12/19/the-top-8-iot-trends-for-2018/#445cbde167f7
                    https://www.fitnessmagazine.com/health/injury/knee/pain-behind-knee/
                IF and KMaps
                    Solving Parallel switch case - with encoding the combination with a constant and apply switch case on that.
                    messages 			release
                    00 - save button or sth - release clicked = 0, release success = na
                    01 - release successful - release clicked = 1, release success = 1
                    10 - other button failed - release clicked = 0, released success = na
                    11 - release failed - release clicked = 1, release success = 0.
                    Can make K-Map to solve it better.
                    I could have done it as release success variable is dependent on release clicked so only 2 simple if clause but
                            difficult to understand because very non-intuitive
                            developer may forget dependence and can result in blunders in coding
                            prefer creating codes - 1 variable with 4 values than 2 boolean variables with 1 dependent on another.
                Architecture to HLD. OR Code to Architecture.
                    Or Working System to UML Diagram.
                    https://en.wikipedia.org/wiki/Software_architecture
                How to make a program that will automatically download quotes from internet and show on desktop as background.
                    well if folder that it picks from is updated, so will desktop bg.
                IDE Making
                    void runCommand(String command)
                    {
                        try {
                            ProcessBuilder builder = new ProcessBuilder(
                                    "cmd.exe", "/c", command);
                            builder.redirectErrorStream(true);
                            Process p = builder.start();
                            BufferedReader r = new BufferedReader(new InputStreamReader(p.getInputStream()));
                            String line;
                            while (true) {
                                line = r.readLine();
                                if (line == null) { break; }
                                System.out.println(line);
                            }
                        } catch (IOException ex) {
                            Logger.getLogger(FileToClass2.class.getName()).log(Level.SEVERE, null, ex);
                        }


                    }

                    void createClass(String dir, String filename)
                    {
                        //TODO: stop using exact java path / compile all .java in a dir
                        runCommand("cd "+dir+" && \"C:\\Program Files\\Java\\jdk1.8.0_91\\bin\\javac\" " + filename);
                    }

                    void runClass(String dir, String filename)
                    {
                        //TODO: allow use of packages etc
                        runCommand("cd " + dir + " && java " + filename);
                    }
                    //use swings, etc framework and invoke processes using command prompt or system calls
                Simple Scraper at work
                    import java.net.*;
                    import java.io.*;


                    public class Grabber {

                      public static void main(String[] args) {

                        int port = 80;

                        for (int i = 0; i < args.length; i++) {
                          try {
                             URL u = new URL(args[i]);
                             if (u.getPort() != -1) port = u.getPort();
                             if (!(u.getProtocol().equalsIgnoreCase("http"))) {
                               System.err.println("Sorry. I only understand http.");
                               continue;
                             }
                             Socket s = new Socket(u.getHost(), port);
                             OutputStream theOutput = s.getOutputStream();
                             // no auto-flushing
                             PrintWriter pw = new PrintWriter(theOutput, false);
                             // native line endings are uncertain so add them manually
                             pw.print("GET " + u.getFile() + " HTTP/1.0\r\n");
                             pw.print("Accept: text/plain, text/html, text/*\r\n");
                             pw.print("\r\n");
                             pw.flush();
                             InputStream in = s.getInputStream();
                             InputStreamReader isr = new InputStreamReader(in);
                             BufferedReader br = new BufferedReader(isr);
                             int c;
                             while ((c = br.read()) != -1) {
                               System.out.print((char) c);
                             }
                          }
                          catch (MalformedURLException ex) {
                            System.err.println(args[i] + " is not a valid URL");
                          }
                          catch (IOException ex) {
                            System.err.println(ex);
                          }

                        }

                      }

                    }
                    /*
                    This is the beginning of a typical response:

                    utopia% java Grabber http://students.poly.edu:80
                    HTTP/1.0 200 OK
                    Date: Thu, 17 Apr 1997 20:11:14 GMT
                    Server: Apache/1.1.3
                    Content-type: text/html

                    <title>Polytechnic University's Student Council Server</title>
                    < body bgcolor="white" link=#0000dd vlink=#0000dd >

                    < img src="http://www.poly.edu/images/poly_3d.jpeg" alt="" >
                    How does this differ from essentially the same program we wrote a little earlier that used URL instead of sockets?

                */
            </Misc>
        </Uncat>
</Foundation>